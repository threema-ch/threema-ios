// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: md-d2d-history.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// ## History Exchange Protocol
//
// This protocol specifies how to transfer the conversation history from one
// device to another.
//
// ### Terminology
//
// - `SD`: Source device
// - `DD`: Destination device
// - `DGHEK`: Device Group History Exchange Key
//
// ### Key Derivation
//
//     DGHEK = BLAKE2b(key=DGK, salt='he', personal='3ma-mdev')
//
// ### Protocol Flow
//
// SD or DD may choose to start the protocol. If DD starts the protocol it is
// _requesting to receive conversation history data_. If SD starts the
// protocol it is _offering to send conversation history data_.
//
// If SD started the protocol:
//
// - `purpose` must be set to _offer to send history data_.
// - SD takes the role of RID
// - DD takes the role of RRD
//
// If DD started the protocol:
//
// - `purpose` must be set to _request to receive history data_.
// - DD takes the role of RID
// - SD takes the role of RRD
//
// If the protocol was transitioned into from the Device Join Protocol:
//
// - ED becomes SD
// - ND becomes DD
// - the Connection Setup part is to be skipped since we already have a
//   connection
//
// #### Connection Setup
//
// RID creates an `rendezvous.RendezvousInit` by following the Connection
// Rendezvous Protocol. It encrypts the created `rendezvous.RendezvousInit`
// with `DGHEK`, wraps it in a `url.HistoryExchangeRequestOrOffer` and offers
// it in form of a URL or a QR code.
//
// RRD scans the QR code and parses the `url.HistoryExchangeRequestOrOffer`.
// It will then decrypt the contained `rendezvous.RendezvousInit`. Once
// decrypted, the enclosed `rendezvous.RendezvousInit` must be handled
// according to the Connection Rendezvous Protocol.
//
// Once the Connection Rendezvous Protocol has established at least one
// connection path, DD waits another 3s or until all connection paths have
// been established. Nomination is then done by DD following the Connection
// Rendezvous Protocol.
//
// Note that all messages on the nominated connection path must be end-to-end
// encrypted as defined by the Connection Rendezvous Protocol. All transmitted
// messages are to be wrapped in:
//
// - `FromDestinationDeviceEnvelope` when sending from DD to SD, and
// - `FromSourceDeviceEnvelope` when sending from SD to DD.
//
// #### History Transfer Flow
//
// If invoked by the Device Join Protocol or as soon as one of the connection
// paths has been nominated, DD should show ask the user for which timespan
// the user wants to transfer the conversation history from SD to DD.
//
// Once the user made a timespan selection, DD sends a `GetSummary` message
// and SD responds with a `Summary` message. This may be repeated.
//
//     DD ----- GetSummary ---> SD
//     DD <------ Summary ----- SD
//
// Once the user chooses to transmit the conversation history of a selected
// timespan, DD sends a `BeginTransfer` message.
//
//     DD --- BeginTransfer --> SD
//
// SD will now send `Data` (with `common.BlobData` ahead) repetitively until
// the conversation history of the selected timespan has been fully
// transmitted.
//
//     DD <- common.BlobData -- SD   [0..N]
//     DD <- common.Data     -- SD   [1]
//
// SD may now close the connection once all buffered data has been written. DD
// may close the connection when it received the last `Data` message.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Media type to transfer
enum History_MediaType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// All media should be transferred
  case all // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .all
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .all
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .all: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension History_MediaType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [History_MediaType] = [
    .all,
  ]
}

#endif  // swift(>=4.2)

/// Root message envelope for messages from the destination device (DD) to the
/// source device (SD).
struct History_FromDestinationDeviceEnvelope {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The enveloped message
  var content: History_FromDestinationDeviceEnvelope.OneOf_Content? = nil

  var getSummary: History_GetSummary {
    get {
      if case .getSummary(let v)? = content {return v}
      return History_GetSummary()
    }
    set {content = .getSummary(newValue)}
  }

  var beginTransfer: History_BeginTransfer {
    get {
      if case .beginTransfer(let v)? = content {return v}
      return History_BeginTransfer()
    }
    set {content = .beginTransfer(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The enveloped message
  enum OneOf_Content: Equatable {
    case getSummary(History_GetSummary)
    case beginTransfer(History_BeginTransfer)

  #if !swift(>=4.1)
    static func ==(lhs: History_FromDestinationDeviceEnvelope.OneOf_Content, rhs: History_FromDestinationDeviceEnvelope.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.getSummary, .getSummary): return {
        guard case .getSummary(let l) = lhs, case .getSummary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginTransfer, .beginTransfer): return {
        guard case .beginTransfer(let l) = lhs, case .beginTransfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Root message envelope for messages from the source device (SD) to the
/// destination device (DD).
struct History_FromSourceDeviceEnvelope {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The enveloped message
  var content: History_FromSourceDeviceEnvelope.OneOf_Content? = nil

  var summary: History_Summary {
    get {
      if case .summary(let v)? = content {return v}
      return History_Summary()
    }
    set {content = .summary(newValue)}
  }

  var blobData: Common_BlobData {
    get {
      if case .blobData(let v)? = content {return v}
      return Common_BlobData()
    }
    set {content = .blobData(newValue)}
  }

  var data: History_Data {
    get {
      if case .data(let v)? = content {return v}
      return History_Data()
    }
    set {content = .data(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The enveloped message
  enum OneOf_Content: Equatable {
    case summary(History_Summary)
    case blobData(Common_BlobData)
    case data(History_Data)

  #if !swift(>=4.1)
    static func ==(lhs: History_FromSourceDeviceEnvelope.OneOf_Content, rhs: History_FromSourceDeviceEnvelope.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.summary, .summary): return {
        guard case .summary(let l) = lhs, case .summary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.blobData, .blobData): return {
        guard case .blobData(let l) = lhs, case .blobData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Sent by DD to get a summary of the conversation history available on SD.
///
/// When receiving this message:
///
/// 1. If `BeginTransfer` has been received before, close the connection and
///    abort these steps.
/// 2. If summary data is currently being retrieved for a previous `GetSummary`
///    message, abort that process.
/// 3. If cached properties from a previous `GetSummary` message exist, discard
///    those properties.
/// 4. Filter `media` in the following way:
///    1. If the special media type _all_ is present, discard any other
///       entries.
///    2. Remove duplicate entries.
/// 5. Cache the requested properties, including the `id`.
/// 4. Retrieve the summary data for the given timespan and send a `Summary`
///    message with the same `id` back to DD. For outgoing messages, the
///    timespan refers to the time the message was created. For incoming
///    messages, the timespan refers to the time the message was received.
struct History_GetSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier of the summary request
  var id: UInt32 = 0

  /// Timespan to get a summary for
  var timespan: Common_Timespan {
    get {return _timespan ?? Common_Timespan()}
    set {_timespan = newValue}
  }
  /// Returns true if `timespan` has been explicitly set.
  var hasTimespan: Bool {return self._timespan != nil}
  /// Clears the value of `timespan`. Subsequent reads from it will return its default value.
  mutating func clearTimespan() {self._timespan = nil}

  /// Which types of media should be included
  var media: [History_MediaType] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timespan: Common_Timespan? = nil
}

/// Summary data for a given timespan as requested by DD.
///
/// When receiving this message:
///
/// 1. If `BeginTransfer` has been sent in the meantime, discard this message
///    and abort these steps.
/// 2. If `id` matches the id sent in the most recently sent `GetSummary`
///    message, display the summary data to the user. The user may change the
///    properties (timespan, media types, etc.) which will trigger another
///    `GetSummary` message. When the user commits to the currently selected
///    properties, it sends a `BeginTransfer` message.
struct History_Summary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Refers to the unique identifier of the summary request
  var id: UInt32 = 0

  /// Amount of messages that would be transferred
  var messages: UInt32 = 0

  /// Estimated size in bytes of the messages including only the requested
  /// media types
  var size: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Sent by DD to initiate the conversation history transfer for a given
/// timespan.
///
/// When receiving this message:
///
/// 1. If `BeginTransfer` has been received before, close the connection and
///    abort these steps.
/// 2. Lookup the cached requested properties for the given `id`. If none could
///    be found, close the connection and abort these steps.
/// 3. Let `messages` an empty list. Let `size` be `0`.
/// 4. For each remaining message to be sent for the requested timespan:
///    1. If the media types match this message, send the blob as a
///       `common.BlobData` message and update `size` with the byte size of
///       the media.
///    2. Append the current message to `messages` and update `size` with the
///       byte size of the message (without media).
///    3. If `messages` contains 100+ items or `size` is greater 100 MiB, abort
///       the loop.
/// 5. Send a `Data` message with the included `messages`.
/// 6. If there are remaining messages, restart these steps from the beginning.
/// 7. Wait until all buffered data on the connection has been written. Then,
///    close the connection.
struct History_BeginTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Refers to the unique identifier of the summary request
  var id: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// One or more messages of the conversation history sent by SD.
///
/// When receiving this message:
///
/// 1. Let `blobs` be the previously received set of `common.BlobData` prior to
///    this message.
/// 2. For each message of `messages`:
///    1. If the message is not in the expected timespan, close the connection
///       and abort these steps.
///    2. If the message type is unknown or cannot be parsed, discard the
///       message and abort these steps.
///    3. Store the message. If the message already exists, overwrite it.
///    4. If the message refers to a Blob ID, lookup the Blob in `blobs`. If
///       the Blob could be found, store it persistently and remove it from
///       `blobs`.
/// 3. Log a warning for each remaining Blob in `blobs` and discard them.
/// 4. If `remaining` is `0`, close the connection and consider the
///    conversation history transfer successfully completed.
struct History_Data {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Past messages
  var messages: [History_PastMessage] = []

  /// Amount of messages remaining to be transferred **after** this message
  var remaining: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Contains a past incoming or outgoing message.
struct History_PastMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: History_PastMessage.OneOf_Message? = nil

  var incoming: History_PastIncomingMessage {
    get {
      if case .incoming(let v)? = message {return v}
      return History_PastIncomingMessage()
    }
    set {message = .incoming(newValue)}
  }

  var outgoing: History_PastOutgoingMessage {
    get {
      if case .outgoing(let v)? = message {return v}
      return History_PastOutgoingMessage()
    }
    set {message = .outgoing(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Message: Equatable {
    case incoming(History_PastIncomingMessage)
    case outgoing(History_PastOutgoingMessage)

  #if !swift(>=4.1)
    static func ==(lhs: History_PastMessage.OneOf_Message, rhs: History_PastMessage.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.incoming, .incoming): return {
        guard case .incoming(let l) = lhs, case .incoming(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.outgoing, .outgoing): return {
        guard case .outgoing(let l) = lhs, case .outgoing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// A reaction to a message
struct History_Reaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unix-ish timestamp in milliseconds when the reaction happened.
  var at: UInt64 = 0

  var type: History_Reaction.TypeEnum = .acknowledge

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The reaction type.
  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Message explicitly acknowledged
    case acknowledge // = 0

    /// Message explicitly declined
    case decline // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .acknowledge
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .acknowledge
      case 1: self = .decline
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .acknowledge: return 0
      case .decline: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension History_Reaction.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [History_Reaction.TypeEnum] = [
    .acknowledge,
    .decline,
  ]
}

#endif  // swift(>=4.2)

/// A past outgoing message
struct History_PastOutgoingMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Enclosed outgoing message
  var message: D2d_OutgoingMessage {
    get {return _message ?? D2d_OutgoingMessage()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  /// Unix-ish timestamp in milliseconds for when the message has been sent
  var sentAt: UInt64 = 0

  /// Optional Unix-ish timestamp in milliseconds for when the message has been
  /// marked as read
  var readAt: UInt64 {
    get {return _readAt ?? 0}
    set {_readAt = newValue}
  }
  /// Returns true if `readAt` has been explicitly set.
  var hasReadAt: Bool {return self._readAt != nil}
  /// Clears the value of `readAt`. Subsequent reads from it will return its default value.
  mutating func clearReadAt() {self._readAt = nil}

  /// Optional last reaction to the message
  var lastReactionAt: History_Reaction {
    get {return _lastReactionAt ?? History_Reaction()}
    set {_lastReactionAt = newValue}
  }
  /// Returns true if `lastReactionAt` has been explicitly set.
  var hasLastReactionAt: Bool {return self._lastReactionAt != nil}
  /// Clears the value of `lastReactionAt`. Subsequent reads from it will return its default value.
  mutating func clearLastReactionAt() {self._lastReactionAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _message: D2d_OutgoingMessage? = nil
  fileprivate var _readAt: UInt64? = nil
  fileprivate var _lastReactionAt: History_Reaction? = nil
}

/// A past incoming message
struct History_PastIncomingMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Enclosed incoming message
  var message: D2d_IncomingMessage {
    get {return _message ?? D2d_IncomingMessage()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  /// Unix-ish timestamp in milliseconds for when the message has been received
  var receivedAt: UInt64 = 0

  /// Optional Unix-ish timestamp in milliseconds for when the message has been
  /// marked as read
  var readAt: UInt64 {
    get {return _readAt ?? 0}
    set {_readAt = newValue}
  }
  /// Returns true if `readAt` has been explicitly set.
  var hasReadAt: Bool {return self._readAt != nil}
  /// Clears the value of `readAt`. Subsequent reads from it will return its default value.
  mutating func clearReadAt() {self._readAt = nil}

  /// Optional last reaction to the message
  var lastReactionAt: History_Reaction {
    get {return _lastReactionAt ?? History_Reaction()}
    set {_lastReactionAt = newValue}
  }
  /// Returns true if `lastReactionAt` has been explicitly set.
  var hasLastReactionAt: Bool {return self._lastReactionAt != nil}
  /// Clears the value of `lastReactionAt`. Subsequent reads from it will return its default value.
  mutating func clearLastReactionAt() {self._lastReactionAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _message: D2d_IncomingMessage? = nil
  fileprivate var _readAt: UInt64? = nil
  fileprivate var _lastReactionAt: History_Reaction? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "history"

extension History_MediaType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL"),
  ]
}

extension History_FromDestinationDeviceEnvelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FromDestinationDeviceEnvelope"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "get_summary"),
    2: .standard(proto: "begin_transfer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: History_GetSummary?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .getSummary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .getSummary(v)
        }
      }()
      case 2: try {
        var v: History_BeginTransfer?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .beginTransfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .beginTransfer(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .getSummary?: try {
      guard case .getSummary(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .beginTransfer?: try {
      guard case .beginTransfer(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: History_FromDestinationDeviceEnvelope, rhs: History_FromDestinationDeviceEnvelope) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension History_FromSourceDeviceEnvelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FromSourceDeviceEnvelope"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "summary"),
    2: .standard(proto: "blob_data"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: History_Summary?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .summary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .summary(v)
        }
      }()
      case 2: try {
        var v: Common_BlobData?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .blobData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .blobData(v)
        }
      }()
      case 3: try {
        var v: History_Data?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .data(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .summary?: try {
      guard case .summary(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .blobData?: try {
      guard case .blobData(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .data?: try {
      guard case .data(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: History_FromSourceDeviceEnvelope, rhs: History_FromSourceDeviceEnvelope) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension History_GetSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "timespan"),
    3: .same(proto: "media"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timespan) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.media) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if let v = self._timespan {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.media.isEmpty {
      try visitor.visitPackedEnumField(value: self.media, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: History_GetSummary, rhs: History_GetSummary) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._timespan != rhs._timespan {return false}
    if lhs.media != rhs.media {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension History_Summary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Summary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "messages"),
    3: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.messages) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.messages != 0 {
      try visitor.visitSingularUInt32Field(value: self.messages, fieldNumber: 2)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: History_Summary, rhs: History_Summary) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension History_BeginTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BeginTransfer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: History_BeginTransfer, rhs: History_BeginTransfer) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension History_Data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Data"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
    2: .same(proto: "remaining"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.remaining) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    if self.remaining != 0 {
      try visitor.visitSingularUInt64Field(value: self.remaining, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: History_Data, rhs: History_Data) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.remaining != rhs.remaining {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension History_PastMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PastMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "incoming"),
    2: .same(proto: "outgoing"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: History_PastIncomingMessage?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .incoming(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .incoming(v)
        }
      }()
      case 2: try {
        var v: History_PastOutgoingMessage?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .outgoing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .outgoing(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.message {
    case .incoming?: try {
      guard case .incoming(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .outgoing?: try {
      guard case .outgoing(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: History_PastMessage, rhs: History_PastMessage) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension History_Reaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Reaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "at"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.at) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.at != 0 {
      try visitor.visitSingularUInt64Field(value: self.at, fieldNumber: 1)
    }
    if self.type != .acknowledge {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: History_Reaction, rhs: History_Reaction) -> Bool {
    if lhs.at != rhs.at {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension History_Reaction.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACKNOWLEDGE"),
    1: .same(proto: "DECLINE"),
  ]
}

extension History_PastOutgoingMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PastOutgoingMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .standard(proto: "sent_at"),
    3: .standard(proto: "read_at"),
    4: .standard(proto: "last_reaction_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.sentAt) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._readAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._lastReactionAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.sentAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.sentAt, fieldNumber: 2)
    }
    if let v = self._readAt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    if let v = self._lastReactionAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: History_PastOutgoingMessage, rhs: History_PastOutgoingMessage) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.sentAt != rhs.sentAt {return false}
    if lhs._readAt != rhs._readAt {return false}
    if lhs._lastReactionAt != rhs._lastReactionAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension History_PastIncomingMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PastIncomingMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .standard(proto: "received_at"),
    3: .standard(proto: "read_at"),
    4: .standard(proto: "last_reaction_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.receivedAt) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._readAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._lastReactionAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.receivedAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.receivedAt, fieldNumber: 2)
    }
    if let v = self._readAt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    if let v = self._lastReactionAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: History_PastIncomingMessage, rhs: History_PastIncomingMessage) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.receivedAt != rhs.receivedAt {return false}
    if lhs._readAt != rhs._readAt {return false}
    if lhs._lastReactionAt != rhs._lastReactionAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
