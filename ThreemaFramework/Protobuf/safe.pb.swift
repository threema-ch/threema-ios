//  _____ _
// |_   _| |_  _ _ ___ ___ _ __  __ _
//   | | | ' \| '_/ -_) -_) '  \/ _` |_
//   |_| |_||_|_| \___\___|_|_|_\__,_(_)
//
// Threema iOS Client
// Copyright (c) 2020-2021 Threema GmbH
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License, version 3,
// as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Visibility of a conversation.
enum Safe_ConversationVisibility: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Appears in the list of conversations
  case show // = 0

  /// Appears in the archived list of conversations
  case archive // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .show
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .show
    case 1: self = .archive
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .show: return 0
    case .archive: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Safe_ConversationVisibility: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_ConversationVisibility] = [
    .show,
    .archive,
  ]
}

#endif  // swift(>=4.2)

/// Category of a conversation.
enum Safe_ConversationCategory: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// No specific (default) category
  case `default` // = 0

  /// Protected conversation (*private chat*)
  case protected // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .default
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .default
    case 1: self = .protected
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .default: return 0
    case .protected: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Safe_ConversationCategory: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_ConversationCategory] = [
    .default,
    .protected,
  ]
}

#endif  // swift(>=4.2)

/// Threema Safe backup contents.
struct Safe_Backup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version of the format
  /// References: `info.version`
  var version: UInt32 = 0

  /// Metadata about the device which created the backup
  /// References: `info.device`
  var device: String = String()

  /// The private key associated with the Threema ID
  /// References: `user.privatekey`
  var privateKey: Data = SwiftProtobuf.Internal.emptyData

  /// The user's profile
  /// Note: The data MUST be inlined!
  var userProfile: Safe_UserProfile {
    get {return _userProfile ?? Safe_UserProfile()}
    set {_userProfile = newValue}
  }
  /// Returns true if `userProfile` has been explicitly set.
  var hasUserProfile: Bool {return self._userProfile != nil}
  /// Clears the value of `userProfile`. Subsequent reads from it will return its default value.
  mutating func clearUserProfile() {self._userProfile = nil}

  /// Contacts
  /// References: `contacts[]`
  var contacts: [Safe_Contact] = []

  /// Groups
  /// References: `groups[]`
  var groups: [Safe_Group] = []

  /// Distribution lists
  /// References: `distributionlists[]`
  var distributionLists: [Safe_DistributionList] = []

  /// App settings
  /// References: `settings`
  var settings: Safe_Settings {
    get {return _settings ?? Safe_Settings()}
    set {_settings = newValue}
  }
  /// Returns true if `settings` has been explicitly set.
  var hasSettings: Bool {return self._settings != nil}
  /// Clears the value of `settings`. Subsequent reads from it will return its default value.
  mutating func clearSettings() {self._settings = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _userProfile: Safe_UserProfile? = nil
  fileprivate var _settings: Safe_Settings? = nil
}

/// The user's profile.
struct Safe_UserProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Nickname
  /// References: `user.nickname`
  var nickname: String = String()

  /// Profile image
  /// References: `user.profilePic`
  var profileImage: Common_Image {
    get {return _profileImage ?? Common_Image()}
    set {_profileImage = newValue}
  }
  /// Returns true if `profileImage` has been explicitly set.
  var hasProfileImage: Bool {return self._profileImage != nil}
  /// Clears the value of `profileImage`. Subsequent reads from it will return its default value.
  mutating func clearProfileImage() {self._profileImage = nil}

  var profileImageSharePolicy: Safe_UserProfile.ProfileImageSharePolicy = .nobody

  /// Contact IDs the profile image may be shared with. Should only be filled
  /// when the `ProfileImageSharePolicy` is `ALLOW_LIST`.
  /// References: `user.profilePicRelease[]`
  var profileImageShareWith: [String] = []

  /// External entities linked with the identity
  /// References: `user.links[]`
  var identityLinks: [Safe_IdentityLink] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Profile image share policy
  /// References: `user.profilePicRelease[]`
  enum ProfileImageSharePolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Don't share
    case nobody // = 0

    /// Share with everyone
    case everyone // = 1

    /// Share with a limited amount of contacts explicitly listed
    case allowList // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .nobody
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .nobody
      case 1: self = .everyone
      case 2: self = .allowList
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .nobody: return 0
      case .everyone: return 1
      case .allowList: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _profileImage: Common_Image? = nil
}

#if swift(>=4.2)

extension Safe_UserProfile.ProfileImageSharePolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_UserProfile.ProfileImageSharePolicy] = [
    .nobody,
    .everyone,
    .allowList,
  ]
}

#endif  // swift(>=4.2)

/// Threema contact.
struct Safe_Contact {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Threema ID of the contact
  /// References: `contacts[].identity`
  var identity: String = String()

  /// Public key of the contact
  /// References: `contacts[].publickey`
  var publicKey: Data = SwiftProtobuf.Internal.emptyData

  /// Unix-ish timestamp in milliseconds when the contact has been created
  /// (added) locally.
  /// References: `contacts[].createdAt`
  var createdAt: UInt64 = 0

  var verificationLevel: Safe_Contact.VerificationLevel = .unverified

  var identityType: Safe_Contact.IdentityType = .regular

  var displayPolicy: Safe_Contact.DisplayPolicy = .show

  /// Conversation category of the contact
  /// References: `contacts[].private`
  var conversationCategory: Safe_ConversationCategory = .default

  /// Conversation visbility of the contact
  var conversationVisibility: Safe_ConversationVisibility = .show

  /// First name of the contact
  /// References: `contacts[].firstname`
  var firstName: Safe_Contact.OneOf_FirstName? = nil

  var firstNameValue: String {
    get {
      if case .firstNameValue(let v)? = firstName {return v}
      return String()
    }
    set {firstName = .firstNameValue(newValue)}
  }

  /// Last name of the contact
  /// References: `contacts[].lastname`
  var lastName: Safe_Contact.OneOf_LastName? = nil

  var lastNameValue: String {
    get {
      if case .lastNameValue(let v)? = lastName {return v}
      return String()
    }
    set {lastName = .lastNameValue(newValue)}
  }

  /// Nickname of the contact (without `~` prefix)
  /// References: `contacts[].nickname`
  var nickname: Safe_Contact.OneOf_Nickname? = nil

  var nicknameValue: String {
    get {
      if case .nicknameValue(let v)? = nickname {return v}
      return String()
    }
    set {nickname = .nicknameValue(newValue)}
  }

  /// Profile image as received from the contact
  var profileImage: Common_Image {
    get {return _profileImage ?? Common_Image()}
    set {_profileImage = newValue}
  }
  /// Returns true if `profileImage` has been explicitly set.
  var hasProfileImage: Bool {return self._profileImage != nil}
  /// Clears the value of `profileImage`. Subsequent reads from it will return its default value.
  mutating func clearProfileImage() {self._profileImage = nil}

  /// Custom profile image set by the user
  var customProfileImage: Common_Image {
    get {return _customProfileImage ?? Common_Image()}
    set {_customProfileImage = newValue}
  }
  /// Returns true if `customProfileImage` has been explicitly set.
  var hasCustomProfileImage: Bool {return self._customProfileImage != nil}
  /// Clears the value of `customProfileImage`. Subsequent reads from it will return its default value.
  mutating func clearCustomProfileImage() {self._customProfileImage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// First name of the contact
  /// References: `contacts[].firstname`
  enum OneOf_FirstName: Equatable {
    case firstNameValue(String)

  #if !swift(>=4.1)
    static func ==(lhs: Safe_Contact.OneOf_FirstName, rhs: Safe_Contact.OneOf_FirstName) -> Bool {
      switch (lhs, rhs) {
      case (.firstNameValue(let l), .firstNameValue(let r)): return l == r
      }
    }
  #endif
  }

  /// Last name of the contact
  /// References: `contacts[].lastname`
  enum OneOf_LastName: Equatable {
    case lastNameValue(String)

  #if !swift(>=4.1)
    static func ==(lhs: Safe_Contact.OneOf_LastName, rhs: Safe_Contact.OneOf_LastName) -> Bool {
      switch (lhs, rhs) {
      case (.lastNameValue(let l), .lastNameValue(let r)): return l == r
      }
    }
  #endif
  }

  /// Nickname of the contact (without `~` prefix)
  /// References: `contacts[].nickname`
  enum OneOf_Nickname: Equatable {
    case nicknameValue(String)

  #if !swift(>=4.1)
    static func ==(lhs: Safe_Contact.OneOf_Nickname, rhs: Safe_Contact.OneOf_Nickname) -> Bool {
      switch (lhs, rhs) {
      case (.nicknameValue(let l), .nicknameValue(let r)): return l == r
      }
    }
  #endif
  }

  /// Verification level of the contact
  /// References: `contacts[].verification`
  enum VerificationLevel: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unverified, public key has been obtained from the server
    case unverified // = 0

    /// Verified with one of the account links via the server, or the contact
    /// has been obtained via the Work API.
    case serverVerified // = 1

    /// Verified, public key has been obtained via a secure channel
    case fullyVerified // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unverified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unverified
      case 1: self = .serverVerified
      case 2: self = .fullyVerified
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unverified: return 0
      case .serverVerified: return 1
      case .fullyVerified: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Identity type of the contact
  /// References: `contacts[].workVerified`
  enum IdentityType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Regular contact (uses the regular Threema app)
    case regular // = 0

    /// Work contact (uses the Threema work app)
    case work // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .regular
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .regular
      case 1: self = .work
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .regular: return 0
      case .work: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Display policy for the contact
  /// References: `contacts[].hidden`
  enum DisplayPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Show contact
    case show // = 0

    /// Hide contact (e.g. group contact not explicitly added)
    case hide // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .show
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .show
      case 1: self = .hide
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .show: return 0
      case .hide: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _profileImage: Common_Image? = nil
  fileprivate var _customProfileImage: Common_Image? = nil
}

#if swift(>=4.2)

extension Safe_Contact.VerificationLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Contact.VerificationLevel] = [
    .unverified,
    .serverVerified,
    .fullyVerified,
  ]
}

extension Safe_Contact.IdentityType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Contact.IdentityType] = [
    .regular,
    .work,
  ]
}

extension Safe_Contact.DisplayPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Contact.DisplayPolicy] = [
    .show,
    .hide,
  ]
}

#endif  // swift(>=4.2)

/// Threema contacts associated to a group.
struct Safe_Group {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique group identity
  /// References: `groups[].id` and `groups[].creator`
  var groupIdentity: Common_GroupIdentity {
    get {return _groupIdentity ?? Common_GroupIdentity()}
    set {_groupIdentity = newValue}
  }
  /// Returns true if `groupIdentity` has been explicitly set.
  var hasGroupIdentity: Bool {return self._groupIdentity != nil}
  /// Clears the value of `groupIdentity`. Subsequent reads from it will return its default value.
  mutating func clearGroupIdentity() {self._groupIdentity = nil}

  /// Name of the group
  /// References: `groups[].groupname`
  var name: String = String()

  /// Unix-ish timestamp in milliseconds when the group has been created locally
  /// References: `groups[].createdAt`
  var createdAt: UInt64 = 0

  /// Conversation category of the group
  /// References: `groups[].private`
  var conversationCategory: Safe_ConversationCategory = .default

  /// Conversation visbility of the group
  var conversationVisibility: Safe_ConversationVisibility = .show

  var userState: Safe_Group.UserState = .member

  /// Group's profile image as received from the group's administrator
  var profileImage: Common_Image {
    get {return _profileImage ?? Common_Image()}
    set {_profileImage = newValue}
  }
  /// Returns true if `profileImage` has been explicitly set.
  var hasProfileImage: Bool {return self._profileImage != nil}
  /// Clears the value of `profileImage`. Subsequent reads from it will return its default value.
  mutating func clearProfileImage() {self._profileImage = nil}

  /// Group members (**NOT** including the user itself)
  /// References: `groups[].members`
  var memberIdentities: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The user's state within the group
  /// References: `groups[].deleted`
  enum UserState: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// The user is a member (or an admin) of the group
    case member // = 0

    /// The user has been kicked from the group
    case kicked // = 1

    /// The user left the group
    case left // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .member
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .member
      case 1: self = .kicked
      case 2: self = .left
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .member: return 0
      case .kicked: return 1
      case .left: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _groupIdentity: Common_GroupIdentity? = nil
  fileprivate var _profileImage: Common_Image? = nil
}

#if swift(>=4.2)

extension Safe_Group.UserState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Group.UserState] = [
    .member,
    .kicked,
    .left,
  ]
}

#endif  // swift(>=4.2)

/// Threema contacts associated to a distribution list.
struct Safe_DistributionList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID of the distribution list
  var distributionListID: UInt64 = 0

  /// Name of the distribution list
  /// References: `distributionlists[].name`
  var name: String = String()

  /// Unix-ish timestamp in milliseconds when the group has been created
  /// References: `distributionlists[].createdAt`
  var createdAt: UInt64 = 0

  /// Conversation category of the distribution list
  /// References: `distributionlists[].private`
  var conversationCategory: Safe_ConversationCategory = .default

  /// Conversation visbility of the distribution list
  var conversationVisibility: Safe_ConversationVisibility = .show

  /// Distribution list members
  /// References: `distributionlists[].members`
  var memberIdentities: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// App settings
struct Safe_Settings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var contactSyncPolicy: Safe_Settings.ContactSyncPolicy = .notSynced

  var unknownContactPolicy: Safe_Settings.UnknownContactPolicy = .allowUnknown

  var readMessagePolicy: Safe_Settings.ReadMessagePolicy = .sendReadReceipt

  var composeMessagePolicy: Safe_Settings.ComposeMessagePolicy = .sendTypingIndicator

  var callPolicy: Safe_Settings.CallPolicy = .allowCall

  var callConnectionPolity: Safe_Settings.CallConnectionPolicy = .allowDirect

  var screenshotPolicy: Safe_Settings.ScreenshotPolicy = .allowScreenshot

  var keyboardDataCollectionPolicy: Safe_Settings.KeyboardDataCollectionPolicy = .allowDataCollection

  /// List of Threema IDs whose messages are blocked
  /// References: `settings.blockedContacts[]`
  var blockedIdentities: [String] = []

  /// Threema IDs to be excluded when syncing
  /// References: `settings.syncExcludedIds[]`
  var excludeFromSyncIdentities: [String] = []

  /// List of recently used emojis, where the most recently used Emoji comes
  /// first.
  /// References: `settings.recentEmojis[]`
  var recentEmojis: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Contact synchronisation policy
  /// References: `settings.syncContacts`
  enum ContactSyncPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Not synced
    case notSynced // = 0

    /// Synced
    case sync // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .notSynced
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notSynced
      case 1: self = .sync
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .notSynced: return 0
      case .sync: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Unknown contacts policy
  /// References: `settings.blockUnknown`
  enum UnknownContactPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allowed to contact the user
    case allowUnknown // = 0

    /// Will be blocked by the user
    case blockUnknown // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowUnknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowUnknown
      case 1: self = .blockUnknown
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowUnknown: return 0
      case .blockUnknown: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Read message policy (when an unread message has been read)
  /// References: `settings.readReceipts`
  enum ReadMessagePolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Send *read* receipt when an unread message has been read
    case sendReadReceipt // = 0

    /// Don't send *read* receipts
    case ignoreRead // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .sendReadReceipt
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sendReadReceipt
      case 1: self = .ignoreRead
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .sendReadReceipt: return 0
      case .ignoreRead: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Compose message policy
  /// References: `settings.sendTyping`
  enum ComposeMessagePolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Send *typing* indicator when a message is being composed
    case sendTypingIndicator // = 0

    /// Don't send *typing* indicators
    case ignoreCompose // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .sendTypingIndicator
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sendTypingIndicator
      case 1: self = .ignoreCompose
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .sendTypingIndicator: return 0
      case .ignoreCompose: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Threema Call policy
  /// References: `settings.threemaCalls`
  enum CallPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow creating/receiving Threema Calls
    case allowCall // = 0

    /// Denied from creating/receiving any Threema Calls
    case denyCall // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowCall
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowCall
      case 1: self = .denyCall
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowCall: return 0
      case .denyCall: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Threema Call connection policy
  /// References: `settings.relayThreemaCalls`
  enum CallConnectionPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow direct (peer-to-peer) connections for Threema Calls
    case allowDirect // = 0

    /// Require relayed connections for Threema Calls
    case requireRelay // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowDirect
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowDirect
      case 1: self = .requireRelay
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowDirect: return 0
      case .requireRelay: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Screenshot policy
  /// References: `settings.disableScreenshots`
  enum ScreenshotPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow taking screenshots
    case allowScreenshot // = 0

    /// Deny taking screenshots, if possible
    case denyScreenshot // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowScreenshot
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowScreenshot
      case 1: self = .denyScreenshot
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowScreenshot: return 0
      case .denyScreenshot: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Keyboard data collection policy (e.g. for personalised suggestions)
  /// References: `settings.incognitoKeyboard`
  enum KeyboardDataCollectionPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow keyboard input data to be collected
    case allowDataCollection // = 0

    /// Deny collecting of keyboard input data
    case denyDataCollection // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowDataCollection
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowDataCollection
      case 1: self = .denyDataCollection
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowDataCollection: return 0
      case .denyDataCollection: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Safe_Settings.ContactSyncPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Settings.ContactSyncPolicy] = [
    .notSynced,
    .sync,
  ]
}

extension Safe_Settings.UnknownContactPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Settings.UnknownContactPolicy] = [
    .allowUnknown,
    .blockUnknown,
  ]
}

extension Safe_Settings.ReadMessagePolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Settings.ReadMessagePolicy] = [
    .sendReadReceipt,
    .ignoreRead,
  ]
}

extension Safe_Settings.ComposeMessagePolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Settings.ComposeMessagePolicy] = [
    .sendTypingIndicator,
    .ignoreCompose,
  ]
}

extension Safe_Settings.CallPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Settings.CallPolicy] = [
    .allowCall,
    .denyCall,
  ]
}

extension Safe_Settings.CallConnectionPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Settings.CallConnectionPolicy] = [
    .allowDirect,
    .requireRelay,
  ]
}

extension Safe_Settings.ScreenshotPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Settings.ScreenshotPolicy] = [
    .allowScreenshot,
    .denyScreenshot,
  ]
}

extension Safe_Settings.KeyboardDataCollectionPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Settings.KeyboardDataCollectionPolicy] = [
    .allowDataCollection,
    .denyDataCollection,
  ]
}

#endif  // swift(>=4.2)

/// Threema ID link.
struct Safe_IdentityLink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identity link type
  /// References: `user.links[].type`, `user.links[].value`
  var type: Safe_IdentityLink.OneOf_Type? = nil

  /// Linked with a verified telephone number (E.164 format without leading
  /// `+`)
  var phoneNumber: String {
    get {
      if case .phoneNumber(let v)? = type {return v}
      return String()
    }
    set {type = .phoneNumber(newValue)}
  }

  /// Linked with a verified email address
  var email: String {
    get {
      if case .email(let v)? = type {return v}
      return String()
    }
    set {type = .email(newValue)}
  }

  /// Identity link description
  /// References: `user.links[].name`
  var description_p: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Identity link type
  /// References: `user.links[].type`, `user.links[].value`
  enum OneOf_Type: Equatable {
    /// Linked with a verified telephone number (E.164 format without leading
    /// `+`)
    case phoneNumber(String)
    /// Linked with a verified email address
    case email(String)

  #if !swift(>=4.1)
    static func ==(lhs: Safe_IdentityLink.OneOf_Type, rhs: Safe_IdentityLink.OneOf_Type) -> Bool {
      switch (lhs, rhs) {
      case (.phoneNumber(let l), .phoneNumber(let r)): return l == r
      case (.email(let l), .email(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "safe"

extension Safe_ConversationVisibility: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SHOW"),
    1: .same(proto: "ARCHIVE"),
  ]
}

extension Safe_ConversationCategory: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "PROTECTED"),
  ]
}

extension Safe_Backup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Backup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "device"),
    3: .standard(proto: "private_key"),
    4: .standard(proto: "user_profile"),
    5: .same(proto: "contacts"),
    6: .same(proto: "groups"),
    7: .standard(proto: "distribution_lists"),
    8: .same(proto: "settings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.version)
      case 2: try decoder.decodeSingularStringField(value: &self.device)
      case 3: try decoder.decodeSingularBytesField(value: &self.privateKey)
      case 4: try decoder.decodeSingularMessageField(value: &self._userProfile)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.contacts)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.groups)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.distributionLists)
      case 8: try decoder.decodeSingularMessageField(value: &self._settings)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.device.isEmpty {
      try visitor.visitSingularStringField(value: self.device, fieldNumber: 2)
    }
    if !self.privateKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKey, fieldNumber: 3)
    }
    if let v = self._userProfile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.contacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contacts, fieldNumber: 5)
    }
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 6)
    }
    if !self.distributionLists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.distributionLists, fieldNumber: 7)
    }
    if let v = self._settings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Safe_Backup, rhs: Safe_Backup) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.device != rhs.device {return false}
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs._userProfile != rhs._userProfile {return false}
    if lhs.contacts != rhs.contacts {return false}
    if lhs.groups != rhs.groups {return false}
    if lhs.distributionLists != rhs.distributionLists {return false}
    if lhs._settings != rhs._settings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Safe_UserProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserProfile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nickname"),
    2: .standard(proto: "profile_image"),
    3: .standard(proto: "profile_image_share_policy"),
    4: .standard(proto: "profile_image_share_with"),
    5: .standard(proto: "identity_links"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.nickname)
      case 2: try decoder.decodeSingularMessageField(value: &self._profileImage)
      case 3: try decoder.decodeSingularEnumField(value: &self.profileImageSharePolicy)
      case 4: try decoder.decodeRepeatedStringField(value: &self.profileImageShareWith)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.identityLinks)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 1)
    }
    if let v = self._profileImage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.profileImageSharePolicy != .nobody {
      try visitor.visitSingularEnumField(value: self.profileImageSharePolicy, fieldNumber: 3)
    }
    if !self.profileImageShareWith.isEmpty {
      try visitor.visitRepeatedStringField(value: self.profileImageShareWith, fieldNumber: 4)
    }
    if !self.identityLinks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identityLinks, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Safe_UserProfile, rhs: Safe_UserProfile) -> Bool {
    if lhs.nickname != rhs.nickname {return false}
    if lhs._profileImage != rhs._profileImage {return false}
    if lhs.profileImageSharePolicy != rhs.profileImageSharePolicy {return false}
    if lhs.profileImageShareWith != rhs.profileImageShareWith {return false}
    if lhs.identityLinks != rhs.identityLinks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Safe_UserProfile.ProfileImageSharePolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOBODY"),
    1: .same(proto: "EVERYONE"),
    2: .same(proto: "ALLOW_LIST"),
  ]
}

extension Safe_Contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Contact"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identity"),
    2: .standard(proto: "public_key"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "verification_level"),
    5: .standard(proto: "identity_type"),
    6: .standard(proto: "display_policy"),
    7: .standard(proto: "conversation_category"),
    8: .standard(proto: "conversation_visibility"),
    9: .standard(proto: "first_name_value"),
    10: .standard(proto: "last_name_value"),
    11: .standard(proto: "nickname_value"),
    12: .standard(proto: "profile_image"),
    13: .standard(proto: "custom_profile_image"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.identity)
      case 2: try decoder.decodeSingularBytesField(value: &self.publicKey)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.createdAt)
      case 4: try decoder.decodeSingularEnumField(value: &self.verificationLevel)
      case 5: try decoder.decodeSingularEnumField(value: &self.identityType)
      case 6: try decoder.decodeSingularEnumField(value: &self.displayPolicy)
      case 7: try decoder.decodeSingularEnumField(value: &self.conversationCategory)
      case 8: try decoder.decodeSingularEnumField(value: &self.conversationVisibility)
      case 9:
        if self.firstName != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.firstName = .firstNameValue(v)}
      case 10:
        if self.lastName != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.lastName = .lastNameValue(v)}
      case 11:
        if self.nickname != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.nickname = .nicknameValue(v)}
      case 12: try decoder.decodeSingularMessageField(value: &self._profileImage)
      case 13: try decoder.decodeSingularMessageField(value: &self._customProfileImage)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 2)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 3)
    }
    if self.verificationLevel != .unverified {
      try visitor.visitSingularEnumField(value: self.verificationLevel, fieldNumber: 4)
    }
    if self.identityType != .regular {
      try visitor.visitSingularEnumField(value: self.identityType, fieldNumber: 5)
    }
    if self.displayPolicy != .show {
      try visitor.visitSingularEnumField(value: self.displayPolicy, fieldNumber: 6)
    }
    if self.conversationCategory != .default {
      try visitor.visitSingularEnumField(value: self.conversationCategory, fieldNumber: 7)
    }
    if self.conversationVisibility != .show {
      try visitor.visitSingularEnumField(value: self.conversationVisibility, fieldNumber: 8)
    }
    if case .firstNameValue(let v)? = self.firstName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    }
    if case .lastNameValue(let v)? = self.lastName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    }
    if case .nicknameValue(let v)? = self.nickname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    }
    if let v = self._profileImage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }
    if let v = self._customProfileImage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Safe_Contact, rhs: Safe_Contact) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.verificationLevel != rhs.verificationLevel {return false}
    if lhs.identityType != rhs.identityType {return false}
    if lhs.displayPolicy != rhs.displayPolicy {return false}
    if lhs.conversationCategory != rhs.conversationCategory {return false}
    if lhs.conversationVisibility != rhs.conversationVisibility {return false}
    if lhs.firstName != rhs.firstName {return false}
    if lhs.lastName != rhs.lastName {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs._profileImage != rhs._profileImage {return false}
    if lhs._customProfileImage != rhs._customProfileImage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Safe_Contact.VerificationLevel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNVERIFIED"),
    1: .same(proto: "SERVER_VERIFIED"),
    2: .same(proto: "FULLY_VERIFIED"),
  ]
}

extension Safe_Contact.IdentityType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REGULAR"),
    1: .same(proto: "WORK"),
  ]
}

extension Safe_Contact.DisplayPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SHOW"),
    1: .same(proto: "HIDE"),
  ]
}

extension Safe_Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Group"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_identity"),
    2: .same(proto: "name"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "conversation_category"),
    5: .standard(proto: "conversation_visibility"),
    6: .standard(proto: "user_state"),
    7: .standard(proto: "profile_image"),
    8: .standard(proto: "member_identities"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._groupIdentity)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.createdAt)
      case 4: try decoder.decodeSingularEnumField(value: &self.conversationCategory)
      case 5: try decoder.decodeSingularEnumField(value: &self.conversationVisibility)
      case 6: try decoder.decodeSingularEnumField(value: &self.userState)
      case 7: try decoder.decodeSingularMessageField(value: &self._profileImage)
      case 8: try decoder.decodeRepeatedStringField(value: &self.memberIdentities)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._groupIdentity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 3)
    }
    if self.conversationCategory != .default {
      try visitor.visitSingularEnumField(value: self.conversationCategory, fieldNumber: 4)
    }
    if self.conversationVisibility != .show {
      try visitor.visitSingularEnumField(value: self.conversationVisibility, fieldNumber: 5)
    }
    if self.userState != .member {
      try visitor.visitSingularEnumField(value: self.userState, fieldNumber: 6)
    }
    if let v = self._profileImage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.memberIdentities.isEmpty {
      try visitor.visitRepeatedStringField(value: self.memberIdentities, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Safe_Group, rhs: Safe_Group) -> Bool {
    if lhs._groupIdentity != rhs._groupIdentity {return false}
    if lhs.name != rhs.name {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.conversationCategory != rhs.conversationCategory {return false}
    if lhs.conversationVisibility != rhs.conversationVisibility {return false}
    if lhs.userState != rhs.userState {return false}
    if lhs._profileImage != rhs._profileImage {return false}
    if lhs.memberIdentities != rhs.memberIdentities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Safe_Group.UserState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEMBER"),
    1: .same(proto: "KICKED"),
    2: .same(proto: "LEFT"),
  ]
}

extension Safe_DistributionList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DistributionList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "distribution_list_id"),
    2: .same(proto: "name"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "conversation_category"),
    5: .standard(proto: "conversation_visibility"),
    6: .standard(proto: "member_identities"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFixed64Field(value: &self.distributionListID)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.createdAt)
      case 4: try decoder.decodeSingularEnumField(value: &self.conversationCategory)
      case 5: try decoder.decodeSingularEnumField(value: &self.conversationVisibility)
      case 6: try decoder.decodeRepeatedStringField(value: &self.memberIdentities)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.distributionListID != 0 {
      try visitor.visitSingularFixed64Field(value: self.distributionListID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 3)
    }
    if self.conversationCategory != .default {
      try visitor.visitSingularEnumField(value: self.conversationCategory, fieldNumber: 4)
    }
    if self.conversationVisibility != .show {
      try visitor.visitSingularEnumField(value: self.conversationVisibility, fieldNumber: 5)
    }
    if !self.memberIdentities.isEmpty {
      try visitor.visitRepeatedStringField(value: self.memberIdentities, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Safe_DistributionList, rhs: Safe_DistributionList) -> Bool {
    if lhs.distributionListID != rhs.distributionListID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.conversationCategory != rhs.conversationCategory {return false}
    if lhs.conversationVisibility != rhs.conversationVisibility {return false}
    if lhs.memberIdentities != rhs.memberIdentities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Safe_Settings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Settings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contact_sync_policy"),
    2: .standard(proto: "unknown_contact_policy"),
    3: .standard(proto: "read_message_policy"),
    4: .standard(proto: "compose_message_policy"),
    5: .standard(proto: "call_policy"),
    6: .standard(proto: "call_connection_polity"),
    7: .standard(proto: "screenshot_policy"),
    8: .standard(proto: "keyboard_data_collection_policy"),
    9: .standard(proto: "blocked_identities"),
    10: .standard(proto: "exclude_from_sync_identities"),
    11: .standard(proto: "recent_emojis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.contactSyncPolicy)
      case 2: try decoder.decodeSingularEnumField(value: &self.unknownContactPolicy)
      case 3: try decoder.decodeSingularEnumField(value: &self.readMessagePolicy)
      case 4: try decoder.decodeSingularEnumField(value: &self.composeMessagePolicy)
      case 5: try decoder.decodeSingularEnumField(value: &self.callPolicy)
      case 6: try decoder.decodeSingularEnumField(value: &self.callConnectionPolity)
      case 7: try decoder.decodeSingularEnumField(value: &self.screenshotPolicy)
      case 8: try decoder.decodeSingularEnumField(value: &self.keyboardDataCollectionPolicy)
      case 9: try decoder.decodeRepeatedStringField(value: &self.blockedIdentities)
      case 10: try decoder.decodeRepeatedStringField(value: &self.excludeFromSyncIdentities)
      case 11: try decoder.decodeRepeatedStringField(value: &self.recentEmojis)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.contactSyncPolicy != .notSynced {
      try visitor.visitSingularEnumField(value: self.contactSyncPolicy, fieldNumber: 1)
    }
    if self.unknownContactPolicy != .allowUnknown {
      try visitor.visitSingularEnumField(value: self.unknownContactPolicy, fieldNumber: 2)
    }
    if self.readMessagePolicy != .sendReadReceipt {
      try visitor.visitSingularEnumField(value: self.readMessagePolicy, fieldNumber: 3)
    }
    if self.composeMessagePolicy != .sendTypingIndicator {
      try visitor.visitSingularEnumField(value: self.composeMessagePolicy, fieldNumber: 4)
    }
    if self.callPolicy != .allowCall {
      try visitor.visitSingularEnumField(value: self.callPolicy, fieldNumber: 5)
    }
    if self.callConnectionPolity != .allowDirect {
      try visitor.visitSingularEnumField(value: self.callConnectionPolity, fieldNumber: 6)
    }
    if self.screenshotPolicy != .allowScreenshot {
      try visitor.visitSingularEnumField(value: self.screenshotPolicy, fieldNumber: 7)
    }
    if self.keyboardDataCollectionPolicy != .allowDataCollection {
      try visitor.visitSingularEnumField(value: self.keyboardDataCollectionPolicy, fieldNumber: 8)
    }
    if !self.blockedIdentities.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockedIdentities, fieldNumber: 9)
    }
    if !self.excludeFromSyncIdentities.isEmpty {
      try visitor.visitRepeatedStringField(value: self.excludeFromSyncIdentities, fieldNumber: 10)
    }
    if !self.recentEmojis.isEmpty {
      try visitor.visitRepeatedStringField(value: self.recentEmojis, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Safe_Settings, rhs: Safe_Settings) -> Bool {
    if lhs.contactSyncPolicy != rhs.contactSyncPolicy {return false}
    if lhs.unknownContactPolicy != rhs.unknownContactPolicy {return false}
    if lhs.readMessagePolicy != rhs.readMessagePolicy {return false}
    if lhs.composeMessagePolicy != rhs.composeMessagePolicy {return false}
    if lhs.callPolicy != rhs.callPolicy {return false}
    if lhs.callConnectionPolity != rhs.callConnectionPolity {return false}
    if lhs.screenshotPolicy != rhs.screenshotPolicy {return false}
    if lhs.keyboardDataCollectionPolicy != rhs.keyboardDataCollectionPolicy {return false}
    if lhs.blockedIdentities != rhs.blockedIdentities {return false}
    if lhs.excludeFromSyncIdentities != rhs.excludeFromSyncIdentities {return false}
    if lhs.recentEmojis != rhs.recentEmojis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Safe_Settings.ContactSyncPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_SYNCED"),
    1: .same(proto: "SYNC"),
  ]
}

extension Safe_Settings.UnknownContactPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_UNKNOWN"),
    1: .same(proto: "BLOCK_UNKNOWN"),
  ]
}

extension Safe_Settings.ReadMessagePolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SEND_READ_RECEIPT"),
    1: .same(proto: "IGNORE_READ"),
  ]
}

extension Safe_Settings.ComposeMessagePolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SEND_TYPING_INDICATOR"),
    1: .same(proto: "IGNORE_COMPOSE"),
  ]
}

extension Safe_Settings.CallPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_CALL"),
    1: .same(proto: "DENY_CALL"),
  ]
}

extension Safe_Settings.CallConnectionPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_DIRECT"),
    1: .same(proto: "REQUIRE_RELAY"),
  ]
}

extension Safe_Settings.ScreenshotPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_SCREENSHOT"),
    1: .same(proto: "DENY_SCREENSHOT"),
  ]
}

extension Safe_Settings.KeyboardDataCollectionPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_DATA_COLLECTION"),
    1: .same(proto: "DENY_DATA_COLLECTION"),
  ]
}

extension Safe_IdentityLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IdentityLink"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "phone_number"),
    2: .same(proto: "email"),
    3: .same(proto: "description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.type != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.type = .phoneNumber(v)}
      case 2:
        if self.type != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.type = .email(v)}
      case 3: try decoder.decodeSingularStringField(value: &self.description_p)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.type {
    case .phoneNumber(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    case .email(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case nil: break
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Safe_IdentityLink, rhs: Safe_IdentityLink) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
