// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: csp-e2e.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// ## End-to-End Encrypted Messages (Supplementary)
//
// This is a supplementary section to the corresponding structbuf section
// with newer messages that use protobuf instead of structbuf. All defined
// messages here follow the same logic.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Metadata sent within a CSP payload `message-with-metadata-box` struct.
public struct CspE2e_MessageMetadata: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Padding that is ignored by the receiver.
  /// Recommended to be chosen such that the total length of padding + nickname
  /// is at least 16 bytes. May be empty if the nickname is long enough.
  public var padding: Data = Data()

  /// Unique message ID. Must match the message ID of the outer struct
  /// (i.e. `message-with-metadata-box.message-id`).
  public var messageID: UInt64 = 0

  /// Unix-ish timestamp in milliseconds for when the message has been created.
  ///
  /// Messages sent in a group must have the same timestamp for each group
  /// member.
  public var createdAt: UInt64 = 0

  /// Nickname
  ///
  /// Should be sent when the associate message requires _user profile
  /// distribution_.
  ///
  /// When the user cleared its nickname, send an empty string. Do not send the
  /// user's Threema ID (i.e. process data).
  ///
  /// Recommended to not exceed 32 grapheme clusters. Should not contain
  /// whitespace characters at the beginning or the end of string.
  public var nickname: String {
    get {return _nickname ?? String()}
    set {_nickname = newValue}
  }
  /// Returns true if `nickname` has been explicitly set.
  public var hasNickname: Bool {return self._nickname != nil}
  /// Clears the value of `nickname`. Subsequent reads from it will return its default value.
  public mutating func clearNickname() {self._nickname = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nickname: String? = nil
}

/// Edit an existing message (e.g. a text message or a media message caption).
///
/// **Properties (1:1)**:
/// - Kind: 1:1
/// - Flags:
///   - `0x01`: Send push notification.
/// - User profile distribution: No
/// - Exempt from blocking: No
/// - Implicit _direct_ contact creation: No
/// - Protect against replay: Yes
/// - Unarchive: No
/// - Bump _last update_: No
/// - Reflect:
///   - Incoming: Yes
///   - Outgoing: Yes
///   - _Sent_ update: No
/// - Delivery receipts: No
/// - Reactions: No
/// - Edit applies to: N/A (obviously)
/// - Deletable by: N/A
/// - When rejected: N/A (ignored)
/// - Send to Threema Gateway ID group creator: N/A
///
/// **Properties (Group)**:
/// - Kind: Group
/// - Flags:
///   - `0x01`: Send push notification.
/// - User profile distribution: No
/// - Exempt from blocking: No
/// - Implicit _direct_ contact creation: No
/// - Protect against replay: Yes
/// - Unarchive: No
/// - Bump _last update_: No
/// - Reflect:
///   - Incoming: Yes
///   - Outgoing: Yes
///   - _Sent_ update: No
/// - Delivery receipts: N/A
/// - Reactions: No
/// - Edit applies to: N/A (obviously)
/// - Deletable by: N/A
/// - When rejected: N/A (ignored)
/// - Send to Threema Gateway ID group creator: If capture is enabled
///
/// The following steps must be invoked when the user wants to edit a 1:1
/// message:
///
/// 1. If the sender or the receiver do not have `EDIT_MESSAGE_SUPPORT`, disallow
///    editing and abort these steps.
/// 2. Run the _Common Edit Message Enter Steps_.
/// 3. Allow the user to edit the referred message.
///
/// The following steps must be invoked when the user wants to edit a group
/// message:
///
/// 1. If the group is marked as _left_, disallow editing and abort these steps.
/// 2. If the sender or all of the group members do not have
///    `EDIT_MESSAGE_SUPPORT`, disallow editing and abort these steps.
/// 3. Run the _Common Edit Message Enter Steps_.
/// 4. If any of the group members do not have `EDIT_MESSAGE_SUPPORT`, notify the
///    user that the affected contacts will not receive the edited content.
/// 5. Allow the user to edit the referred message.
///
/// The following steps are defined as the _Common Edit Message Enter Steps_:
///
/// 1. Let `message` be the referred message.
/// 2. If the user is not the original sender of `message`, disallow editing and
///    abort these steps.
/// 3. If `message` has been sent (`sent-at`) more than 6 hours ago, disallow
///    editing and abort these steps.¹
///
/// The following steps must be invoked when the user wants to submit an edited
/// 1:1 message.
///
/// 1. If the sender or the receiver do not have `EDIT_MESSAGE_SUPPORT`, discard
///    the edited message and abort these steps.
/// 2. Run the _Common Edit Message Submit Preflight Steps_.
/// 3. Let `edited-at` be the current timestamp.
/// 4. Run the _1:1 Messages Submit Steps_ with `messages` set from the following
///    properties:
///    - `created-at` set to `edited-at`,
///    - to construct an `EditMessage` message.
/// 5. Edit the referred message as defined by the associated _Edit applies to_
///    property and add an indicator to the referred message, informing the user
///    that the referred message has been edited by the user at `edited-at`.
///
/// The following steps must be invoked when the user wants to submit an edited
/// group message.
///
/// 1. If the group is marked as _left_, discard the edited message and abort
///    these steps.
/// 2. If the sender or all of the group members do not have
///    `EDIT_MESSAGE_SUPPORT`, discard the edited message and abort these steps.
/// 3. Run the _Common Edit Message Submit Preflight Steps_.
/// 4. Let `edited-at` be the current timestamp.
/// 5. Run the _Group Messages Submit Steps_ with `messages` set from the
///    following properties:
///    - `created-at` set to `edited-at`,
///    - to construct an `EditMessage` message (wrapped by
///      [`group-member-container`](ref:e2e.group-member-container)).
/// 6. Edit the referred message as defined by the associated _Edit applies to_
///    property and add an indicator to the referred message, informing the user
///    that the referred message has been edited by the user at `edited-at`.
///
/// The following steps are defined as the _Common Edit Message Submit Preflight
/// Steps_:
///
/// 1. Lookup the message with `message_id` originally sent by the sender within
///    the associated conversation and let `message` be the result.
/// 2. If `message` is no longer defined, discard the edited message and abort
///    these steps.
/// 3. If the content of `message` is identical to the edited message, discard
///    the edited message and abort these steps.
///
/// When reflected from another device as an incoming or outgoing 1:1 message:
///
/// 1. Run the _Common Edit Message Receive Steps_.
///
/// When receiving this message as a 1:1 message:
///
/// 1. Run the _Common Edit Message Receive Steps_.
///
/// When reflected from another device as an incoming or outgoing group message:
///
/// 1. Run the _Common Edit Message Receive Steps_.
///
/// When receiving this message as a group message (wrapped by
/// [`group-member-container`](ref:e2e.group-member-container)):
///
/// 1. Run the [_Common Group Receive Steps_](ref:e2e#receiving). If the message
///    has been discarded, abort these steps.
/// 2. Run the _Common Edit Message Receive Steps_.
///
/// The following steps are defined as the _Common Edit Message Receive Steps_:
///
/// 1. Lookup the message with `message_id` originally sent by the sender within
///    the associated conversation and let `referred-message` be the result.
/// 2. If `referred-message` is not defined or the sender is not the original
///    sender of `referred-message`, discard the message and abort these steps.²
/// 3. If `referred-message` is not editable (see the associated _Edit applies
///    to_ property), discard the message and abort these steps.
/// 4. Edit `referred-message` as defined by the associated _Edit applies to_
///    property and add an indicator to `referred-message`, informing the user
///    that the message has been edited by the sender at the message's (the
///    `EditMessage`'s) `created-at`.
///
/// ¹: For simplicity, the time constraint is applied on the sender side only.
/// The receiver will always accept a request to edit a message. This is deemed
/// acceptable considering this is not a security feature.
///
/// ²: Implementations do not track the group member setup at the time a message
/// was received. Therefore, an edited message is always sent to the **current**
/// group member setup, including any group members that weren't part of the
/// group when the message was sent. However, any ordinary client will discard
/// `EditMessage` for unknown messages. This leak is not great but considered
/// acceptable for now.
public struct CspE2e_EditMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID of the referred message to be edited.
  public var messageID: UInt64 = 0

  /// Text (or caption) to update the referred message with. Should be ≤ 6000
  /// bytes.
  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Remove an existing message.
///
/// Note: This is a soft-security feature at best and it applies a best effort
/// approach, meaning that it relies on some level of good will on the receiving
/// end. A malicious receiver can easily persist a message prior to removal by
/// e.g. making a screenshot, forwarding it, changing the date, explicitly saving
/// it (if it contains media), etc.
///
/// **Properties (1:1)**:
/// - Kind: 1:1
/// - Flags:
///   - `0x01`: Send push notification.
/// - User profile distribution: No
/// - Exempt from blocking: No
/// - Implicit _direct_ contact creation: No
/// - Protect against replay: Yes
/// - Unarchive: No
/// - Bump _last update_: No
/// - Reflect:
///   - Incoming: Yes
///   - Outgoing: Yes
///   - _Sent_ update: No
/// - Delivery receipts: No
/// - Reactions: No
/// - Edit applies to: N/A
/// - Deletable by: N/A (obviously)
/// - When rejected: N/A (ignored)
/// - Send to Threema Gateway ID group creator: N/A
///
/// **Properties (Group)**:
/// - Kind: Group
/// - Flags:
///   - `0x01`: Send push notification.
/// - User profile distribution: No
/// - Exempt from blocking: No
/// - Implicit _direct_ contact creation: No
/// - Protect against replay: Yes
/// - Unarchive: No
/// - Bump _last update_: No
/// - Reflect:
///   - Incoming: Yes
///   - Outgoing: Yes
///   - _Sent_ update: No
/// - Delivery receipts: N/A
/// - Reactions: No
/// - Edit applies to: N/A
/// - Deletable by: N/A (obviously)
/// - When rejected: N/A (ignored)
/// - Send to Threema Gateway ID group creator: If capture is enabled
///
/// The following steps must be invoked when the user wants to delete a 1:1
/// message:
///
/// 1. If the sender or the receiver do not have `DELETE_MESSAGE_SUPPORT`,
///    disallow removal and abort these steps.
/// 2. Run the _Common Delete Message Preflight Steps_.
/// 3. Let `deleted-at` be the current timestamp.
/// 4. Run the _1:1 Messages Submit Steps_ with `messages` set from the following
///    properties:
///    - `created-at` set to `deleted-at`,
///    - to construct a `DeleteMessage` message.
/// 5. Replace the referred message with a message informing the user that the
///    referred message of the user has been removed at `deleted-at`.²
///
/// The following steps must be invoked when the user wants to delete a group
/// message.
///
/// 1. If the group is marked as _left_, disallow removal and abort these steps.
/// 2. If the sender or all of the group members do not have
///    `DELETE_MESSAGE_SUPPORT`, disallow removal and abort these steps.
/// 3. Run the _Common Delete Message Preflight Steps_.
/// 4. If any of the group members do not have `DELETE_MESSAGE_SUPPORT`, notify
///    the user that the affected contacts will continue to see the message.
/// 5. Let `deleted-at` be the current timestamp.
/// 6. Run the _Group Messages Submit Steps_ with `messages` set from the
///    following properties:
///    - `created-at` set to `deleted-at`,
///    - to construct a `DeleteMessage` message (wrapped by
///      [`group-member-container`](ref:e2e.group-member-container)).
/// 7. Replace the referred message with a message informing the user that the
///    referred message of the user has been removed at `deleted-at`.²
///
/// The following steps are defined as the _Common Delete Message Preflight
/// Steps_:
///
/// 1. Let `message` be the referred message.
/// 2. If the user is not the original sender of `message`, disallow removal and
///    abort these steps.
/// 3. If `message` has been sent (`sent-at`) more than 6 hours ago, disallow
///    removal and abort these steps.¹
///
/// When reflected from another device as an incoming or outgoing 1:1 message:
///
/// 1. Run the _Common Delete Message Receive Steps_.
///
/// When receiving this message as a 1:1 message:
///
/// 1. Run the _Common Delete Message Receive Steps_.
///
/// When reflected from another device as an incoming or outgoing group message:
///
/// 1. Run the _Common Delete Message Receive Steps_.
///
/// When receiving this message as a group message (wrapped by
/// [`group-member-container`](ref:e2e.group-member-container)):
///
/// 1. Run the [_Common Group Receive Steps_](ref:e2e#receiving). If the message
///    has been discarded, abort these steps.
/// 2. Run the _Common Delete Message Receive Steps_.
///
/// The following steps are defined as the _Common Delete Message Receive Steps_:
///
/// 1. Lookup the message with `message_id` originally sent by the sender within
///    the associated conversation and let `referred-message` be the result.
/// 2. If `referred-message` is not defined or the sender is not the original
///    sender of `referred-message`, discard the message and abort these steps.
/// 3. If `referred-message` is not deletable (see the associated _Deletable by_
///    property), discard the message and abort these steps.
/// 4. Replace `referred-message` with a message informing the user that the
///    message of the sender has been removed at the message's (the
///    `DeleteMessage`'s) `created-at`.²
///
/// ¹: For simplicity, the time constraint is applied on the sender side only.
/// The receiver will always accept a request to delete a message. This is deemed
/// acceptable considering this is just barely a soft-security feature.
///
/// ²: All references to a removed message (e.g. quotes) must be updated as well,
/// so that the message content is no longer visible. An implementation should
/// also try to withdraw or update any notification created for a removed
/// message.
public struct CspE2e_DeleteMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID of the referred message to be removed.
  public var messageID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Announces and immediately starts a group call.
///
/// **Properties**:
/// - Kind: Group
/// - Flags:
///   - `0x01`: Send push notification.
/// - User profile distribution: Yes
/// - Exempt from blocking: Yes
/// - Implicit _direct_ contact creation: No
/// - Protect against replay: Yes
/// - Unarchive: TODO(SE-508)
/// - Bump _last update_: TODO(SE-508)
/// - Reflect:
///   - Incoming: Yes
///   - Outgoing: Yes
///   - _Sent_ update: No
/// - Delivery receipts: N/A
/// - Reactions: No
/// - When rejected: N/A¹
/// - Edit applies to: N/A
/// - Deletable by: N/A
/// - Send to Threema Gateway ID group creator: If capture is enabled
///
/// ¹: For the group creator it will be handled as if `group-sync-request` was
/// received, re-sending a `GroupCallStart` if still ongoing, implicitly
/// triggered by FS `Reject` receive steps.
///
/// When the user wants to create a new group call or join an existing group
/// call, run the steps outlined in the _Create or Join_ section of the Group
/// Call Protocol.
///
/// When reflected from another device as an incoming or outgoing message:
///
/// 1. Run the _Common Group Call Start Receive Steps_.
///
/// When receiving this message:
///
/// 1. Run the [_Common Group Receive Steps_](ref:e2e#receiving). If the message
///    has been discarded, abort these steps.
/// 2. Run the _Common Group Call Start Receive Steps_.
///
/// The following steps are defined as the _Common Group Call Start Receive
/// Steps_:
///
/// 1. If the hostname of `sfu_base_url` does not use the scheme `https` or does
///    not end with one of the set of [_Allowed SFU Hostname
///    Suffixes_](ref:group-calls#obtain-sfu-information), log a warning, discard
///    the message and abort these steps.
/// 2. Let `running` be the list of group calls that are currently considered
///    running within the group.
/// 3. If another call with the same GCK exists in `running`, log a warning,
///    discard the message and abort these steps.
/// 4. Add the received call to the list of group calls that are currently
///    considered running (even if `protocol_version` is unsupported¹).
/// 5. Start a task to run the _Group Call Refresh Steps_.²
///
/// ¹: Adding unsupported `protocol_version`s allows the user to join an ongoing
///  call after an app update where support for `protocol_version` has been
///  added.
///
/// ²: This ensures that the user automatically switches to the chosen call if it
/// is currently participating in a group call of this group.
public struct CspE2e_GroupCallStart: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Protocol version used for group calls of this group. The current version
  /// number is `1`.
  ///
  /// Note: This is a _major_ version and may only be increased in case of
  /// breaking changes due to the significant UX impact this has when running the
  /// _Common Group Receive Steps_ (i.e. only calls with supported protocol
  /// versions can be _chosen_).
  public var protocolVersion: UInt32 = 0

  /// The secret Group Call Key (`GCK`) used for this call.
  public var gck: Data = Data()

  /// The base URL of the SFU, used to join or peek the call.
  public var sfuBaseURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// React to a message.
///
/// **Properties (1:1)**:
/// - Kind: 1:1
/// - Flags:
///   - `0x01`: Send push notification.
/// - User profile distribution: Yes
/// - Exempt from blocking: No
/// - Implicit _direct_ contact creation: No
/// - Protect against replay: Yes
/// - Reflect:
///   - Incoming: Yes
///   - Outgoing: Yes
///   - _Sent_ update: No
/// - Delivery receipts: No
/// - Reactions: No, that would be silly!
/// - When rejected: N/A (ignored)
/// - Edit applies to: N/A (can withdraw and apply with another `Reaction`)
/// - Deletable by: N/A (can withdraw with another `Reaction`)
/// - Send to Threema Gateway ID group creator: N/A
///
/// **Properties (Group)**:
/// - Kind: 1:1
/// - Flags:
///   - `0x01`: Send push notification.
/// - User profile distribution: Yes
/// - Exempt from blocking: No
/// - Implicit _direct_ contact creation: No
/// - Protect against replay: Yes
/// - Reflect:
///   - Incoming: Yes
///   - Outgoing: Yes
///   - _Sent_ update: No
/// - Delivery receipts: N/A
/// - Reactions: No, that would be silly!
/// - When rejected: N/A (ignored)
/// - Edit applies to: N/A (can withdraw and apply with another `Reaction`)
/// - Deletable by: N/A (can withdraw with another `Reaction`)
/// - Send to Threema Gateway ID group creator: If capture is enabled
///
/// When the user submits a reaction in a 1:1 conversation:
///
/// 1. Let `reaction` be the reaction to be applied to or withdrawn from a
///    referred message which must contain a single fully-qualified [emoji
///    codepoint sequence that is part of the currently supported Unicode
///    standard][emoji-test.txt].
/// 2. Run the _Legacy Reaction Mapping Steps_ with `reaction` and let
///    `legacy-reaction` be the result.
/// 3. If `legacy-reaction` is not defined and the sender or the receiver does
///    not have `REACTION_SUPPORT`, log a warning and abort these steps.¹
/// 4. Let `reacted-at` be the current timestamp.
/// 5. If both sender and receiver have `REACTION_SUPPORT`, run the _1:1 Messages
///    Submit Steps_ with `messages` set from the following properties:
///    - `created-at` set to `reacted-at`,
///    - to construct a `Reaction` message from `reaction`.
/// 6. If the sender or the receiver does not have `REACTION_SUPPORT`, run the
///    _1:1 Messages Submit Steps_ with `messages` set from the following
///    properties:
///    - `created-at` set to `reacted-at`,
///    - to construct the `legacy-reaction`.
/// 7. Apply `reaction` (i.e. apply or withdraw) to the referred message with the
///    `reacted-at` timestamp.
///
/// When the user submits a reaction in a group conversation:
///
/// 1. Let `reaction` be the reaction to be applied to or withdrawn from a
///    referred message which must contain a single fully-qualified [emoji
///    codepoint sequence that is part of the currently supported Unicode
///    standard][emoji-test.txt].
/// 2. Run the _Legacy Reaction Mapping Steps_ with `reaction` and let
///    `legacy-reaction` be the result.
/// 3. If `legacy-reaction` is not defined:
///    1. If the sender does not have `REACTION_SUPPORT`, log a warning and abort
///       these steps.²
///    2. If all of the group members do not have `REACTION_SUPPORT`, log a
///       warning and and abort these steps.²
///    3. If any of the group members do not have `REACTION_SUPPORT`, notify the
///       user that the affected contacts will not receive the reaction.
/// 4. Let `reacted-at` be the current timestamp.
/// 5. Run the _Group Messages Submit Steps_ with `messages` set from the
///    following properties:
///    - `created-at` set to `reacted-at`,
///    - to construct a _canonical_ `Reaction` message from `reaction`,
///    - to construct a _specific_ message in the following way:
///      1. Let `receiver` be the specific receiver.
///      2. If the `receiver` does not have `REACTION_SUPPORT` and
///         `legacy-reaction` is defined, return the `legacy-reaction` (wrapped
///         by [`group-member-container`](ref:e2e.group-member-container)).
///      3. Construct and return the _canonical_ `Reaction` message from
///         `reaction` (wrapped by
///         [`group-member-container`](ref:e2e.group-member-container)).³
/// 6. Apply `reaction` (i.e. apply or withdraw) to the referred message with the
///    `reacted-at` timestamp.
///
/// The following steps are defined as the _Legacy Reaction Mapping Steps_:
///
/// 1. If `action` is of variant `apply`:
///    1. If `action.apply` equals one of the following codepoint sequences,
///       return a `e2e.delivery-receipt` of type _acknowledge_ (0x03):
///       - `1F44D` (👍)
///       - `1F44D 1F3FB` (👍🏻)
///       - `1F44D 1F3FC` (👍🏼)
///       - `1F44D 1F3FD` (👍🏽)
///       - `1F44D 1F3FE` (👍🏾)
///       - `1F44D 1F3FF` (👍🏿)
///    2. If `action.apply` equals one of the following codepoint sequences,
///       return a `e2e.delivery-receipt` of type _decline_ (0x04):
///       - `1F44E` (👎)
///       - `1F44E 1F3FB` (👎🏻)
///       - `1F44E 1F3FC` (👎🏼)
///       - `1F44E 1F3FD` (👎🏽)
///       - `1F44E 1F3FE` (👎🏾)
///       - `1F44E 1F3FF` (👎🏿)
/// 2. Return no message.
///
/// When reflected from another device as an incoming or outgoing 1:1 message:
///
/// 1. Run the _Common Reaction Receive Steps_.
///
/// When receiving this message:
///
/// 1. Run the _Common Reaction Receive Steps_.
///
/// When receiving this message (wrapped by
/// [`group-member-container`](ref:e2e.group-member-container)):
///
/// 1. Run the [_Common Group Receive Steps_](ref:e2e#receiving). If the reaction
///    message has been discarded, abort these steps.
/// 1. Run the _Common Reaction Receive Steps_.
///
/// The following steps are defined as the _Common Reaction Receive Steps_:
///
/// 1. Lookup the referred message with `message_id` within the associated
///    conversation and let `referred-message` be the result.
/// 2. If `referred-message` is not defined, discard the message and abort these
///    steps.
/// 3. If `referred-message` is not reactable (see the associated _Reactions_
///    property), discard the message and abort these steps.
/// 4. If `action` is of variant `apply`:
///    1. If `apply` contains more than 64 bytes, discard the message and abort
///       these steps.
///    2. Decode `apply` to a UTF-8 string. If the string is empty, discard the
///       message and abort these steps.
///    3. Apply (or re-apply) the resulting emoji from the sender to
///       `referred-message` with the message's (the `Reaction`'s) `created-at`
///       timestamp used for the time of reaction.⁴⁵
/// 5. If `action` is of variant `withdraw`:
///    1. If `withdraw` contains more than 64 bytes, discard the message and
///       abort these steps.
///    2. Decode `withdraw` to a UTF-8 string. If the string is empty, discard
///       the message and abort these steps.
///    3. Remove the resulting emoji reaction from the sender for `message`.⁴⁵
///
/// ¹: The UI should not allow to create non-legacy reactions in 1:1
/// conversations with a sender or receiver that does not have
/// `REACTION_SUPPORT`.
///
/// ²: The UI should not allow to create non-legacy reactions in group
/// conversations with a sender that does not have `REACTION_SUPPORT` or when all
/// other group members don't have `REACTION_SUPPORT`.
///
/// ³: In case the reaction could not be mapped to a legacy reaction, this
/// results in a `Reaction` message being sent to group members that currently do
/// not support reactions. This is intentional.
///
/// ⁴: Note that the _apply_ mechanism is additive, meaning multiple reactions
/// from the same sender are allowed on a single message. This is why the
/// _withdraw_ mechanism is needed which removes a specific reaction. On the
/// other hand, a deprecated `e2e.delivery-receipt` will replace all existing
/// reactions of the sender at once (including these new-style reactions).
///
/// ⁵: The UI should display a placeholder (�) for unknown emojis, meaining those
/// which are not a single fully-qualified [emoji codepoint sequence that is part
/// of the currently supported Unicode standard][emoji-test.txt]. But the
/// individual code sequences still have individual display buckets.
///
/// [emoji-test.txt]: https://www.unicode.org/Public/emoji/latest/emoji-test.txt
public struct CspE2e_Reaction: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID of the referred message.
  public var messageID: UInt64 = 0

  /// A single emoji reaction to be applied or withdrawn.
  public var action: CspE2e_Reaction.OneOf_Action? = nil

  /// Apply a new emoji reaction.
  public var apply: Data {
    get {
      if case .apply(let v)? = action {return v}
      return Data()
    }
    set {action = .apply(newValue)}
  }

  /// Withdraw a specific emoji reaction.
  public var withdraw: Data {
    get {
      if case .withdraw(let v)? = action {return v}
      return Data()
    }
    set {action = .withdraw(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single emoji reaction to be applied or withdrawn.
  public enum OneOf_Action: Equatable, @unchecked Sendable {
    /// Apply a new emoji reaction.
    case apply(Data)
    /// Withdraw a specific emoji reaction.
    case withdraw(Data)

  }

  public init() {}
}

/// Request joining a group.
///
/// This message is sent to the administrator of a group. The required
/// information is provided by a `GroupInvite` URL payload.
///
/// **Properties**:
/// - Kind: 1:1
/// - Flags:
///   - `0x01`: Send push notification.
/// - User profile distribution: Yes
/// - Exempt from blocking: Yes
/// - Implicit _direct_ contact creation: Yes
/// - Protect against replay: Yes
/// - Reflect:
///   - Incoming: Yes
///   - Outgoing: Yes
///   - _Sent_ update: No
/// - Delivery receipts: No
/// - Reactions: No
/// - When rejected: N/A (ignored)
/// - Edit applies to: N/A
/// - Deletable by: User only
/// - Send to Threema Gateway ID group creator: N/A
///
/// When receiving this message:
///
/// 1. Look up the corresponding group invitation by the token.
/// 2. If the group invitation could not be found, discard the message and abort
///    these steps.
/// 3. If the sender is already part of the group, send an accept response and
///    then respond as if the sender had sent a `group-sync-request` (i.e. send a
///    `group-setup`, `group-name`, etc.). Finally, abort these steps.
/// 4. If the group name does not match the name in the originally sent group
///    invitation, discard the message and abort these steps.
/// 5. If the group invitation has expired, send the respective response and
///    abort these steps.
/// 6. If the group invitation requires the admin to accept the request, show
///    this information in the user interface and pause these steps until the
///    user manually confirmed of rejected the request. Note that the date of the
///    decision is allowed to extend beyond the expiration date of the group
///    invitation. Continue with the following sub-steps once the user made a
///    decision on the request:
///     1. If the user manually rejected the request, send the respective
///        response and abort these steps.
/// 7. If the group is full, send the respective response and abort these steps.
/// 8. Send an accept response.
/// 9. Add the sender of the group invitation request to the group and follow the
///    group protocol from there.
public struct CspE2e_GroupJoinRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The group invite token, 16 bytes
  public var token: Data = Data()

  /// The group name from the group invite URL
  public var groupName: String = String()

  /// A message for the group administrator, e.g. for identification purposes
  ///
  /// The message helps the administrator to decide whether or not to accept a
  /// join request.
  ///
  /// Should be requested by the user interface for invitations that require
  /// manual confirmation by the administrator. Should not be requested in case
  /// the invitation will be automatically accepted.
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response sent by the admin of a group towards a sender of a valid group join
/// request.
///
/// **Properties**:
/// - Kind: 1:1
/// - Flags: None
/// - User profile distribution: Yes
/// - Exempt from blocking: Yes
/// - Implicit _direct_ contact creation: Yes
/// - Protect against replay: Yes
/// - Reflect:
///   - Incoming: Yes
///   - Outgoing: Yes
///   - _Sent_ update: No
/// - Delivery receipts: No
/// - Reactions: No
/// - When rejected: N/A (ignored)
/// - Edit applies to: N/A
/// - Deletable by: N/A
/// - Send to Threema Gateway ID group creator: N/A
///
/// When receiving this message:
///
/// 1. Look up the corresponding group join request by the token and the
///    sender's Threema ID as the administrator's Threema ID.
/// 2. If the group join request could not be found, discard the message and
///    abort these steps.
/// 3. Mark the group join request as accepted or (automatically) rejected by
///    the given response type.
/// 4. If the group join request has been accepted, remember the group id in
///    order to be able to map an incoming `group-setup` to the group.
public struct CspE2e_GroupJoinResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The group invite token, 16 bytes
  public var token: Data = Data()

  public var response: CspE2e_GroupJoinResponse.Response {
    get {return _response ?? CspE2e_GroupJoinResponse.Response()}
    set {_response = newValue}
  }
  /// Returns true if `response` has been explicitly set.
  public var hasResponse: Bool {return self._response != nil}
  /// Clears the value of `response`. Subsequent reads from it will return its default value.
  public mutating func clearResponse() {self._response = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Response of the admin
  public struct Response: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var response: CspE2e_GroupJoinResponse.Response.OneOf_Response? = nil

    /// Accept a group invite request
    public var accept: CspE2e_GroupJoinResponse.Response.Accept {
      get {
        if case .accept(let v)? = response {return v}
        return CspE2e_GroupJoinResponse.Response.Accept()
      }
      set {response = .accept(newValue)}
    }

    /// Token of a group invitation expired
    public var expired: Common_Unit {
      get {
        if case .expired(let v)? = response {return v}
        return Common_Unit()
      }
      set {response = .expired(newValue)}
    }

    /// Group invitation cannot be accepted due to the group being full
    public var groupFull: Common_Unit {
      get {
        if case .groupFull(let v)? = response {return v}
        return Common_Unit()
      }
      set {response = .groupFull(newValue)}
    }

    /// The administrator explicitly rejects the invitation request
    public var reject: Common_Unit {
      get {
        if case .reject(let v)? = response {return v}
        return Common_Unit()
      }
      set {response = .reject(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Response: Equatable, Sendable {
      /// Accept a group invite request
      case accept(CspE2e_GroupJoinResponse.Response.Accept)
      /// Token of a group invitation expired
      case expired(Common_Unit)
      /// Group invitation cannot be accepted due to the group being full
      case groupFull(Common_Unit)
      /// The administrator explicitly rejects the invitation request
      case reject(Common_Unit)

    }

    /// Accept a group invite request
    public struct Accept: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Group ID (little-endian) as chosen by the group creator
      ///
      /// Note: Combined with the Threema ID of the administrator, this forms the
      /// `GroupIdentity`.
      public var groupID: UInt64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _response: CspE2e_GroupJoinResponse.Response? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "csp_e2e"

extension CspE2e_MessageMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "padding"),
    3: .standard(proto: "message_id"),
    4: .standard(proto: "created_at"),
    2: .same(proto: "nickname"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.padding) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._nickname) }()
      case 3: try { try decoder.decodeSingularFixed64Field(value: &self.messageID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.createdAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.padding.isEmpty {
      try visitor.visitSingularBytesField(value: self.padding, fieldNumber: 1)
    }
    try { if let v = self._nickname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if self.messageID != 0 {
      try visitor.visitSingularFixed64Field(value: self.messageID, fieldNumber: 3)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CspE2e_MessageMetadata, rhs: CspE2e_MessageMetadata) -> Bool {
    if lhs.padding != rhs.padding {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs._nickname != rhs._nickname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2e_EditMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.messageID != 0 {
      try visitor.visitSingularFixed64Field(value: self.messageID, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CspE2e_EditMessage, rhs: CspE2e_EditMessage) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2e_DeleteMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.messageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.messageID != 0 {
      try visitor.visitSingularFixed64Field(value: self.messageID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CspE2e_DeleteMessage, rhs: CspE2e_DeleteMessage) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2e_GroupCallStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupCallStart"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "protocol_version"),
    2: .same(proto: "gck"),
    3: .standard(proto: "sfu_base_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.protocolVersion) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.gck) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sfuBaseURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.protocolVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.protocolVersion, fieldNumber: 1)
    }
    if !self.gck.isEmpty {
      try visitor.visitSingularBytesField(value: self.gck, fieldNumber: 2)
    }
    if !self.sfuBaseURL.isEmpty {
      try visitor.visitSingularStringField(value: self.sfuBaseURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CspE2e_GroupCallStart, rhs: CspE2e_GroupCallStart) -> Bool {
    if lhs.protocolVersion != rhs.protocolVersion {return false}
    if lhs.gck != rhs.gck {return false}
    if lhs.sfuBaseURL != rhs.sfuBaseURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2e_Reaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Reaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .same(proto: "apply"),
    3: .same(proto: "withdraw"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.messageID) }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.action != nil {try decoder.handleConflictingOneOf()}
          self.action = .apply(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.action != nil {try decoder.handleConflictingOneOf()}
          self.action = .withdraw(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.messageID != 0 {
      try visitor.visitSingularFixed64Field(value: self.messageID, fieldNumber: 1)
    }
    switch self.action {
    case .apply?: try {
      guard case .apply(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .withdraw?: try {
      guard case .withdraw(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CspE2e_Reaction, rhs: CspE2e_Reaction) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2e_GroupJoinRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupJoinRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .standard(proto: "group_name"),
    3: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularBytesField(value: self.token, fieldNumber: 1)
    }
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CspE2e_GroupJoinRequest, rhs: CspE2e_GroupJoinRequest) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.groupName != rhs.groupName {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2e_GroupJoinResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupJoinResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "response"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._response) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.token.isEmpty {
      try visitor.visitSingularBytesField(value: self.token, fieldNumber: 1)
    }
    try { if let v = self._response {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CspE2e_GroupJoinResponse, rhs: CspE2e_GroupJoinResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs._response != rhs._response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2e_GroupJoinResponse.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CspE2e_GroupJoinResponse.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accept"),
    2: .same(proto: "expired"),
    3: .standard(proto: "group_full"),
    4: .same(proto: "reject"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CspE2e_GroupJoinResponse.Response.Accept?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .accept(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .accept(v)
        }
      }()
      case 2: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .expired(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .expired(v)
        }
      }()
      case 3: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .groupFull(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .groupFull(v)
        }
      }()
      case 4: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .reject(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .reject(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .accept?: try {
      guard case .accept(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .expired?: try {
      guard case .expired(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .groupFull?: try {
      guard case .groupFull(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .reject?: try {
      guard case .reject(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CspE2e_GroupJoinResponse.Response, rhs: CspE2e_GroupJoinResponse.Response) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2e_GroupJoinResponse.Response.Accept: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CspE2e_GroupJoinResponse.Response.protoMessageName + ".Accept"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.groupID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularFixed64Field(value: self.groupID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CspE2e_GroupJoinResponse.Response.Accept, rhs: CspE2e_GroupJoinResponse.Response.Accept) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
