// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: group-call.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// # Group Call Protocol
//
// Note that group calls are not necessarily bound to a Threema group. _Group_
// refers to a group of call participants and is a way to distinguish from 1:1
// Threema calls.
//
// There are two primary variants which use the same technology underneath:
//
// - A group call scoped to a (Threema) group is simple and easy to use. It does
//   not have any advanced functionality such as administration or external
//   guests. Only one group call is intended to run within a group.
// - A conference call is a more advanced type of group call and delivers more
//   advanced functionality such as administration. Concrete specification
//   pending.
//
// The theoretical maximum amount of participants is 790 (due to the way we
// derive WebRTC MIDs) but the practical limit is way below that.
//
// ## Terminology
//
// - `GCK`: Group Call Key, only used for key derivation
// - `GCKH`: Group Call Key Hash
// - `GCNHAK`: Group Call Normal Handshake Authentication Key
// - `GCHK`: Group Call Handshake Key
// - `GCSK`: Group Call State Key
// - `GCAK`: Group Call Administrator Key, only used for key derivation
// - `GCAMK`: Group Call Administrator Message Key
// - `PCK`: Participant Call Key
// - `PCMK`: Participant Call Media Key, only used for key derivation
// - `PCMK`': Ratchet iteration of PCMK
// - `PCMFK`: Participant Call Media Frame Key
// - `PCCK`: Participant Call Cookie
// - `PCSN`: Participant Call Sequence Number
// - `MFSN`: Media Frame Sequence Number
//
// ## General Information
//
// **Endianness**: All integers use little-endian encoding.
//
// **Encryption cipher**: XSalsa20-Poly1305, unless otherwise specified.
//
// **Nonce format**:
//
// - a 16 byte cookie (PCCK), followed by
// - a monotonically increasing sequence number (PCSN, u64-le).
//
// **Sequence number**: The sequence number starts with `1` and is counted
// separately for each direction (i.e. there is one sequence number counter for
// the sender and one for the receiver). We will use `PCSN+` in this document to
// denote that the counter should be increased **after** the value has been
// inserted (i.e. semantically equivalent to `x++` in many languages).
//
// Note: This format is equivalent to the CSP transport encryption.
//
// ## Key Derivation
//
// Note: All keys that are not derived from `GCK` directly will be derived using
// `GCKH` as input. This ensures that exchanged secret keys are useless if the
// Group Call ID has been exposed (unless `GCK` is also known to the attacker).
//
//     GCKH = BLAKE2b(key=GCK, salt='#', personal='3ma-call')
//
//     GCHK = BLAKE2b(key=GCK, salt='h', personal='3ma-call')
//     GCSK = BLAKE2b(key=GCK, salt='s', personal='3ma-call')
//
//     GCAMK = BLAKE2b(key=GCAK, salt='am', personal='3ma-call', input=GCKH)
//
//     PCMK' = BLAKE2b(key=PCMK, salt="m'", personal='3ma-call')
//     PCMFK = BLAKE2b(key=PCMK, salt='mf', personal='3ma-call', input=GCKH)
//
// ## Group Call ID Derivation
//
// For group calls scoped to groups, the Group Call ID is derived by running
// BLAKE2b on specific data provided by the `GroupCallStart`:
//
//     group-call-id = BLAKE2b(
//       out-length=32,
//       salt='i',
//       personal='3ma-call',
//       input=
//            group-creator-identity
//         || group-id
//         || u8(GroupCallStart.protocol_version)
//         || GroupCallStart.gck
//         || utf8-encode(GroupCallStart.sfu_base_url),
//     )
//
// ## Protocol Flow
//
// ### Obtain SFU Information
//
// Before a call can be joined or created, SFU information and an authentication
// token need to be obtained via the Directory Server API. The obtained
// information includes the following items referenced in subsequent sections:
//
// - _SFU Base URL_: Base URL used to create and distribute new calls.
// - _Allowed SFU Hostname Suffixes_: A set of allowed hostname suffixes to be
//   applied against the _SFU Base URL_ when joining calls.
// - _SFU Token_: An opaque token used to authenticate against the SFU.
//
// When receiving the SFU information, ensure the _SFU Base URL_ uses the scheme
// `https` and the included hostname ends with one of the _Allowed SFU Hostname
// Suffixes_.
//
// ### Scoped to Group
//
// #### Periodic Refresh
//
// The following steps are defined as the _Group Call Refresh Steps_ and will be
// applied to update the group calls that are currently considered running
// within a group, determining which one of them is the chosen call and
// potentially join the chosen call:
//
// 1. Let `running` be the list of group calls that are currently considered
//    running within the group.
// 2. Let `calls` be a copy of `running`. Reset the _token-refreshed_ mark of
//    each `call` of `calls` (or simply scope it to the execution of these
//    steps).
// 3. For each `call` of `calls`, run the following steps (labelled _peek-call_)
//    concurrently and wait for them to return:
//    1. If the user is currently participating in `call`, abort the _peek-call_
//       sub-steps.
//    2. _Peek_ the `call` via a `SfuHttpRequest.Peek` request. If this does not
//       result in a response within 5s, remove `call` from `calls` and abort
//       the _peek-call_ sub-steps.
//    3. If the received status code for `call` is `401` and `call` is not
//       marked with _token-refreshed_:
//       1. Refresh the _SFU Token_. If the _SFU Token_ refresh fails or does
//          not yield an _SFU Token_ within 10s, remove `call` from `calls` and
//          abort the _peek-call_ sub-steps.
//       2. Mark the `call` as _token-refreshed_.
//       3. Restart the _peek-call_ sub-steps for this `call`.
//    4. If the server could not be reached or the received status code is not
//       `200` or if the _Peek_ response could not be decoded:
//       1. Remove `call` from `calls`.
//       2. If the received status code is `404`, remove `call` from `running`
//          and abort the _peek-call_ sub-steps.
//       3. If the `call`'s _failed_ counter is `>= 3` and the `call` was
//          received more than 10h ago, remove `call` from `running` and abort
//          the _peek-call_ sub-steps.
//       4. Increase the _failed_ counter for `call` by `1` and abort the
//          _peek-call_ sub-steps.
//    5. Reset the `call`'s _failed_ counter to `0`.
//    6. If the protocol version of the `call` is not supported, remove `call`
//       from `calls`, log a warning that a group call with an unsupported
//       version is currently running and abort the _peek-call_ sub-steps.
//    7. (`call` is kept in `calls` and in `running`.)
// 4. If `running` is empty, cancel the timer to periodically re-run the _Group
//    Call Refresh Steps_ of this group. Otherwise, restart or schedule the
//    timer to re-run the _Group Call Refresh Steps_ of this group in 10s.
// 5. Let `chosen-call` be any call of `calls` with the highest `started_at`
//    value (i.e. the most recently created call) as provided by the _peek_
//    result.
// 6. If `chosen-call` is not defined, signal that no group call is currently
//    running within the group, abort these steps and return `chosen-call`.
// 7. Signal `chosen-call` as the currently running group call within the group.
// 8. If the _Group Call Join Steps_ are currently running with a different (or
//    new) group call than `chosen-call`, cancel and restart the _Group Call
//    Join Steps_ asynchronously with the same `intent` but with the
//    `chosen-call`.
// 9. If the user is currently participating in a group call of this group that
//    is different to `chosen-call`, exit the running group call and run the
//    _Group Call Join Steps_ asynchronously with the `intent` to _only join_
//    `chosen-call`.
// 10. Return `chosen-call`.
//
// Note: The above steps have been carefully crafted to gracefully handle cases
// where the SFU of one call cannot be reached for a short period of time.
//
// When the Threema app is active, run the _Group Call Refresh Steps_ for each
// group. This will start a timer to refresh any group call status.
//
// When the user leaves a group call, run the _Group Call Refresh Steps_ for the
// respective group.
//
// The above described timer may be cancelled when the Threema app is inactive.
// The timer interval may be increased to 30s in case the group conversation is
// currently not visible to the user.
//
// #### Create or Join
//
// The following steps are to be run when a user wants to join a group call of a
// group where a group call is currently considered running (e.g. the user hits
// _join_ in the UI) or when the user intents to create a group call for a group
// where no group call is currently considered running (e.g. the user hits the
// _call_ button in the UI):
//
// 1. Let `intent` be the user's intent, i.e. to either _only join_ or _create
//    or join_ a group call.
// 2. Refresh the _SFU Token_ if necessary. If the _SFU Token_ refresh fails
//    within 10s, abort these steps and notify the user.
// 3. Run the _Group Call Refresh Steps_ for the respective group and let `call`
//    be the result.
// 4. If `call` is undefined and `intent` is to _only join_, abort these steps
//    and notify the user that no group call is running / the group call is no
//    longer running.
// 5. If `call` is undefined, create (but don't send) a `GroupCallStart`
//    message, apply it to `call` and mark `call` as _new_.
// 6. Run the _Group Call Join Steps_ with the `intent` and `call`.
//
// The following steps are defined as the _Group Call Join Steps_ (also applied
// for creating a group call).:
//
// 1. Let `intent` be either _only join_ or _create or join_. Let `call` be the
//    given group call to be joined (or created).
// 2.  _Join_ (or implicitly create) the group call via a `SfuHttpRequest.Join`
//    request. If this does not result in a response within 10s, abort these
//    steps and notify the user.
// 3. If the received status code is `503`, notify the user that the group call
//    is full and abort these steps.
// 4. If the server could not be reached or the received status code is not
//    `200` or if the _Join_ response could not be decoded, abort these steps
//    and notify the user.
// 5. Establish a WebRTC connection to the SFU with the information provided in
//    the _Join_ response. Wait until the SFU sent the initial
//    `SfuToParticipant.Hello` message via the associated data channel. Let
//    `hello` be that message.
// 6. If the `hello.participants` contains less than 4 items, set the initial
//    capture state of the microphone to _on_.
// 7. If `call` is marked as _new_:
//    1. Optionally add an artificial wait period of 2s minus the time elapsed
//       since step 1.[^1]
//    2. Announce (the previously created but not yet sent) `call` in the
//       associated group by sending it as a `GroupCallStart` message.
//    3. Add the created `call` to the list of group calls that are currently
//       considered running.
//    4. Asynchronously run the _Group Call Refresh Steps_.[^2]
// 8. The group call is now considered established and should asynchronously
//    invoke the SFU to Participant and Participant to Participant flows.
//
// [^1]: This prevents butter-fingered user from accidentally starting a group
// call.
//
// [^2]: This will initiate the refresh timer for a newly created call and
// signal it to the UI.
//
// Note: Implementations need to ensure that only one group call can be active
// at the same time in the application. This means that only one invocation of
// the _Create or Join_ flow and only one invocation of the _Group Call Join
// Steps_ can be active. Be aware that these steps can be cancelled by the user
// and by the _Group Call Refresh Steps_.
//
// ### SFU to Participant Flow
//
// Upon successful joining via `SfuHttpRequest.Join`, the SFU waits for the
// client to establish a WebRTC connection and then announces all participants
// to the newly joined participant in its `SfuToParticipant.Hello` message.
//
// When another participant joins or leaves, a `ParticipantJoined` or
// `ParticipantLeft` message will be sent.
//
// At any time, participants may subscribe and unsubscribe receiving microphone,
// camera and screen data from other participants.
//
// If the user is alone in a call for more than 3 minute, the call should be
// left to save resources. The SFU will automatically drop such calls after 5
// minutes but this results in non-ideal UX.
//
// ### Participant to Participant Flow
//
// Unlike the other flows, this one is more complicated and needs to be done
// separately for each other participant. During the handshake, ephemeral
// encryption keys will be established.
//
// Note that multiple participants with the same Threema ID in the same call are
// **explicitly allowed**. Not only can this happen in case the connection has
// been lost (e.g. the client already reconnected but the SFU has not detected
// connection loss yet), but it is also a feature for multi-device capable
// clients.
//
// #### Handshake
//
// When a new participant (NP) joins, it must authenticate each other existing
// participant (EP) and establish an ephemeral shared secret (`PCK`). The flow
// depends on whether NP and EP are normal or guest participants:
//
// If both are normal participants:
//
//     NP ----- Hello ---> EP
//     NP <---- Hello ---- EP
//     NP <---- Auth ----- EP
//     NP ----- Auth ----> EP
//
// If both are guest participants:
//
//     NP -- GuestHello -> EP
//     NP <- GuestHello -- EP
//     NP <- GuestAuth --- EP
//     NP -- GuestAuth --> EP
//
// If NP is a normal participant and EP is a guest participant:
//
//     NP ----- Hello ---> EP
//     NP <- GuestHello -- EP
//     NP <- GuestAuth --- EP
//     NP -- GuestAuth --> EP
//
// If NP is a guest participant and NP is a normal participant:
//
//     NP -- GuestHello -> EP
//     NP <---- Hello ---- EP
//     NP <- GuestAuth --- EP
//     NP -- GuestAuth --> EP
//
// Note: This looks more intimidating than it really is. Basically, if either is
// a guest, we fulfill the guest handshake but both always start with sending
// their respective role's _hello_ variant.
//
// For group calls scoped to groups:
//
// - Only handshake messages from Threema IDs that are part of the group are
//   allowed.
// - External guests are not allowed and therefore the guest handshake is not
//   allowed.
//
// #### Post-Handshake
//
// After the handshake, **both** sides run the following steps:
//
// 1. Subscribe to the other participant's microphone feed (i.e. send a
//    `ParticipantMicrophone` message to the SFU).
// 2. If the user is an administrator, send an `Admin.ReportAsAdmin` message to
//    the other participant.
// 3. If _hold_ is currently active, send a `Hold` message to the other
//    participant.
// 4. If _hold_ is not currently active, send a `CaptureState` message to the
//    other participant for each device (camera, microphone, ...) that is
//    currently activated (`Mode` is `ON`).
//
// #### Join/Leave of Other Participants
//
// When a new participant joins, all other participants run the following steps:
//
// 1. Let `pcmk` be the currently _applied_ PCMK with the associated context.
// 2. If the amount of ratchet rounds for `pcmk` is `255`, abort the call with
//    an error condition and abort these steps.
// 3. Advance the ratchet of `pcmk` once (i.e. replace the key by deriving
//    PCMK') and apply for media encryption immediately. Note: Do **not** reset
//    the MFSN!
// 4. Set the _handshake state_ of this participant to `await-np-hello`.
//
// Note: The announcement of the new participant is guaranteed to be sent prior
// to any handshake messages of the new participant.
//
// When a participant leaves, all other participants run the following steps:
//
// 1. Let `pending-pcmk` be the currently _pending_ PCMK the associated context.
// 2. If `pending-pcmk` exists, additionally mark `pending-pcmk` as _stale_ and
//    abort these steps.
// 3. Let `current-pcmk` be the currently _applied_ PCMK with the associated
//    context.
// 4. Set `pending-pcmk` in the following way:
//    1. Generate a new cryptographically secure random PCMK and assign it to
//       `pending-pcmk`.
//    2. Set `pending-pcmk.epoch` to `current-pcmk.epoch + 1`, wrap back to `0`
//       if it would be `256`.
//    3. Set `pending-pcmk.ratchet_counter` to `0`.
//    4. Do **not** reset the MFSN! Continue the existing MFSN counter of the
//       previous PCMK.
// 5. Send `pending-pcmk` to all authenticated participants via a _rekey_
//    message.
// 6. Schedule a task to run the following steps after 2s:
//   1. Apply `pending-pcmk` for media encryption. This means that
//      `pending-pcmk` now replaces the _applied_ PCMK and is no longer
//      _pending_.
//   2. If `pending-pcmk` is marked as _stale_, run the parent steps from the
//      beginning.
//
// When a participant receives a _rekey_ message from another participant.
//
// 1. Let `current-pcmk` be the PCMK and its associated context used for the
//    participant.
// 2. Let `new-pcmk` be the media keys (PCMK) of the received message.
// 3. Store `new-pcmk` as a successor to `current-pcmk` (and any other successor
//    already stored on `current-pcmk`) and follow the description of the media
//    frame on when to apply it.
//
// Note: The result of the above steps is that re-keying is throttled but always
// catches up to the current participant state with a maximum delay of 4s.
//
// #### State Update
//
// One of the participants is deterministically designated to update the
// peekable call state every 10s and additionally every time a participant joins
// or leaves. If the call state has not been updated/refreshed for 30s, the SFU
// will delete it.
//
// After each change to the list of participants, run the following steps to
// determine whether the user is designated:
//
// 1. Cancel any running timer to update the call state.
// 2. Let `candidates` be a list of all currently authenticated non-guest
//    participants.
// 3. If `candidates` is empty, add all currently authenticated guest
//    participants to the list.
// 4. If the user is not in `candidates`, abort these steps.
// 5. If the user does not have the lowest participant ID in `candidates`, abort
//    these steps.
// 6. Send a `ParticipantToSfu.UpdateCallState` message to the SFU and schedule
//    a repetitive timer to repeat this step every 10s.
//
// Note: The above algorithm is prone to races since the authentication process
// is asynchronous for each participant pair. However, this should not be an
// issue as they'd essentially post the same status (eventually).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Current call state as announced by the designated client.
///
/// Note: The `CallState` accurateness must not be relied upon as it can be out
///       of date and can be replayed by the SFU.
public struct Groupcall_CallState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Random amount of padding, ignored by the receiver.
  public var padding: Data = Data()

  /// Participant ID of the designated client that created this message.
  public var stateCreatedBy: UInt32 = 0

  /// UNIX-ish timestamp in milliseconds the designated client created this
  /// message.
  public var stateCreatedAt: UInt64 = 0

  /// Information for each participant of the group call.
  public var participants: Dictionary<UInt32,Groupcall_CallState.Participant> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Information for a single participant.
  public struct Participant {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Type-specific information.
    public var participant: Groupcall_CallState.Participant.OneOf_Participant? = nil

    public var threema: Groupcall_CallState.Participant.Normal {
      get {
        if case .threema(let v)? = participant {return v}
        return Groupcall_CallState.Participant.Normal()
      }
      set {participant = .threema(newValue)}
    }

    public var guest: Groupcall_CallState.Participant.Guest {
      get {
        if case .guest(let v)? = participant {return v}
        return Groupcall_CallState.Participant.Guest()
      }
      set {participant = .guest(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Type-specific information.
    public enum OneOf_Participant: Equatable {
      case threema(Groupcall_CallState.Participant.Normal)
      case guest(Groupcall_CallState.Participant.Guest)

    #if !swift(>=4.1)
      public static func ==(lhs: Groupcall_CallState.Participant.OneOf_Participant, rhs: Groupcall_CallState.Participant.OneOf_Participant) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.threema, .threema): return {
          guard case .threema(let l) = lhs, case .threema(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.guest, .guest): return {
          guard case .guest(let l) = lhs, case .guest(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// A _normal_ participant, i.e. a Threema client.
    public struct Normal {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Threema ID of the sender.
      public var identity: String = String()

      /// Nickname associated to the Threema ID (without `~` prefix).
      public var nickname: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// A _guest_ participant.
    public struct Guest {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The guest's self-assigned name.
      public var name: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

/// Request payloads sent to the SFU as part of an HTTP request.
public struct Groupcall_SfuHttpRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Peeks for the current state of the group call for the given Group Call ID.
  ///
  /// IMPORTANT: The _peek_ process is considered stable across different
  /// protocol versions. Therefore, the message **should** maintain backwards
  /// compatibility!
  ///
  /// The URL is formed in the following way:
  ///
  ///     <sfu_base_url>/v1/peek/<call_id-as-hex>
  ///
  /// When sending this request:
  ///
  /// 1. Use `POST` as method.
  /// 2. Set the `Authorization` header to `ThreemaSfuToken <sfu-token>`.
  /// 3. Set the encoded `SfuHttpRequest.Join` message as body.
  ///
  /// When receiving this request:
  ///
  /// 1. If the `Authorization` header is missing, the provided `sfu-token` in
  ///    the `Authorization` header is invalid or expired, respond with status
  ///    code `401` and abort these steps.
  /// 2. If the provided data is invalid, respond with status code `400` and
  ///    abort these steps.
  /// 3. If `call_id` does not equal the Call ID from the URL (decoded
  ///    `call_id-as-hex`), respond with status code `400` and abort these steps.
  /// 4. If no group call for the given `call_id` is currently running, respond
  ///    with status code `404` and abort these steps.
  /// 5. Respond with status code `200` and an encoded `SfuHttpResponse.Peek`
  ///    message as body.
  public struct Peek {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Group Call ID associated to the group call.
    public var callID: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Requests to join the group call with the given Group Call ID.
  ///
  /// The URL is formed in the following way:
  ///
  ///     <sfu_base_url>/v1/join/<call_id-as-hex>
  ///
  /// When sending this request:
  ///
  /// 1. Use `POST` as method.
  /// 2. Set the `Authorization` header to `ThreemaSfuToken <sfu-token>`.
  /// 3. Set the encoded `SfuHttpRequest.Join` message as body.
  ///
  /// When receiving this request:
  ///
  /// 1. If the `Authorization` header is missing, the provided `sfu-token` in
  ///    the `Authorization` header is invalid or expired, respond with status
  ///    code `401` and abort these steps.
  /// 2. If the provided data is invalid, respond with status code `400` and
  ///    abort these steps.
  /// 3. If `call_id` does not equal the Call ID from the URL (decoded
  ///    `call_id-as-hex`), respond with status code `400` and abort these steps.
  /// 4. If the `protocol_version` is unsupported by the SFU, respond with status
  ///    code `419` and abort these steps.
  /// 5. If no more participants can join the group call for the given `call_id`,
  ///    respond with status code `503` and abort these steps.
  /// 6. Respond with status code `200` and an encoded `SfuHttpResponse.Join`
  ///    message as body.
  /// 7. Once the WebRTC connection has been established, announce the newly
  ///    joined participant to all other participants via the corresponding data
  ///    channel. If no WebRTC connection is being established within 30s, the
  ///    participant ID is no longer reserved for the client and the group call
  ///    must be teared down if no other participant started joining this group
  ///    call.
  public struct Join {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Group Call ID associated to the group call.
    public var callID: Data = Data()

    /// Protocol version the call was announced with.
    public var protocolVersion: UInt32 = 0

    /// DTLS fingerprint of the x509 certificate that will be used by the client.
    ///
    /// Note: This is the authentication anchor for the WebRTC connection towards
    ///       the SFU.
    public var dtlsFingerprint: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Response payloads sent back from the SFU as part of an HTTP request.
public struct Groupcall_SfuHttpResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Information returned for a running group call.
  ///
  /// IMPORTANT: The _peek_ process is considered stable across different
  /// protocol versions. Therefore, the message **should** maintain backwards
  /// compatibility!
  ///
  /// Note: The included `CallState` information may not be accurate and should
  /// not be relied upon.
  public struct Peek {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Unix-ish timestamp in milliseconds for when the first participant joined
    /// the Group Call ID and therefore started the group call.
    public var startedAt: UInt64 = 0

    /// Maximum amount of participants allowed in the group call.
    public var maxParticipants: UInt32 = 0

    /// Call state (`CallState`), encrypted by `GCSK.secret` and prefixed with a
    /// random nonce.
    ///
    /// Not provided in case the call is currently running but no participant has
    /// sent a call state to the SFU, or if the call state expired.
    ///
    /// The content of the call state is protocol version dependent and should
    /// therefore be ignored if a client does not support the particular protocol
    /// version the group call is associated with.
    public var encryptedCallState: Data {
      get {return _encryptedCallState ?? Data()}
      set {_encryptedCallState = newValue}
    }
    /// Returns true if `encryptedCallState` has been explicitly set.
    public var hasEncryptedCallState: Bool {return self._encryptedCallState != nil}
    /// Clears the value of `encryptedCallState`. Subsequent reads from it will return its default value.
    public mutating func clearEncryptedCallState() {self._encryptedCallState = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _encryptedCallState: Data? = nil
  }

  /// Information returned when joining a group call.
  ///
  /// When receiving this response, initiate the WebRTC connection to the SFU and
  /// consider the connection established when the `SfuToParticipant.Hello`
  /// message has been received on the associated data channel.
  public struct Join {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Unix-ish timestamp in milliseconds for when the first participant joined
    /// the Group Call ID and therefore started the group call.
    public var startedAt: UInt64 = 0

    /// Maximum amount of participants allowed in the group call.
    public var maxParticipants: UInt32 = 0

    /// Participant ID assigned to the client.
    ///
    /// Note: The client needs to know the participant ID early to derive MIDs
    ///       required to be present in the O/A SDP.
    public var participantID: UInt32 = 0

    /// List of addresses the SFU listens for a WebRTC connection.
    ///
    /// Note: One UDP IPv4 address is mandatory! One IPv6 address is recommended.
    public var addresses: [Groupcall_SfuHttpResponse.Join.Address] = []

    /// ICE username fragment for the WebRTC connection.
    public var iceUsernameFragment: String = String()

    /// ICE password for the WebRTC connection.
    public var icePassword: String = String()

    /// DTLS fingerprint of the x509 certificate that will be used by the SFU.
    ///
    /// Note: This is the authentication anchor for the WebRTC connection towards
    ///       the SFU.
    public var dtlsFingerprint: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Address the SFU is listening for a WebRTC connection.
    public struct Address {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var `protocol`: Groupcall_SfuHttpResponse.Join.Address.ProtocolEnum = .udp

      /// Port.
      public var port: UInt32 = 0

      /// IPv4 or IPv6 address.
      public var ip: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Protocol.
      public enum ProtocolEnum: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case udp // = 0
        case UNRECOGNIZED(Int)

        public init() {
          self = .udp
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .udp
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .udp: return 0
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Groupcall_SfuHttpResponse.Join.Address.ProtocolEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Groupcall_SfuHttpResponse.Join.Address.ProtocolEnum] = [
    .udp,
  ]
}

#endif  // swift(>=4.2)

/// Messages sent from the SFU to a participant via a data channel.
///
/// Data Channel Parameters:
///
/// - `ordered`: `true`
/// - `negotiated`: `true`
/// - `id`: `0`
public struct Groupcall_SfuToParticipant {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The enveloped message from the SFU.
  ///
  /// When relaying a message from one participant to another, omit any
  /// additional padding.
  ///
  /// IMPORTANT: The format of the `SfuToParticipant.Envelope` and
  /// `ParticipantToSfu.Envelope` must be compatible for the relay case, so the
  /// SFU can forward the data without having to re-encode.
  public struct Envelope {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Random amount of padding, ignored by the receiver.
    public var padding: Data = Data()

    public var content: Groupcall_SfuToParticipant.Envelope.OneOf_Content? = nil

    public var relay: Groupcall_ParticipantToParticipant.OuterEnvelope {
      get {
        if case .relay(let v)? = content {return v}
        return Groupcall_ParticipantToParticipant.OuterEnvelope()
      }
      set {content = .relay(newValue)}
    }

    public var hello: Groupcall_SfuToParticipant.Hello {
      get {
        if case .hello(let v)? = content {return v}
        return Groupcall_SfuToParticipant.Hello()
      }
      set {content = .hello(newValue)}
    }

    public var participantJoined: Groupcall_SfuToParticipant.ParticipantJoined {
      get {
        if case .participantJoined(let v)? = content {return v}
        return Groupcall_SfuToParticipant.ParticipantJoined()
      }
      set {content = .participantJoined(newValue)}
    }

    public var participantLeft: Groupcall_SfuToParticipant.ParticipantLeft {
      get {
        if case .participantLeft(let v)? = content {return v}
        return Groupcall_SfuToParticipant.ParticipantLeft()
      }
      set {content = .participantLeft(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Content: Equatable {
      case relay(Groupcall_ParticipantToParticipant.OuterEnvelope)
      case hello(Groupcall_SfuToParticipant.Hello)
      case participantJoined(Groupcall_SfuToParticipant.ParticipantJoined)
      case participantLeft(Groupcall_SfuToParticipant.ParticipantLeft)

    #if !swift(>=4.1)
      public static func ==(lhs: Groupcall_SfuToParticipant.Envelope.OneOf_Content, rhs: Groupcall_SfuToParticipant.Envelope.OneOf_Content) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.relay, .relay): return {
          guard case .relay(let l) = lhs, case .relay(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.hello, .hello): return {
          guard case .hello(let l) = lhs, case .hello(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.participantJoined, .participantJoined): return {
          guard case .participantJoined(let l) = lhs, case .participantJoined(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.participantLeft, .participantLeft): return {
          guard case .participantLeft(let l) = lhs, case .participantLeft(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// Announces all other participants to a newly joined participant.
  ///
  /// When receiving this message:
  ///
  /// 1. If a `Hello` was received before (i.e. if the receiver is not a newly
  ///    joined participant), log a warning and abort these steps.
  /// 2. Initiate the participant to participate handshake for each participant
  ///    listed in this message.
  public struct Hello {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// All participants in the group call. This **excludes** the client's
    /// participant ID.
    public var participantIds: [UInt32] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Announces that a new participant joined to existing participants.
  ///
  /// When receiving this message:
  ///
  /// 1. Look up the participant. If it already exists (i.e. never _left_), log a
  ///    warning and abort these steps.
  /// 2. Run the corresponding steps described by the _Join/Leave_ section.
  public struct ParticipantJoined {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var participantID: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Announces that a participant left to existing participants.
  ///
  /// When receiving this message:
  ///
  /// 1. Look up the participant. If it was never announced to have _joined_ by
  ///    an associated `ParticipantJoined` message, log a warning and abort these
  ///    steps.
  /// 2. Run the corresponding steps described by the _Join/Leave_ section.
  public struct ParticipantLeft {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var participantID: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Messages sent from a participant to the SFU via a data channel.
///
/// Data Channel Parameters:
///
/// - `ordered`: `true`
/// - `negotiated`: `true`
/// - `id`: `0`
public struct Groupcall_ParticipantToSfu {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The enveloped message towards the SFU.
  ///
  /// When relaying a message from one participant to another, omit any
  /// additional padding.
  ///
  /// IMPORTANT: The format of the `SfuToParticipant.Envelope` and
  /// `ParticipantToSfu.Envelope` must be compatible for the relay case, so the
  /// SFU can forward the data without having to re-encode.
  public struct Envelope {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Random amount of padding, ignored by the receiver.
    public var padding: Data = Data()

    public var content: Groupcall_ParticipantToSfu.Envelope.OneOf_Content? = nil

    public var relay: Groupcall_ParticipantToParticipant.OuterEnvelope {
      get {
        if case .relay(let v)? = content {return v}
        return Groupcall_ParticipantToParticipant.OuterEnvelope()
      }
      set {content = .relay(newValue)}
    }

    public var updateCallState: Groupcall_ParticipantToSfu.UpdateCallState {
      get {
        if case .updateCallState(let v)? = content {return v}
        return Groupcall_ParticipantToSfu.UpdateCallState()
      }
      set {content = .updateCallState(newValue)}
    }

    public var requestParticipantMicrophone: Groupcall_ParticipantToSfu.ParticipantMicrophone {
      get {
        if case .requestParticipantMicrophone(let v)? = content {return v}
        return Groupcall_ParticipantToSfu.ParticipantMicrophone()
      }
      set {content = .requestParticipantMicrophone(newValue)}
    }

    public var requestParticipantCamera: Groupcall_ParticipantToSfu.ParticipantCamera {
      get {
        if case .requestParticipantCamera(let v)? = content {return v}
        return Groupcall_ParticipantToSfu.ParticipantCamera()
      }
      set {content = .requestParticipantCamera(newValue)}
    }

    public var requestParticipantScreenShare: Groupcall_ParticipantToSfu.ParticipantScreen {
      get {
        if case .requestParticipantScreenShare(let v)? = content {return v}
        return Groupcall_ParticipantToSfu.ParticipantScreen()
      }
      set {content = .requestParticipantScreenShare(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Content: Equatable {
      case relay(Groupcall_ParticipantToParticipant.OuterEnvelope)
      case updateCallState(Groupcall_ParticipantToSfu.UpdateCallState)
      case requestParticipantMicrophone(Groupcall_ParticipantToSfu.ParticipantMicrophone)
      case requestParticipantCamera(Groupcall_ParticipantToSfu.ParticipantCamera)
      case requestParticipantScreenShare(Groupcall_ParticipantToSfu.ParticipantScreen)

    #if !swift(>=4.1)
      public static func ==(lhs: Groupcall_ParticipantToSfu.Envelope.OneOf_Content, rhs: Groupcall_ParticipantToSfu.Envelope.OneOf_Content) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.relay, .relay): return {
          guard case .relay(let l) = lhs, case .relay(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.updateCallState, .updateCallState): return {
          guard case .updateCallState(let l) = lhs, case .updateCallState(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.requestParticipantMicrophone, .requestParticipantMicrophone): return {
          guard case .requestParticipantMicrophone(let l) = lhs, case .requestParticipantMicrophone(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.requestParticipantCamera, .requestParticipantCamera): return {
          guard case .requestParticipantCamera(let l) = lhs, case .requestParticipantCamera(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.requestParticipantScreenShare, .requestParticipantScreenShare): return {
          guard case .requestParticipantScreenShare(let l) = lhs, case .requestParticipantScreenShare(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// Update the call state that can be retrieved via a _peek_.
  ///
  /// Note: Only the currently designated client should send this to the SFU.
  ///
  /// When receiving this message:
  ///
  /// 1. Store the encrypted call state and make it accessible via _peek_ HTTP
  ///    requests.
  /// 2. Start a timer to purge the call state after 30s. Subsequent
  ///    `UpdateCallState` messages will update the call state and reset the
  ///    timer.
  public struct UpdateCallState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Call state (`CallState`), encrypted by `GCSK` and prefixed with
    /// a random nonce.
    public var encryptedCallState: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Subscribe or unsubscribe to a participant's microphone feed.
  ///
  /// When receiving this message:
  ///
  /// 1. If the `participant_id` refers to the sender's participant ID or an
  ///    unknown participant ID, discard the message and abort these steps.
  /// 2. If `subscribe` is set, forward the microphone feed to the client that
  ///    fits best to the provided parameters.
  /// 3. If `unsubscribe` is set, stop forwarding microphone feed of this
  ///    participant to the client.
  public struct ParticipantMicrophone {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Participant ID whose microphone feed should be subscribed or unsubscribed
    /// from.
    public var participantID: UInt32 = 0

    public var action: Groupcall_ParticipantToSfu.ParticipantMicrophone.OneOf_Action? = nil

    public var subscribe: Groupcall_ParticipantToSfu.ParticipantMicrophone.Subscribe {
      get {
        if case .subscribe(let v)? = action {return v}
        return Groupcall_ParticipantToSfu.ParticipantMicrophone.Subscribe()
      }
      set {action = .subscribe(newValue)}
    }

    public var unsubscribe: Groupcall_ParticipantToSfu.ParticipantMicrophone.Unsubscribe {
      get {
        if case .unsubscribe(let v)? = action {return v}
        return Groupcall_ParticipantToSfu.ParticipantMicrophone.Unsubscribe()
      }
      set {action = .unsubscribe(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Action: Equatable {
      case subscribe(Groupcall_ParticipantToSfu.ParticipantMicrophone.Subscribe)
      case unsubscribe(Groupcall_ParticipantToSfu.ParticipantMicrophone.Unsubscribe)

    #if !swift(>=4.1)
      public static func ==(lhs: Groupcall_ParticipantToSfu.ParticipantMicrophone.OneOf_Action, rhs: Groupcall_ParticipantToSfu.ParticipantMicrophone.OneOf_Action) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.subscribe, .subscribe): return {
          guard case .subscribe(let l) = lhs, case .subscribe(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.unsubscribe, .unsubscribe): return {
          guard case .unsubscribe(let l) = lhs, case .unsubscribe(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// Subscribe to a participant's microphone feed.
    public struct Subscribe {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Unsubscribe a participant's microphone feed.
    public struct Unsubscribe {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  /// Subscribe or unsubscribe to a participant's camera feed.
  ///
  /// When receiving this message:
  ///
  /// 1. If the `participant_id` refers to the sender's participant ID or an
  ///    unknown participant ID, discard the message and abort these steps.
  /// 2. If `subscribe` is set, forward the camera feed to the client that fits
  ///    best to the provided parameters.
  /// 3. If `unsubscribe` is set, stop forwarding camera feed of this participant
  ///    to the client.
  public struct ParticipantCamera {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Participant ID whose camera feed should be subscribed or unsubscribed
    /// from.
    public var participantID: UInt32 = 0

    public var action: Groupcall_ParticipantToSfu.ParticipantCamera.OneOf_Action? = nil

    public var subscribe: Groupcall_ParticipantToSfu.ParticipantCamera.Subscribe {
      get {
        if case .subscribe(let v)? = action {return v}
        return Groupcall_ParticipantToSfu.ParticipantCamera.Subscribe()
      }
      set {action = .subscribe(newValue)}
    }

    public var unsubscribe: Groupcall_ParticipantToSfu.ParticipantCamera.Unsubscribe {
      get {
        if case .unsubscribe(let v)? = action {return v}
        return Groupcall_ParticipantToSfu.ParticipantCamera.Unsubscribe()
      }
      set {action = .unsubscribe(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Action: Equatable {
      case subscribe(Groupcall_ParticipantToSfu.ParticipantCamera.Subscribe)
      case unsubscribe(Groupcall_ParticipantToSfu.ParticipantCamera.Unsubscribe)

    #if !swift(>=4.1)
      public static func ==(lhs: Groupcall_ParticipantToSfu.ParticipantCamera.OneOf_Action, rhs: Groupcall_ParticipantToSfu.ParticipantCamera.OneOf_Action) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.subscribe, .subscribe): return {
          guard case .subscribe(let l) = lhs, case .subscribe(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.unsubscribe, .unsubscribe): return {
          guard case .unsubscribe(let l) = lhs, case .unsubscribe(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// Subscribe to a participant's camera feed.
    public struct Subscribe {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Desired resolution. The client should use the canvas' resolution the
      /// camera feed be displayed in. The SFU will select the spatial layer that
      /// fits best.
      public var desiredResolution: Common_Resolution {
        get {return _desiredResolution ?? Common_Resolution()}
        set {_desiredResolution = newValue}
      }
      /// Returns true if `desiredResolution` has been explicitly set.
      public var hasDesiredResolution: Bool {return self._desiredResolution != nil}
      /// Clears the value of `desiredResolution`. Subsequent reads from it will return its default value.
      public mutating func clearDesiredResolution() {self._desiredResolution = nil}

      /// Desired frame rate. The SFU will select the temporal layer that fits
      /// best.
      public var desiredFps: UInt32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _desiredResolution: Common_Resolution? = nil
    }

    /// Unsubscribe a participant's camera feed.
    public struct Unsubscribe {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  /// Subscribe or unsubscribe to a participant's screen feed.
  public struct ParticipantScreen {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Participant ID whose screen feed should be subscribed or unsubscribed
    /// from.
    public var participantID: UInt32 = 0

    public var action: Groupcall_ParticipantToSfu.ParticipantScreen.OneOf_Action? = nil

    public var subscribe: Groupcall_ParticipantToSfu.ParticipantScreen.Subscribe {
      get {
        if case .subscribe(let v)? = action {return v}
        return Groupcall_ParticipantToSfu.ParticipantScreen.Subscribe()
      }
      set {action = .subscribe(newValue)}
    }

    public var unsubscribe: Groupcall_ParticipantToSfu.ParticipantScreen.Unsubscribe {
      get {
        if case .unsubscribe(let v)? = action {return v}
        return Groupcall_ParticipantToSfu.ParticipantScreen.Unsubscribe()
      }
      set {action = .unsubscribe(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Action: Equatable {
      case subscribe(Groupcall_ParticipantToSfu.ParticipantScreen.Subscribe)
      case unsubscribe(Groupcall_ParticipantToSfu.ParticipantScreen.Unsubscribe)

    #if !swift(>=4.1)
      public static func ==(lhs: Groupcall_ParticipantToSfu.ParticipantScreen.OneOf_Action, rhs: Groupcall_ParticipantToSfu.ParticipantScreen.OneOf_Action) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.subscribe, .subscribe): return {
          guard case .subscribe(let l) = lhs, case .subscribe(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.unsubscribe, .unsubscribe): return {
          guard case .unsubscribe(let l) = lhs, case .unsubscribe(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// Subscribe to a participant's screen feed.
    public struct Subscribe {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Unsubscribe a participant's screen feed.
    public struct Unsubscribe {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

/// Messages sent from one participant to another.
///
/// Note that these are relayed via `SfuToParticipant.Envelope` and
/// `ParticipantToSfu.Envelope` in order to prevent races with
/// `ParticipantJoined`/`ParticipantLeft`.
public struct Groupcall_ParticipantToParticipant {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Used for all messages that are relayed from one participant to another via
  /// the SFU.
  ///
  /// When receiving a relayed message:
  ///
  /// 1. If the `receiver` is not the user's assigned participant id, discard the
  ///    message and abort these steps.
  /// 2. If the `sender` is unknown, discard the message and abort these steps.
  /// 3. Decrypt `encrypted_data` according to the current _handshake state_ and
  ///    handle the inner envelope:
  ///    - `await-ep-hello` or `await-np-hello`: Expect a
  ///      `Handshake.HelloEnvelope`.
  ///    - `await-auth`: Expect a `Handshake.AuthEnvelope`.
  ///    - `done`: Expect a post-auth `Envelope`.
  public struct OuterEnvelope {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Participant ID of the sender. Checked by the SFU to be correct, dropped
    /// if not.
    public var sender: UInt32 = 0

    /// Participant ID of the receiver. Checked by the SFU to exist, dropped if
    /// not.
    public var receiver: UInt32 = 0

    /// The inner envelope. Always encrypted. Key and nonce are to be inferred
    /// from the current _handshake state_ towards the sending participant.
    public var encryptedData: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Messages required for the initial lock-step handshake between participants.
  public struct Handshake {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The first message (`HelloEnvelope(Hello)` or `HelloEnvelope(GuestHello)`)
    /// of both sides is always encrypted by `GCHK`, prefixed with a
    /// random nonce.
    public struct HelloEnvelope {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Random amount of padding, ignored by the receiver
      public var padding: Data = Data()

      public var content: Groupcall_ParticipantToParticipant.Handshake.HelloEnvelope.OneOf_Content? = nil

      public var hello: Groupcall_ParticipantToParticipant.Handshake.Hello {
        get {
          if case .hello(let v)? = content {return v}
          return Groupcall_ParticipantToParticipant.Handshake.Hello()
        }
        set {content = .hello(newValue)}
      }

      public var guestHello: Groupcall_ParticipantToParticipant.Handshake.GuestHello {
        get {
          if case .guestHello(let v)? = content {return v}
          return Groupcall_ParticipantToParticipant.Handshake.GuestHello()
        }
        set {content = .guestHello(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Content: Equatable {
        case hello(Groupcall_ParticipantToParticipant.Handshake.Hello)
        case guestHello(Groupcall_ParticipantToParticipant.Handshake.GuestHello)

      #if !swift(>=4.1)
        public static func ==(lhs: Groupcall_ParticipantToParticipant.Handshake.HelloEnvelope.OneOf_Content, rhs: Groupcall_ParticipantToParticipant.Handshake.HelloEnvelope.OneOf_Content) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.hello, .hello): return {
            guard case .hello(let l) = lhs, case .hello(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.guestHello, .guestHello): return {
            guard case .guestHello(let l) = lhs, case .guestHello(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public init() {}
    }

    /// If both sides started the normal handshake, the second message is
    /// encrypted in the following way:
    ///
    /// 1. Let `inner-nonce` be a random nonce.
    /// 2. Let `inner-data` be encrypted by:
    ///
    /// ```text
    /// S = X25519HSalsa20(<sender.CK>.secret, <receiver.CK>.public)
    /// GCNHAK = Blake2b(
    ///   key=S, salt='nha', personal='3ma-call', input=GCKH)
    /// XSalsa20-Poly1305(
    ///   key=GCNHAK,
    ///   nonce=<inner-nonce>,
    ///   data=<AuthEnvelope(Auth)>,
    /// )
    /// ```
    /// 3. Let `outer-data` be encrypted by:
    ///
    /// ```text
    /// XSalsa20-Poly1305(
    ///   key=X25519HSalsa20(<sender.PCK>.secret, <receiver.PCK>.public),
    ///   nonce=<sender.PCCK> || <sender.PCSN+>,
    ///   data=<inner-nonce> || <inner-data>,
    /// )
    /// ```
    /// 4. Return `outer-data`.
    ///
    /// If either side started the guest handshake, the second message is
    /// encrypted by:
    ///
    /// ```text
    /// XSalsa20-Poly1305(
    ///   key=X25519HSalsa20(<sender.PCK>.secret, <receiver.PCK>.public),
    ///   nonce=<sender.PCCK> || <sender.PCSN+>,
    ///   data=<AuthEnvelope(GuestAuth)>,
    /// )
    /// ```
    ///
    /// When receiving this message:
    ///
    /// 1. If either side initiated a guest handshake via a `GuestHello`, expect
    ///    `guest_auth` to be set. If `guest_auth` is not set, log a warning and
    ///    abort these steps.
    /// 2. If both sides initiated the (normal) handshake, expect `auth` to be
    ///    set. If `auth` is not set, log a warning and abort these steps.
    public struct AuthEnvelope {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Random amount of padding, ignored by the receiver
      public var padding: Data = Data()

      public var content: Groupcall_ParticipantToParticipant.Handshake.AuthEnvelope.OneOf_Content? = nil

      public var auth: Groupcall_ParticipantToParticipant.Handshake.Auth {
        get {
          if case .auth(let v)? = content {return v}
          return Groupcall_ParticipantToParticipant.Handshake.Auth()
        }
        set {content = .auth(newValue)}
      }

      public var guestAuth: Groupcall_ParticipantToParticipant.Handshake.GuestAuth {
        get {
          if case .guestAuth(let v)? = content {return v}
          return Groupcall_ParticipantToParticipant.Handshake.GuestAuth()
        }
        set {content = .guestAuth(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Content: Equatable {
        case auth(Groupcall_ParticipantToParticipant.Handshake.Auth)
        case guestAuth(Groupcall_ParticipantToParticipant.Handshake.GuestAuth)

      #if !swift(>=4.1)
        public static func ==(lhs: Groupcall_ParticipantToParticipant.Handshake.AuthEnvelope.OneOf_Content, rhs: Groupcall_ParticipantToParticipant.Handshake.AuthEnvelope.OneOf_Content) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.auth, .auth): return {
            guard case .auth(let l) = lhs, case .auth(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.guestAuth, .guestAuth): return {
            guard case .guestAuth(let l) = lhs, case .guestAuth(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public init() {}
    }

    /// Initial handshake message.
    ///
    /// When creating this message as a newly joined participant towards another
    /// participant:
    ///
    /// 1. Set the participant's _handshake state_ to `await-ep-hello`.
    /// 2. Send this message.
    ///
    /// When receiving this message as a guest participant:
    ///
    /// 1. Map it to a `GuestHello` in the following way:
    ///    - `name`: `Hello.nickname`
    ///    - `pck`: `Hello.pck`
    ///    - `pcck`: `Hello.pcck`
    /// 2. Handle the mapped `GuestHello` as if it had been received directly.
    ///
    /// When receiving this message as a regular participant:
    ///
    /// 1. (Placeholder for conference call PCK != GCAMK step.)
    /// 2. If the group call is scoped to a (Threema) group and `identity` is not
    ///    part of the associated group (including the user itself), log a
    ///    warning and abort these steps.
    /// 3. If the sender is a newly joined participant and therefore the
    ///    _handshake state_ was set to `await-np-hello` (as described by the
    ///    _Join/Leave_ section):
    ///    1. Respond by sending a `Hello` message, immediately followed by an
    ///       `Auth` message.
    ///    2. Set the participant's _handshake state_ to `await-auth` and abort
    ///       these steps.
    /// 4. If the participant's _handshake state_ is `await-ep-hello`:
    ///    1. If the `pck` reflects the local PCK.public or the `pcck` reflects
    ///       the local PCCK, log a warning and abort these steps.
    ///    2. Respond by sending an `Auth` message.
    ///    3. Set the participant's _handshake state_ to `await-auth` and abort
    ///       these steps.
    /// 5. Log a warning and abort these steps.
    public struct Hello {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Threema ID of the sender.
      public var identity: String = String()

      /// Nickname associated to the Threema ID (without `~` prefix).
      public var nickname: String = String()

      /// 32 byte ephemeral public key (`PCK.public`) towards the remote
      /// participant.
      ///
      /// Note: It is allowed to use the same `PCK` for multiple participants.
      public var pck: Data = Data()

      /// 16 byte random cookie used for nonces by the sender in subsequent
      /// messages.
      public var pcck: Data = Data()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Second and final handshake message.
    ///
    /// When receiving this message:
    ///
    /// 1. If the participant's _handshake state_ is not `await-auth`, log a
    ///    warning and abort these steps.
    /// 2. If the repeated `pck` does not equal the local `PCK.public` used
    ///    towards this participant, log a warning and abort these steps.
    /// 3. If the repeated `pcck` does not equal the local `PCCK` used towards
    ///    this participant, log a warning and abort these steps.
    /// 4. Set the participant's _handshake state_ to `done`.
    public struct Auth {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// 32 byte repeated ephemeral public key from the `Hello` message.
      ///
      /// Note: Repeating the sender's `PCK.public` prevents replay attacks.
      public var pck: Data = Data()

      /// 32 byte repeated random cookie from the `Hello` message.
      ///
      /// Note: Repeating the sender's `PCCK` prevents replay attacks while
      ///       allowing the sender to use the same `PCK` for multiple
      ///       participants.
      public var pcck: Data = Data()

      /// The currently applied PCMK and any _pending_ PCMK used for media
      /// encryption, specifically in that order.
      ///
      /// Note: An implementation can expect at least one media key to be
      /// present.
      public var mediaKeys: [Groupcall_ParticipantToParticipant.MediaKey] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Initial guest handshake message.
    ///
    /// When creating this message as a newly joined guest participant towards
    /// another participant:
    ///
    /// 1. Set the participant's _handshake state_ to `await-ep-hello`.
    /// 2. Send this message.
    ///
    /// When receiving this message:
    ///
    /// 1. If guest participants are not allowed for this call, log a warning
    ///    and abort these steps.
    /// 2. (Placeholder for conference call PCK != GCAMK step.)
    /// 3. If the sender is a newly joined participant and therefore the
    ///    _handshake state_ was set to `await-np-hello` (as described by the
    ///    _Join/Leave_ section):
    ///    1. Respond by sending a `GuestHello` message, immediately followed by
    ///       a `GuestAuth` message.
    ///    2. Set the participant's _handshake state_ to `await-guest-auth` and
    ///       abort these steps.
    /// 4. If the participant's _handshake state_ is `await-ep-hello`:
    ///    1. If the `pck` reflects the local PCK.public or the `pcck` reflects
    ///       the local PCCK, log a warning and abort these steps.
    ///    2. Respond by sending a `GuestAuth` message.
    ///    3. Set the participant's _handshake state_ to `await-guest-auth` and
    ///       abort these steps.
    /// 5. Log a warning and abort these steps.
    public struct GuestHello {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The guest's self-assigned name.
      public var name: String = String()

      /// 32 byte ephemeral public key (`PCK.public`) towards the remote
      /// participant.
      ///
      /// Note: It is allowed to use the same `PCK` for multiple participants.
      public var pck: Data = Data()

      /// 16 byte random cookie used for nonces by the sender in subsequent
      /// messages.
      public var pcck: Data = Data()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Second and final handshake message triggered if either side initiated the
    /// guest handshake.
    ///
    /// When receiving this message:
    ///
    /// 1. If the participant's _handshake state_ is not `await-guest-auth`, log
    ///    a warning and abort these steps.
    /// 2. If the repeated `pck` does not equal the local `PCK.public` used
    ///    towards this participant, log a warning and abort these steps.
    /// 3. If the repeated `pcck` does not equal the local `PCCK` used towards
    ///    this participant, log a warning and abort these steps.
    /// 4. Set the participant's _handshake state_ to `done`.
    public struct GuestAuth {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// 32 byte repeated ephemeral public key from the `GuestHello` message.
      ///
      /// Note: Repeating the sender's `PCK.public` prevents replay attacks.
      public var pck: Data = Data()

      /// 32 byte repeated random cookie from the `GuestHello` message.
      ///
      /// Note: Repeating the sender's `PCCK` prevents replay attacks while
      ///       allowing the sender to use the same `PCK` for multiple
      ///       participants.
      public var pcck: Data = Data()

      /// The currently applied PCMK and any _pending_ PCMK used for media
      /// encryption, specifically in that order.
      ///
      /// Note: An implementation can expect at least one media key to be
      /// present.
      public var mediaKeys: [Groupcall_ParticipantToParticipant.MediaKey] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  /// After fulfilling either the (normal) handshake or the guest handshake, all
  /// following messages are encoded in `Envelope` and encrypted by:
  ///
  /// ```text
  /// XSalsa20-Poly1305(
  ///   key=X25519HSalsa20(<sender.PCK>.secret, <receiver.PCK>.public),
  ///   nonce=<sender.PCCK> || <sender.PCSN+>,
  /// )
  /// ```
  ///
  /// Note: Since the guest handshake is TOFU, an attacker knowing `GCK` having
  /// control over the SFU may apply a MITM attack between a guest participant
  /// and another participant. The attacker would be able to silently eavesdrop
  /// all media traffic between the two participants. This is repeatable for all
  /// other participants and means the attacker is able to silently eavesdrop the
  /// whole call. Therefore, if a call is not open for guests, `GuestHello` (and
  /// `GuestAuth`) **must not** be accepted.
  ///
  /// When receiving this message:
  ///
  /// 1. If the participant's _handshake state_ is not `done`, log a warning and
  ///    abort these steps.
  /// 2. Handle the message according to the content.
  public struct Envelope {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Random amount of padding, ignored by the receiver
    public var padding: Data = Data()

    public var content: Groupcall_ParticipantToParticipant.Envelope.OneOf_Content? = nil

    /// An `Admin.Envelope`, encrypted as described by that message.
    public var encryptedAdminEnvelope: Data {
      get {
        if case .encryptedAdminEnvelope(let v)? = content {return v}
        return Data()
      }
      set {content = .encryptedAdminEnvelope(newValue)}
    }

    /// Announces new media keys a participant will apply soon.
    public var rekey: Groupcall_ParticipantToParticipant.MediaKey {
      get {
        if case .rekey(let v)? = content {return v}
        return Groupcall_ParticipantToParticipant.MediaKey()
      }
      set {content = .rekey(newValue)}
    }

    /// Announces capture state changes of a participant.
    public var captureState: Groupcall_ParticipantToParticipant.CaptureState {
      get {
        if case .captureState(let v)? = content {return v}
        return Groupcall_ParticipantToParticipant.CaptureState()
      }
      set {content = .captureState(newValue)}
    }

    /// Announces that the participant entered the _hold_ state.
    public var holdState: Groupcall_ParticipantToParticipant.HoldState {
      get {
        if case .holdState(let v)? = content {return v}
        return Groupcall_ParticipantToParticipant.HoldState()
      }
      set {content = .holdState(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Content: Equatable {
      /// An `Admin.Envelope`, encrypted as described by that message.
      case encryptedAdminEnvelope(Data)
      /// Announces new media keys a participant will apply soon.
      case rekey(Groupcall_ParticipantToParticipant.MediaKey)
      /// Announces capture state changes of a participant.
      case captureState(Groupcall_ParticipantToParticipant.CaptureState)
      /// Announces that the participant entered the _hold_ state.
      case holdState(Groupcall_ParticipantToParticipant.HoldState)

    #if !swift(>=4.1)
      public static func ==(lhs: Groupcall_ParticipantToParticipant.Envelope.OneOf_Content, rhs: Groupcall_ParticipantToParticipant.Envelope.OneOf_Content) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.encryptedAdminEnvelope, .encryptedAdminEnvelope): return {
          guard case .encryptedAdminEnvelope(let l) = lhs, case .encryptedAdminEnvelope(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.rekey, .rekey): return {
          guard case .rekey(let l) = lhs, case .rekey(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.captureState, .captureState): return {
          guard case .captureState(let l) = lhs, case .captureState(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.holdState, .holdState): return {
          guard case .holdState(let l) = lhs, case .holdState(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// Messages from admins towards participants (including admins).
  public struct Admin {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Message from an administrator, encrypted by:
    ///
    /// ```text
    /// XSalsa20-Poly1305(
    ///   key=X25519HSalsa20(GCAMK.secret, <receiver.PCK>.public),
    ///   nonce=<sender.PCCK> || <sender.PCSN+>,
    /// )
    /// ```
    ///
    /// IMPORTANT: The `ParticipantToParticipant.Envelope` that encapsulates this
    /// message shall be encrypted by the same `PCSN` as used for this
    /// `Envelope`. The only difference is that the sender uses `GCAMK` instead
    /// of its ephemeral `PCK`.
    public struct Envelope {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var content: Groupcall_ParticipantToParticipant.Admin.Envelope.OneOf_Content? = nil

      public var reportAsAdmin: Groupcall_ParticipantToParticipant.Admin.ReportAsAdmin {
        get {
          if case .reportAsAdmin(let v)? = content {return v}
          return Groupcall_ParticipantToParticipant.Admin.ReportAsAdmin()
        }
        set {content = .reportAsAdmin(newValue)}
      }

      public var promoteToAdmin: Groupcall_ParticipantToParticipant.Admin.PromoteToAdmin {
        get {
          if case .promoteToAdmin(let v)? = content {return v}
          return Groupcall_ParticipantToParticipant.Admin.PromoteToAdmin()
        }
        set {content = .promoteToAdmin(newValue)}
      }

      public var forceLeave: Groupcall_ParticipantToParticipant.Admin.ForceLeave {
        get {
          if case .forceLeave(let v)? = content {return v}
          return Groupcall_ParticipantToParticipant.Admin.ForceLeave()
        }
        set {content = .forceLeave(newValue)}
      }

      public var forceCaptureStateOff: Groupcall_ParticipantToParticipant.Admin.ForceCaptureStateOff {
        get {
          if case .forceCaptureStateOff(let v)? = content {return v}
          return Groupcall_ParticipantToParticipant.Admin.ForceCaptureStateOff()
        }
        set {content = .forceCaptureStateOff(newValue)}
      }

      public var forceFocus: Groupcall_ParticipantToParticipant.Admin.ForceFocus {
        get {
          if case .forceFocus(let v)? = content {return v}
          return Groupcall_ParticipantToParticipant.Admin.ForceFocus()
        }
        set {content = .forceFocus(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Content: Equatable {
        case reportAsAdmin(Groupcall_ParticipantToParticipant.Admin.ReportAsAdmin)
        case promoteToAdmin(Groupcall_ParticipantToParticipant.Admin.PromoteToAdmin)
        case forceLeave(Groupcall_ParticipantToParticipant.Admin.ForceLeave)
        case forceCaptureStateOff(Groupcall_ParticipantToParticipant.Admin.ForceCaptureStateOff)
        case forceFocus(Groupcall_ParticipantToParticipant.Admin.ForceFocus)

      #if !swift(>=4.1)
        public static func ==(lhs: Groupcall_ParticipantToParticipant.Admin.Envelope.OneOf_Content, rhs: Groupcall_ParticipantToParticipant.Admin.Envelope.OneOf_Content) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.reportAsAdmin, .reportAsAdmin): return {
            guard case .reportAsAdmin(let l) = lhs, case .reportAsAdmin(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.promoteToAdmin, .promoteToAdmin): return {
            guard case .promoteToAdmin(let l) = lhs, case .promoteToAdmin(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.forceLeave, .forceLeave): return {
            guard case .forceLeave(let l) = lhs, case .forceLeave(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.forceCaptureStateOff, .forceCaptureStateOff): return {
            guard case .forceCaptureStateOff(let l) = lhs, case .forceCaptureStateOff(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.forceFocus, .forceFocus): return {
            guard case .forceFocus(let l) = lhs, case .forceFocus(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public init() {}
    }

    /// Report as an administrator.
    ///
    /// When receiving this message, mark the sender as an administrator in the
    /// UI.
    public struct ReportAsAdmin {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Promote the receiver to an administrator.
    ///
    /// Note: This is final for the scope of this Group Call. An administrator
    ///       cannot be demoted.
    ///
    /// When receiving this message:
    ///
    /// 1. If the user already is an administrator, abort these steps.
    /// 2. Derive GCAMK and calculate the associated public key from the received
    ///    `gcak`. If it does not match the known `GCAMK.public`, log a warning
    ///    and abort these steps.
    /// 3. Send an `Admin.ReportAsAdmin` message to all other participants
    ///    (including the sender who promoted the user to an admin).
    /// 4. Notify the user of its admin status and enable administration
    ///    functionality in the UI.
    public struct PromoteToAdmin {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var gcak: Data = Data()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Force the receiver to leave the call.
    public struct ForceLeave {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Force the receiver's capture device to be turned off.
    ///
    /// Note: This is a momentary enforcement. A participant may immediately
    ///       restart capturing a device (e.g. unmute itself) and the message is
    ///       not repeated towards newly joined participants.
    ///
    /// When receiving this message:
    ///
    /// 1. Look up the corresponding device. If none could be found, abort these
    ///    steps.
    /// 2. If the device's capture state is already _off_, abort these steps.
    /// 3. Send a `CaptureState` message for the device and follow the creation
    ///    steps of that message (i.e. stop capturing, etc.).
    public struct ForceCaptureStateOff {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var device: Groupcall_ParticipantToParticipant.Admin.ForceCaptureStateOff.Device = .all

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum Device: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// Stop capturing all devices
        case all // = 0

        /// Stop capturing the microphone (i.e. mute)
        case microphone // = 1

        /// Stop capturing the camera
        case camera // = 2

        /// Stop capturing the screen
        case screen // = 3
        case UNRECOGNIZED(Int)

        public init() {
          self = .all
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .all
          case 1: self = .microphone
          case 2: self = .camera
          case 3: self = .screen
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .all: return 0
          case .microphone: return 1
          case .camera: return 2
          case .screen: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}
    }

    /// Force focus on a specific participant.
    ///
    /// Note: This is a momentary enforcement. A participant may immediately
    ///       remove the focus and the message is not repeated towards newly
    ///       joined participants.
    ///
    /// When receiving this message:
    ///
    /// 1. Look up the participant to be focused. If none could be found, abort
    ///    these steps.
    /// 2. Focus the participant in the UI. The camera or screen feed
    ///    subscription may need to be created (e.g. participant was not visible
    ///    in the viewport before) or updated (e.g. display resolution changes
    ///    due to focus) by a corresponding `Subscribe` message sent to the SFU.
    public struct ForceFocus {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var participantID: UInt32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  /// Media keys a participant will use for sending.
  ///
  /// Will be sent towards new and existing participants as described by the
  /// _Join/Leave_ section.
  public struct MediaKey {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The current epoch reflecting the PCMK state.
    ///
    /// Initially, epoch is `0` and increases each time a participant leaves. The
    /// concrete mechanism is explained in the _Join/Leave_ section.
    public var epoch: UInt32 = 0

    /// The current ratchet counter reflecting the PCMK state.
    ///
    /// Initially (or when a participant leaves), the ratchet counter is `0` and
    /// increases each time a participant joins. The ratcheting mechanism is
    /// explained in the _Join/Leave_ section.
    public var ratchetCounter: UInt32 = 0

    /// The current state of the PCMK with the applied ratchet counter.
    ///
    /// Initially (or when a participant leaves), PCMK is a random 32 byte secret
    /// key. The concrete mechanism is explained in the _Join/Leave_ section.
    ///
    /// This key must be identical **towards** all participants.
    public var pcmk: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Signals a participant's device capturing state.
  ///
  /// When creating this message:
  ///
  /// 1. Let `device` be the device whose state is to be updated.
  /// 2. If `device` is to be turned _off_:
  ///    1. Stop capturing from the device.
  ///    2. Pause the corresponding media track.
  /// 3. If `device` is to be turned _on_:
  ///    1. Start capturing from the device.
  ///    2. Resume the corresponding media track.
  /// 4. Send the `CaptureState` message for the `device`.
  ///
  /// When receiving this message:
  ///
  /// 1. Let `device` be the device of the sender whose state has been updated.
  /// 2. If `device` was turned _off_ and the user is subscribed to the given
  ///    `device`'s feed:
  ///    1. Stop displaying the corresponding media feed in the UI.
  ///    2. Pause the corresponding media track.
  ///    3. If `device` is `Microphone`, no further action is necessary.
  ///    4. If `device` is `Camera`, send a `ParticipantCamera.Unsubcribe`
  ///       message to the SFU.
  ///    5. If `device` is `Screen`, send a `ParticipantScreen.Unsubcribe`
  ///       message to the SFU.
  /// 3. If `device` was turned _on_ and the user is not subscribed to the given
  ///    `device`'s feed:
  ///    1. Resume the corresponding media track.
  ///    2. Start displaying the corresponding media feed in the UI.
  ///    3. If `device` is `Microphone`, no further action is necessary.
  ///    4. If `device` is `Camera`, send a `ParticipantCamera.Subscribe` message
  ///       to the SFU.
  ///    5. If `device` is `Screen`, send a `ParticipantScreen.Subscribe` message
  ///       to the SFU.
  public struct CaptureState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var state: Groupcall_ParticipantToParticipant.CaptureState.OneOf_State? = nil

    public var microphone: Groupcall_ParticipantToParticipant.CaptureState.Microphone {
      get {
        if case .microphone(let v)? = state {return v}
        return Groupcall_ParticipantToParticipant.CaptureState.Microphone()
      }
      set {state = .microphone(newValue)}
    }

    public var camera: Groupcall_ParticipantToParticipant.CaptureState.Camera {
      get {
        if case .camera(let v)? = state {return v}
        return Groupcall_ParticipantToParticipant.CaptureState.Camera()
      }
      set {state = .camera(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_State: Equatable {
      case microphone(Groupcall_ParticipantToParticipant.CaptureState.Microphone)
      case camera(Groupcall_ParticipantToParticipant.CaptureState.Camera)

    #if !swift(>=4.1)
      public static func ==(lhs: Groupcall_ParticipantToParticipant.CaptureState.OneOf_State, rhs: Groupcall_ParticipantToParticipant.CaptureState.OneOf_State) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.microphone, .microphone): return {
          guard case .microphone(let l) = lhs, case .microphone(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.camera, .camera): return {
          guard case .camera(let l) = lhs, case .camera(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// Capture state of the microphone.
    public struct Microphone {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var state: Groupcall_ParticipantToParticipant.CaptureState.Microphone.OneOf_State? = nil

      public var on: Common_Unit {
        get {
          if case .on(let v)? = state {return v}
          return Common_Unit()
        }
        set {state = .on(newValue)}
      }

      public var off: Common_Unit {
        get {
          if case .off(let v)? = state {return v}
          return Common_Unit()
        }
        set {state = .off(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_State: Equatable {
        case on(Common_Unit)
        case off(Common_Unit)

      #if !swift(>=4.1)
        public static func ==(lhs: Groupcall_ParticipantToParticipant.CaptureState.Microphone.OneOf_State, rhs: Groupcall_ParticipantToParticipant.CaptureState.Microphone.OneOf_State) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.on, .on): return {
            guard case .on(let l) = lhs, case .on(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.off, .off): return {
            guard case .off(let l) = lhs, case .off(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public init() {}
    }

    /// Capture state of the camera.
    public struct Camera {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var state: Groupcall_ParticipantToParticipant.CaptureState.Camera.OneOf_State? = nil

      public var on: Common_Unit {
        get {
          if case .on(let v)? = state {return v}
          return Common_Unit()
        }
        set {state = .on(newValue)}
      }

      public var off: Common_Unit {
        get {
          if case .off(let v)? = state {return v}
          return Common_Unit()
        }
        set {state = .off(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_State: Equatable {
        case on(Common_Unit)
        case off(Common_Unit)

      #if !swift(>=4.1)
        public static func ==(lhs: Groupcall_ParticipantToParticipant.CaptureState.Camera.OneOf_State, rhs: Groupcall_ParticipantToParticipant.CaptureState.Camera.OneOf_State) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.on, .on): return {
            guard case .on(let l) = lhs, case .on(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.off, .off): return {
            guard case .off(let l) = lhs, case .off(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public init() {}
    }

    /// Capture state of the screen.
    public struct Screen {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var state: Groupcall_ParticipantToParticipant.CaptureState.Screen.OneOf_State? = nil

      public var on: Common_Unit {
        get {
          if case .on(let v)? = state {return v}
          return Common_Unit()
        }
        set {state = .on(newValue)}
      }

      public var off: Common_Unit {
        get {
          if case .off(let v)? = state {return v}
          return Common_Unit()
        }
        set {state = .off(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_State: Equatable {
        case on(Common_Unit)
        case off(Common_Unit)

      #if !swift(>=4.1)
        public static func ==(lhs: Groupcall_ParticipantToParticipant.CaptureState.Screen.OneOf_State, rhs: Groupcall_ParticipantToParticipant.CaptureState.Screen.OneOf_State) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.on, .on): return {
            guard case .on(let l) = lhs, case .on(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.off, .off): return {
            guard case .off(let l) = lhs, case .off(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public init() {}
    }

    public init() {}
  }

  /// Signals that a participant is currently on hold / temporarily away.
  ///
  /// When creating this message:
  ///
  /// 1. Send a `CaptureState` message for each capture device. Follow the
  ///    creation steps of that message.
  /// 2. Send the `HoldState` message.
  ///
  /// When receiving this message:
  ///
  /// 1. Apply the _hold_ state in the UI for the participant.
  /// 2. Pause any video-based media tracks of the participant.
  /// 3. If subscribed to the participant's camera feed, send a
  ///    `ParticipantCamera.Unsubcribe` message to the SFU.
  /// 4. If subscribed to the participant's screen feed, send a
  ///    `ParticipantScreen.Unsubcribe` message to the SFU.
  public struct HoldState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Groupcall_ParticipantToParticipant.Admin.ForceCaptureStateOff.Device: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Groupcall_ParticipantToParticipant.Admin.ForceCaptureStateOff.Device] = [
    .all,
    .microphone,
    .camera,
    .screen,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Groupcall_CallState: @unchecked Sendable {}
extension Groupcall_CallState.Participant: @unchecked Sendable {}
extension Groupcall_CallState.Participant.OneOf_Participant: @unchecked Sendable {}
extension Groupcall_CallState.Participant.Normal: @unchecked Sendable {}
extension Groupcall_CallState.Participant.Guest: @unchecked Sendable {}
extension Groupcall_SfuHttpRequest: @unchecked Sendable {}
extension Groupcall_SfuHttpRequest.Peek: @unchecked Sendable {}
extension Groupcall_SfuHttpRequest.Join: @unchecked Sendable {}
extension Groupcall_SfuHttpResponse: @unchecked Sendable {}
extension Groupcall_SfuHttpResponse.Peek: @unchecked Sendable {}
extension Groupcall_SfuHttpResponse.Join: @unchecked Sendable {}
extension Groupcall_SfuHttpResponse.Join.Address: @unchecked Sendable {}
extension Groupcall_SfuHttpResponse.Join.Address.ProtocolEnum: @unchecked Sendable {}
extension Groupcall_SfuToParticipant: @unchecked Sendable {}
extension Groupcall_SfuToParticipant.Envelope: @unchecked Sendable {}
extension Groupcall_SfuToParticipant.Envelope.OneOf_Content: @unchecked Sendable {}
extension Groupcall_SfuToParticipant.Hello: @unchecked Sendable {}
extension Groupcall_SfuToParticipant.ParticipantJoined: @unchecked Sendable {}
extension Groupcall_SfuToParticipant.ParticipantLeft: @unchecked Sendable {}
extension Groupcall_ParticipantToSfu: @unchecked Sendable {}
extension Groupcall_ParticipantToSfu.Envelope: @unchecked Sendable {}
extension Groupcall_ParticipantToSfu.Envelope.OneOf_Content: @unchecked Sendable {}
extension Groupcall_ParticipantToSfu.UpdateCallState: @unchecked Sendable {}
extension Groupcall_ParticipantToSfu.ParticipantMicrophone: @unchecked Sendable {}
extension Groupcall_ParticipantToSfu.ParticipantMicrophone.OneOf_Action: @unchecked Sendable {}
extension Groupcall_ParticipantToSfu.ParticipantMicrophone.Subscribe: @unchecked Sendable {}
extension Groupcall_ParticipantToSfu.ParticipantMicrophone.Unsubscribe: @unchecked Sendable {}
extension Groupcall_ParticipantToSfu.ParticipantCamera: @unchecked Sendable {}
extension Groupcall_ParticipantToSfu.ParticipantCamera.OneOf_Action: @unchecked Sendable {}
extension Groupcall_ParticipantToSfu.ParticipantCamera.Subscribe: @unchecked Sendable {}
extension Groupcall_ParticipantToSfu.ParticipantCamera.Unsubscribe: @unchecked Sendable {}
extension Groupcall_ParticipantToSfu.ParticipantScreen: @unchecked Sendable {}
extension Groupcall_ParticipantToSfu.ParticipantScreen.OneOf_Action: @unchecked Sendable {}
extension Groupcall_ParticipantToSfu.ParticipantScreen.Subscribe: @unchecked Sendable {}
extension Groupcall_ParticipantToSfu.ParticipantScreen.Unsubscribe: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.OuterEnvelope: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.Handshake: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.Handshake.HelloEnvelope: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.Handshake.HelloEnvelope.OneOf_Content: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.Handshake.AuthEnvelope: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.Handshake.AuthEnvelope.OneOf_Content: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.Handshake.Hello: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.Handshake.Auth: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.Handshake.GuestHello: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.Handshake.GuestAuth: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.Envelope: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.Envelope.OneOf_Content: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.Admin: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.Admin.Envelope: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.Admin.Envelope.OneOf_Content: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.Admin.ReportAsAdmin: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.Admin.PromoteToAdmin: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.Admin.ForceLeave: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.Admin.ForceCaptureStateOff: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.Admin.ForceCaptureStateOff.Device: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.Admin.ForceFocus: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.MediaKey: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.CaptureState: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.CaptureState.OneOf_State: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.CaptureState.Microphone: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.CaptureState.Microphone.OneOf_State: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.CaptureState.Camera: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.CaptureState.Camera.OneOf_State: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.CaptureState.Screen: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.CaptureState.Screen.OneOf_State: @unchecked Sendable {}
extension Groupcall_ParticipantToParticipant.HoldState: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "groupcall"

extension Groupcall_CallState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "padding"),
    2: .standard(proto: "state_created_by"),
    3: .standard(proto: "state_created_at"),
    4: .same(proto: "participants"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.padding) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.stateCreatedBy) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.stateCreatedAt) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Groupcall_CallState.Participant>.self, value: &self.participants) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.padding.isEmpty {
      try visitor.visitSingularBytesField(value: self.padding, fieldNumber: 1)
    }
    if self.stateCreatedBy != 0 {
      try visitor.visitSingularUInt32Field(value: self.stateCreatedBy, fieldNumber: 2)
    }
    if self.stateCreatedAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.stateCreatedAt, fieldNumber: 3)
    }
    if !self.participants.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Groupcall_CallState.Participant>.self, value: self.participants, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_CallState, rhs: Groupcall_CallState) -> Bool {
    if lhs.padding != rhs.padding {return false}
    if lhs.stateCreatedBy != rhs.stateCreatedBy {return false}
    if lhs.stateCreatedAt != rhs.stateCreatedAt {return false}
    if lhs.participants != rhs.participants {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_CallState.Participant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_CallState.protoMessageName + ".Participant"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "threema"),
    3: .same(proto: "guest"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Groupcall_CallState.Participant.Normal?
        var hadOneofValue = false
        if let current = self.participant {
          hadOneofValue = true
          if case .threema(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.participant = .threema(v)
        }
      }()
      case 3: try {
        var v: Groupcall_CallState.Participant.Guest?
        var hadOneofValue = false
        if let current = self.participant {
          hadOneofValue = true
          if case .guest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.participant = .guest(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.participant {
    case .threema?: try {
      guard case .threema(let v)? = self.participant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .guest?: try {
      guard case .guest(let v)? = self.participant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_CallState.Participant, rhs: Groupcall_CallState.Participant) -> Bool {
    if lhs.participant != rhs.participant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_CallState.Participant.Normal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_CallState.Participant.protoMessageName + ".Normal"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identity"),
    2: .same(proto: "nickname"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_CallState.Participant.Normal, rhs: Groupcall_CallState.Participant.Normal) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_CallState.Participant.Guest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_CallState.Participant.protoMessageName + ".Guest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_CallState.Participant.Guest, rhs: Groupcall_CallState.Participant.Guest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_SfuHttpRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SfuHttpRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_SfuHttpRequest, rhs: Groupcall_SfuHttpRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_SfuHttpRequest.Peek: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_SfuHttpRequest.protoMessageName + ".Peek"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.callID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularBytesField(value: self.callID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_SfuHttpRequest.Peek, rhs: Groupcall_SfuHttpRequest.Peek) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_SfuHttpRequest.Join: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_SfuHttpRequest.protoMessageName + ".Join"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "protocol_version"),
    3: .standard(proto: "dtls_fingerprint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.protocolVersion) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.dtlsFingerprint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularBytesField(value: self.callID, fieldNumber: 1)
    }
    if self.protocolVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.protocolVersion, fieldNumber: 2)
    }
    if !self.dtlsFingerprint.isEmpty {
      try visitor.visitSingularBytesField(value: self.dtlsFingerprint, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_SfuHttpRequest.Join, rhs: Groupcall_SfuHttpRequest.Join) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.protocolVersion != rhs.protocolVersion {return false}
    if lhs.dtlsFingerprint != rhs.dtlsFingerprint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_SfuHttpResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SfuHttpResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_SfuHttpResponse, rhs: Groupcall_SfuHttpResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_SfuHttpResponse.Peek: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_SfuHttpResponse.protoMessageName + ".Peek"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "started_at"),
    2: .standard(proto: "max_participants"),
    3: .standard(proto: "encrypted_call_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.startedAt) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.maxParticipants) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._encryptedCallState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.startedAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.startedAt, fieldNumber: 1)
    }
    if self.maxParticipants != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxParticipants, fieldNumber: 2)
    }
    try { if let v = self._encryptedCallState {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_SfuHttpResponse.Peek, rhs: Groupcall_SfuHttpResponse.Peek) -> Bool {
    if lhs.startedAt != rhs.startedAt {return false}
    if lhs.maxParticipants != rhs.maxParticipants {return false}
    if lhs._encryptedCallState != rhs._encryptedCallState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_SfuHttpResponse.Join: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_SfuHttpResponse.protoMessageName + ".Join"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "started_at"),
    2: .standard(proto: "max_participants"),
    3: .standard(proto: "participant_id"),
    4: .same(proto: "addresses"),
    5: .standard(proto: "ice_username_fragment"),
    6: .standard(proto: "ice_password"),
    7: .standard(proto: "dtls_fingerprint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.startedAt) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.maxParticipants) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.participantID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.addresses) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.iceUsernameFragment) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.icePassword) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.dtlsFingerprint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startedAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.startedAt, fieldNumber: 1)
    }
    if self.maxParticipants != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxParticipants, fieldNumber: 2)
    }
    if self.participantID != 0 {
      try visitor.visitSingularUInt32Field(value: self.participantID, fieldNumber: 3)
    }
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addresses, fieldNumber: 4)
    }
    if !self.iceUsernameFragment.isEmpty {
      try visitor.visitSingularStringField(value: self.iceUsernameFragment, fieldNumber: 5)
    }
    if !self.icePassword.isEmpty {
      try visitor.visitSingularStringField(value: self.icePassword, fieldNumber: 6)
    }
    if !self.dtlsFingerprint.isEmpty {
      try visitor.visitSingularBytesField(value: self.dtlsFingerprint, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_SfuHttpResponse.Join, rhs: Groupcall_SfuHttpResponse.Join) -> Bool {
    if lhs.startedAt != rhs.startedAt {return false}
    if lhs.maxParticipants != rhs.maxParticipants {return false}
    if lhs.participantID != rhs.participantID {return false}
    if lhs.addresses != rhs.addresses {return false}
    if lhs.iceUsernameFragment != rhs.iceUsernameFragment {return false}
    if lhs.icePassword != rhs.icePassword {return false}
    if lhs.dtlsFingerprint != rhs.dtlsFingerprint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_SfuHttpResponse.Join.Address: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_SfuHttpResponse.Join.protoMessageName + ".Address"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "protocol"),
    2: .same(proto: "port"),
    3: .same(proto: "ip"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.`protocol`) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.`protocol` != .udp {
      try visitor.visitSingularEnumField(value: self.`protocol`, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 2)
    }
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_SfuHttpResponse.Join.Address, rhs: Groupcall_SfuHttpResponse.Join.Address) -> Bool {
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.port != rhs.port {return false}
    if lhs.ip != rhs.ip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_SfuHttpResponse.Join.Address.ProtocolEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UDP"),
  ]
}

extension Groupcall_SfuToParticipant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SfuToParticipant"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_SfuToParticipant, rhs: Groupcall_SfuToParticipant) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_SfuToParticipant.Envelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_SfuToParticipant.protoMessageName + ".Envelope"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "padding"),
    2: .same(proto: "relay"),
    3: .same(proto: "hello"),
    4: .standard(proto: "participant_joined"),
    5: .standard(proto: "participant_left"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.padding) }()
      case 2: try {
        var v: Groupcall_ParticipantToParticipant.OuterEnvelope?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .relay(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .relay(v)
        }
      }()
      case 3: try {
        var v: Groupcall_SfuToParticipant.Hello?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .hello(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .hello(v)
        }
      }()
      case 4: try {
        var v: Groupcall_SfuToParticipant.ParticipantJoined?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .participantJoined(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .participantJoined(v)
        }
      }()
      case 5: try {
        var v: Groupcall_SfuToParticipant.ParticipantLeft?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .participantLeft(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .participantLeft(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.padding.isEmpty {
      try visitor.visitSingularBytesField(value: self.padding, fieldNumber: 1)
    }
    switch self.content {
    case .relay?: try {
      guard case .relay(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .hello?: try {
      guard case .hello(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .participantJoined?: try {
      guard case .participantJoined(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .participantLeft?: try {
      guard case .participantLeft(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_SfuToParticipant.Envelope, rhs: Groupcall_SfuToParticipant.Envelope) -> Bool {
    if lhs.padding != rhs.padding {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_SfuToParticipant.Hello: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_SfuToParticipant.protoMessageName + ".Hello"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "participant_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.participantIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.participantIds.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.participantIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_SfuToParticipant.Hello, rhs: Groupcall_SfuToParticipant.Hello) -> Bool {
    if lhs.participantIds != rhs.participantIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_SfuToParticipant.ParticipantJoined: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_SfuToParticipant.protoMessageName + ".ParticipantJoined"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "participant_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.participantID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.participantID != 0 {
      try visitor.visitSingularUInt32Field(value: self.participantID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_SfuToParticipant.ParticipantJoined, rhs: Groupcall_SfuToParticipant.ParticipantJoined) -> Bool {
    if lhs.participantID != rhs.participantID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_SfuToParticipant.ParticipantLeft: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_SfuToParticipant.protoMessageName + ".ParticipantLeft"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "participant_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.participantID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.participantID != 0 {
      try visitor.visitSingularUInt32Field(value: self.participantID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_SfuToParticipant.ParticipantLeft, rhs: Groupcall_SfuToParticipant.ParticipantLeft) -> Bool {
    if lhs.participantID != rhs.participantID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToSfu: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ParticipantToSfu"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToSfu, rhs: Groupcall_ParticipantToSfu) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToSfu.Envelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToSfu.protoMessageName + ".Envelope"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "padding"),
    2: .same(proto: "relay"),
    3: .standard(proto: "update_call_state"),
    6: .standard(proto: "request_participant_microphone"),
    4: .standard(proto: "request_participant_camera"),
    5: .standard(proto: "request_participant_screen_share"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.padding) }()
      case 2: try {
        var v: Groupcall_ParticipantToParticipant.OuterEnvelope?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .relay(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .relay(v)
        }
      }()
      case 3: try {
        var v: Groupcall_ParticipantToSfu.UpdateCallState?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .updateCallState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .updateCallState(v)
        }
      }()
      case 4: try {
        var v: Groupcall_ParticipantToSfu.ParticipantCamera?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .requestParticipantCamera(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .requestParticipantCamera(v)
        }
      }()
      case 5: try {
        var v: Groupcall_ParticipantToSfu.ParticipantScreen?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .requestParticipantScreenShare(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .requestParticipantScreenShare(v)
        }
      }()
      case 6: try {
        var v: Groupcall_ParticipantToSfu.ParticipantMicrophone?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .requestParticipantMicrophone(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .requestParticipantMicrophone(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.padding.isEmpty {
      try visitor.visitSingularBytesField(value: self.padding, fieldNumber: 1)
    }
    switch self.content {
    case .relay?: try {
      guard case .relay(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .updateCallState?: try {
      guard case .updateCallState(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .requestParticipantCamera?: try {
      guard case .requestParticipantCamera(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .requestParticipantScreenShare?: try {
      guard case .requestParticipantScreenShare(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .requestParticipantMicrophone?: try {
      guard case .requestParticipantMicrophone(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToSfu.Envelope, rhs: Groupcall_ParticipantToSfu.Envelope) -> Bool {
    if lhs.padding != rhs.padding {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToSfu.UpdateCallState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToSfu.protoMessageName + ".UpdateCallState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "encrypted_call_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.encryptedCallState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.encryptedCallState.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedCallState, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToSfu.UpdateCallState, rhs: Groupcall_ParticipantToSfu.UpdateCallState) -> Bool {
    if lhs.encryptedCallState != rhs.encryptedCallState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToSfu.ParticipantMicrophone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToSfu.protoMessageName + ".ParticipantMicrophone"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "participant_id"),
    2: .same(proto: "subscribe"),
    3: .same(proto: "unsubscribe"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.participantID) }()
      case 2: try {
        var v: Groupcall_ParticipantToSfu.ParticipantMicrophone.Subscribe?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .subscribe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .subscribe(v)
        }
      }()
      case 3: try {
        var v: Groupcall_ParticipantToSfu.ParticipantMicrophone.Unsubscribe?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .unsubscribe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .unsubscribe(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.participantID != 0 {
      try visitor.visitSingularUInt32Field(value: self.participantID, fieldNumber: 1)
    }
    switch self.action {
    case .subscribe?: try {
      guard case .subscribe(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .unsubscribe?: try {
      guard case .unsubscribe(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToSfu.ParticipantMicrophone, rhs: Groupcall_ParticipantToSfu.ParticipantMicrophone) -> Bool {
    if lhs.participantID != rhs.participantID {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToSfu.ParticipantMicrophone.Subscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToSfu.ParticipantMicrophone.protoMessageName + ".Subscribe"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToSfu.ParticipantMicrophone.Subscribe, rhs: Groupcall_ParticipantToSfu.ParticipantMicrophone.Subscribe) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToSfu.ParticipantMicrophone.Unsubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToSfu.ParticipantMicrophone.protoMessageName + ".Unsubscribe"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToSfu.ParticipantMicrophone.Unsubscribe, rhs: Groupcall_ParticipantToSfu.ParticipantMicrophone.Unsubscribe) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToSfu.ParticipantCamera: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToSfu.protoMessageName + ".ParticipantCamera"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "participant_id"),
    2: .same(proto: "subscribe"),
    3: .same(proto: "unsubscribe"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.participantID) }()
      case 2: try {
        var v: Groupcall_ParticipantToSfu.ParticipantCamera.Subscribe?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .subscribe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .subscribe(v)
        }
      }()
      case 3: try {
        var v: Groupcall_ParticipantToSfu.ParticipantCamera.Unsubscribe?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .unsubscribe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .unsubscribe(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.participantID != 0 {
      try visitor.visitSingularUInt32Field(value: self.participantID, fieldNumber: 1)
    }
    switch self.action {
    case .subscribe?: try {
      guard case .subscribe(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .unsubscribe?: try {
      guard case .unsubscribe(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToSfu.ParticipantCamera, rhs: Groupcall_ParticipantToSfu.ParticipantCamera) -> Bool {
    if lhs.participantID != rhs.participantID {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToSfu.ParticipantCamera.Subscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToSfu.ParticipantCamera.protoMessageName + ".Subscribe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "desired_resolution"),
    2: .standard(proto: "desired_fps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._desiredResolution) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.desiredFps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._desiredResolution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.desiredFps != 0 {
      try visitor.visitSingularUInt32Field(value: self.desiredFps, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToSfu.ParticipantCamera.Subscribe, rhs: Groupcall_ParticipantToSfu.ParticipantCamera.Subscribe) -> Bool {
    if lhs._desiredResolution != rhs._desiredResolution {return false}
    if lhs.desiredFps != rhs.desiredFps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToSfu.ParticipantCamera.Unsubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToSfu.ParticipantCamera.protoMessageName + ".Unsubscribe"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToSfu.ParticipantCamera.Unsubscribe, rhs: Groupcall_ParticipantToSfu.ParticipantCamera.Unsubscribe) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToSfu.ParticipantScreen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToSfu.protoMessageName + ".ParticipantScreen"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "participant_id"),
    2: .same(proto: "subscribe"),
    3: .same(proto: "unsubscribe"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.participantID) }()
      case 2: try {
        var v: Groupcall_ParticipantToSfu.ParticipantScreen.Subscribe?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .subscribe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .subscribe(v)
        }
      }()
      case 3: try {
        var v: Groupcall_ParticipantToSfu.ParticipantScreen.Unsubscribe?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .unsubscribe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .unsubscribe(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.participantID != 0 {
      try visitor.visitSingularUInt32Field(value: self.participantID, fieldNumber: 1)
    }
    switch self.action {
    case .subscribe?: try {
      guard case .subscribe(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .unsubscribe?: try {
      guard case .unsubscribe(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToSfu.ParticipantScreen, rhs: Groupcall_ParticipantToSfu.ParticipantScreen) -> Bool {
    if lhs.participantID != rhs.participantID {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToSfu.ParticipantScreen.Subscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToSfu.ParticipantScreen.protoMessageName + ".Subscribe"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToSfu.ParticipantScreen.Subscribe, rhs: Groupcall_ParticipantToSfu.ParticipantScreen.Subscribe) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToSfu.ParticipantScreen.Unsubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToSfu.ParticipantScreen.protoMessageName + ".Unsubscribe"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToSfu.ParticipantScreen.Unsubscribe, rhs: Groupcall_ParticipantToSfu.ParticipantScreen.Unsubscribe) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ParticipantToParticipant"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant, rhs: Groupcall_ParticipantToParticipant) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.OuterEnvelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.protoMessageName + ".OuterEnvelope"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "receiver"),
    4: .standard(proto: "encrypted_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.receiver) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.encryptedData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sender != 0 {
      try visitor.visitSingularUInt32Field(value: self.sender, fieldNumber: 1)
    }
    if self.receiver != 0 {
      try visitor.visitSingularUInt32Field(value: self.receiver, fieldNumber: 2)
    }
    if !self.encryptedData.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedData, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.OuterEnvelope, rhs: Groupcall_ParticipantToParticipant.OuterEnvelope) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.receiver != rhs.receiver {return false}
    if lhs.encryptedData != rhs.encryptedData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.Handshake: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.protoMessageName + ".Handshake"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.Handshake, rhs: Groupcall_ParticipantToParticipant.Handshake) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.Handshake.HelloEnvelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.Handshake.protoMessageName + ".HelloEnvelope"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "padding"),
    2: .same(proto: "hello"),
    3: .standard(proto: "guest_hello"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.padding) }()
      case 2: try {
        var v: Groupcall_ParticipantToParticipant.Handshake.Hello?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .hello(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .hello(v)
        }
      }()
      case 3: try {
        var v: Groupcall_ParticipantToParticipant.Handshake.GuestHello?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .guestHello(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .guestHello(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.padding.isEmpty {
      try visitor.visitSingularBytesField(value: self.padding, fieldNumber: 1)
    }
    switch self.content {
    case .hello?: try {
      guard case .hello(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .guestHello?: try {
      guard case .guestHello(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.Handshake.HelloEnvelope, rhs: Groupcall_ParticipantToParticipant.Handshake.HelloEnvelope) -> Bool {
    if lhs.padding != rhs.padding {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.Handshake.AuthEnvelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.Handshake.protoMessageName + ".AuthEnvelope"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "padding"),
    2: .same(proto: "auth"),
    3: .standard(proto: "guest_auth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.padding) }()
      case 2: try {
        var v: Groupcall_ParticipantToParticipant.Handshake.Auth?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .auth(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .auth(v)
        }
      }()
      case 3: try {
        var v: Groupcall_ParticipantToParticipant.Handshake.GuestAuth?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .guestAuth(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .guestAuth(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.padding.isEmpty {
      try visitor.visitSingularBytesField(value: self.padding, fieldNumber: 1)
    }
    switch self.content {
    case .auth?: try {
      guard case .auth(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .guestAuth?: try {
      guard case .guestAuth(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.Handshake.AuthEnvelope, rhs: Groupcall_ParticipantToParticipant.Handshake.AuthEnvelope) -> Bool {
    if lhs.padding != rhs.padding {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.Handshake.Hello: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.Handshake.protoMessageName + ".Hello"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identity"),
    2: .same(proto: "nickname"),
    3: .same(proto: "pck"),
    4: .same(proto: "pcck"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.pck) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.pcck) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 2)
    }
    if !self.pck.isEmpty {
      try visitor.visitSingularBytesField(value: self.pck, fieldNumber: 3)
    }
    if !self.pcck.isEmpty {
      try visitor.visitSingularBytesField(value: self.pcck, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.Handshake.Hello, rhs: Groupcall_ParticipantToParticipant.Handshake.Hello) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.pck != rhs.pck {return false}
    if lhs.pcck != rhs.pcck {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.Handshake.Auth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.Handshake.protoMessageName + ".Auth"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pck"),
    2: .same(proto: "pcck"),
    3: .standard(proto: "media_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.pck) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.pcck) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mediaKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pck.isEmpty {
      try visitor.visitSingularBytesField(value: self.pck, fieldNumber: 1)
    }
    if !self.pcck.isEmpty {
      try visitor.visitSingularBytesField(value: self.pcck, fieldNumber: 2)
    }
    if !self.mediaKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mediaKeys, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.Handshake.Auth, rhs: Groupcall_ParticipantToParticipant.Handshake.Auth) -> Bool {
    if lhs.pck != rhs.pck {return false}
    if lhs.pcck != rhs.pcck {return false}
    if lhs.mediaKeys != rhs.mediaKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.Handshake.GuestHello: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.Handshake.protoMessageName + ".GuestHello"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "pck"),
    3: .same(proto: "pcck"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.pck) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.pcck) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.pck.isEmpty {
      try visitor.visitSingularBytesField(value: self.pck, fieldNumber: 2)
    }
    if !self.pcck.isEmpty {
      try visitor.visitSingularBytesField(value: self.pcck, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.Handshake.GuestHello, rhs: Groupcall_ParticipantToParticipant.Handshake.GuestHello) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.pck != rhs.pck {return false}
    if lhs.pcck != rhs.pcck {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.Handshake.GuestAuth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.Handshake.protoMessageName + ".GuestAuth"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pck"),
    2: .same(proto: "pcck"),
    3: .standard(proto: "media_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.pck) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.pcck) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mediaKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pck.isEmpty {
      try visitor.visitSingularBytesField(value: self.pck, fieldNumber: 1)
    }
    if !self.pcck.isEmpty {
      try visitor.visitSingularBytesField(value: self.pcck, fieldNumber: 2)
    }
    if !self.mediaKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mediaKeys, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.Handshake.GuestAuth, rhs: Groupcall_ParticipantToParticipant.Handshake.GuestAuth) -> Bool {
    if lhs.pck != rhs.pck {return false}
    if lhs.pcck != rhs.pcck {return false}
    if lhs.mediaKeys != rhs.mediaKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.Envelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.protoMessageName + ".Envelope"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "padding"),
    2: .standard(proto: "encrypted_admin_envelope"),
    3: .same(proto: "rekey"),
    4: .standard(proto: "capture_state"),
    5: .standard(proto: "hold_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.padding) }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .encryptedAdminEnvelope(v)
        }
      }()
      case 3: try {
        var v: Groupcall_ParticipantToParticipant.MediaKey?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .rekey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .rekey(v)
        }
      }()
      case 4: try {
        var v: Groupcall_ParticipantToParticipant.CaptureState?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .captureState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .captureState(v)
        }
      }()
      case 5: try {
        var v: Groupcall_ParticipantToParticipant.HoldState?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .holdState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .holdState(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.padding.isEmpty {
      try visitor.visitSingularBytesField(value: self.padding, fieldNumber: 1)
    }
    switch self.content {
    case .encryptedAdminEnvelope?: try {
      guard case .encryptedAdminEnvelope(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .rekey?: try {
      guard case .rekey(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .captureState?: try {
      guard case .captureState(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .holdState?: try {
      guard case .holdState(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.Envelope, rhs: Groupcall_ParticipantToParticipant.Envelope) -> Bool {
    if lhs.padding != rhs.padding {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.Admin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.protoMessageName + ".Admin"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.Admin, rhs: Groupcall_ParticipantToParticipant.Admin) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.Admin.Envelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.Admin.protoMessageName + ".Envelope"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "report_as_admin"),
    2: .standard(proto: "promote_to_admin"),
    3: .standard(proto: "force_leave"),
    4: .standard(proto: "force_capture_state_off"),
    5: .standard(proto: "force_focus"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Groupcall_ParticipantToParticipant.Admin.ReportAsAdmin?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .reportAsAdmin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .reportAsAdmin(v)
        }
      }()
      case 2: try {
        var v: Groupcall_ParticipantToParticipant.Admin.PromoteToAdmin?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .promoteToAdmin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .promoteToAdmin(v)
        }
      }()
      case 3: try {
        var v: Groupcall_ParticipantToParticipant.Admin.ForceLeave?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .forceLeave(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .forceLeave(v)
        }
      }()
      case 4: try {
        var v: Groupcall_ParticipantToParticipant.Admin.ForceCaptureStateOff?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .forceCaptureStateOff(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .forceCaptureStateOff(v)
        }
      }()
      case 5: try {
        var v: Groupcall_ParticipantToParticipant.Admin.ForceFocus?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .forceFocus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .forceFocus(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .reportAsAdmin?: try {
      guard case .reportAsAdmin(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .promoteToAdmin?: try {
      guard case .promoteToAdmin(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .forceLeave?: try {
      guard case .forceLeave(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .forceCaptureStateOff?: try {
      guard case .forceCaptureStateOff(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .forceFocus?: try {
      guard case .forceFocus(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.Admin.Envelope, rhs: Groupcall_ParticipantToParticipant.Admin.Envelope) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.Admin.ReportAsAdmin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.Admin.protoMessageName + ".ReportAsAdmin"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.Admin.ReportAsAdmin, rhs: Groupcall_ParticipantToParticipant.Admin.ReportAsAdmin) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.Admin.PromoteToAdmin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.Admin.protoMessageName + ".PromoteToAdmin"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gcak"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.gcak) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gcak.isEmpty {
      try visitor.visitSingularBytesField(value: self.gcak, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.Admin.PromoteToAdmin, rhs: Groupcall_ParticipantToParticipant.Admin.PromoteToAdmin) -> Bool {
    if lhs.gcak != rhs.gcak {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.Admin.ForceLeave: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.Admin.protoMessageName + ".ForceLeave"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.Admin.ForceLeave, rhs: Groupcall_ParticipantToParticipant.Admin.ForceLeave) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.Admin.ForceCaptureStateOff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.Admin.protoMessageName + ".ForceCaptureStateOff"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.device) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.device != .all {
      try visitor.visitSingularEnumField(value: self.device, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.Admin.ForceCaptureStateOff, rhs: Groupcall_ParticipantToParticipant.Admin.ForceCaptureStateOff) -> Bool {
    if lhs.device != rhs.device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.Admin.ForceCaptureStateOff.Device: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL"),
    1: .same(proto: "MICROPHONE"),
    2: .same(proto: "CAMERA"),
    3: .same(proto: "SCREEN"),
  ]
}

extension Groupcall_ParticipantToParticipant.Admin.ForceFocus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.Admin.protoMessageName + ".ForceFocus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "participant_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.participantID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.participantID != 0 {
      try visitor.visitSingularUInt32Field(value: self.participantID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.Admin.ForceFocus, rhs: Groupcall_ParticipantToParticipant.Admin.ForceFocus) -> Bool {
    if lhs.participantID != rhs.participantID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.MediaKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.protoMessageName + ".MediaKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "epoch"),
    2: .standard(proto: "ratchet_counter"),
    3: .same(proto: "pcmk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.epoch) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.ratchetCounter) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.pcmk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.epoch != 0 {
      try visitor.visitSingularUInt32Field(value: self.epoch, fieldNumber: 1)
    }
    if self.ratchetCounter != 0 {
      try visitor.visitSingularUInt32Field(value: self.ratchetCounter, fieldNumber: 2)
    }
    if !self.pcmk.isEmpty {
      try visitor.visitSingularBytesField(value: self.pcmk, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.MediaKey, rhs: Groupcall_ParticipantToParticipant.MediaKey) -> Bool {
    if lhs.epoch != rhs.epoch {return false}
    if lhs.ratchetCounter != rhs.ratchetCounter {return false}
    if lhs.pcmk != rhs.pcmk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.CaptureState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.protoMessageName + ".CaptureState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "microphone"),
    2: .same(proto: "camera"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Groupcall_ParticipantToParticipant.CaptureState.Microphone?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .microphone(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .microphone(v)
        }
      }()
      case 2: try {
        var v: Groupcall_ParticipantToParticipant.CaptureState.Camera?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .camera(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .camera(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.state {
    case .microphone?: try {
      guard case .microphone(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .camera?: try {
      guard case .camera(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.CaptureState, rhs: Groupcall_ParticipantToParticipant.CaptureState) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.CaptureState.Microphone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.CaptureState.protoMessageName + ".Microphone"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "on"),
    2: .same(proto: "off"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .on(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .on(v)
        }
      }()
      case 2: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .off(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .off(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.state {
    case .on?: try {
      guard case .on(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .off?: try {
      guard case .off(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.CaptureState.Microphone, rhs: Groupcall_ParticipantToParticipant.CaptureState.Microphone) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.CaptureState.Camera: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.CaptureState.protoMessageName + ".Camera"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "on"),
    2: .same(proto: "off"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .on(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .on(v)
        }
      }()
      case 2: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .off(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .off(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.state {
    case .on?: try {
      guard case .on(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .off?: try {
      guard case .off(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.CaptureState.Camera, rhs: Groupcall_ParticipantToParticipant.CaptureState.Camera) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.CaptureState.Screen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.CaptureState.protoMessageName + ".Screen"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "on"),
    2: .same(proto: "off"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .on(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .on(v)
        }
      }()
      case 2: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .off(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .off(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.state {
    case .on?: try {
      guard case .on(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .off?: try {
      guard case .off(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.CaptureState.Screen, rhs: Groupcall_ParticipantToParticipant.CaptureState.Screen) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Groupcall_ParticipantToParticipant.HoldState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Groupcall_ParticipantToParticipant.protoMessageName + ".HoldState"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Groupcall_ParticipantToParticipant.HoldState, rhs: Groupcall_ParticipantToParticipant.HoldState) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
