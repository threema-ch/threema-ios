// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: md-d2d-join.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// ## Device Join Protocol
//
// This protocol specifies how to add a new device to an existing device group.
//
// ### Terminology
//
// - `ED`: Existing device
// - `ND`: New device to be added
//
// ### Blobs
//
// For binary data, the usual Blob scheme is being used by ED. However, instead
// of transferring Blob data via the Blob server, the data is transmitted in
// form of a `common.BlobData` message ahead of a message referencing that Blob
// by the associated Blob ID.
//
// ND is supposed to cache received `common.BlobData` until it can associate the
// data to a Blob referencing its ID. Once the rendezvous connection has been
// closed, any remaining cached `common.BlobData` can be discarded.
//
// ### Protocol Kickoff Flow
//
// ND or ED may choose to start the protocol. If ND starts the protocol it is
// _requesting to join the device group_. If ED starts the protocol it is
// _offering to join the device group_.
//
// If ED started the protocol:
//
// - `variant` must be set to _offer to join the device group_.
// - ED takes the role of RID
// - ND takes the role of RRD
//
// If ND started the protocol:
//
// - `variant` must be set to _request to join the device group_.
// - ND takes the role of RID
// - ED takes the role of RRD
//
// #### Connection Setup
//
// RID creates a `rendezvous.RendezvousInit` by following the Connection
// Rendezvous Protocol. It wraps it in a `url.DeviceGroupJoinRequestOrOffer` and
// offers it in form of a URL or a QR code.
//
// RRD scans the QR code or decodes the URL and then parses the
// `url.DeviceGroupJoinRequestOrOffer`. It will then receive the data over a
// sufficiently secure channel (e.g. a QR code). Once decoded, the enclosed
// `rendezvous.RendezvousInit` must be handled according to the Connection
// Rendezvous Protocol.
//
// Once the Connection Rendezvous Protocol has established at least one
// connection path, ED waits another 3s or until all connection paths have been
// established. Nomination is then done by ED following the Connection
// Rendezvous Protocol.
//
// Note that all messages on the nominated connection path must be end-to-end
// encrypted as defined by the Connection Rendezvous Protocol. All transmitted
// messages are to be wrapped in:
//
// - `NdToEd` when sending from ND to ED, and
// - `EdToNd` when sending from ED to ND.
//
// #### Device Join Flow
//
// As soon as one of the connection paths has been nominated by ED, both devices
// must calculate the Rendezvous Path Hash (RPH) as defined by the Rendezvous
// Protocol and display it to the user.
//
// ED must ask the user for confirmation that RPH is equal on both devices. The
// exact comparison mechanism is an implementation detail. If the user does not
// confirm that RPH is equal on both devices, the process must be aborted.
//
// After confirmation, ED must stop displaying RPH and send a `Begin` message to
// start the device join process.
//
//     ED ------- Begin ------> ND   [1]
//
// ND can now stop displaying RPH.
//
//     ED -- common.BlobData -> ND   [0..N]
//     ED --- EssentialData --> ND   [1]
//
// Once ND successfully registered itself on the Mediator server, it sends a
// `Registered` message.
//
//     ED <---- Registered ---- ND   [1]
//
// ND may now either close the connection or leave it open to transition to the
// History Exchange Protocol. Any further messages ED receives from ND will
// transition into the History Exchange Protocol.
//
// ### Security
//
// The `url.DeviceGroupJoinRequestOrOffer` must be exchanged over a sufficiently
// secure channel. A QR code is considered sufficiently secure in a _safe
// space_. If this can be ensured by the user, ensuring that the Rendezvous Path
// Hash (RPH) is equal on both devices is not strictly necessary.
//
// If an attacker is however able to capture the
// `url.DeviceGroupJoinRequestOrOffer`, the security of the protocol relies on
// the user ensuring that RPH is equal on both devices to ensure authentication
// and mitigate the following attacks:
//
// - If ED started the protocol (offers to join the device group), comparing RPH
//   is critical as otherwise the Client Key would become compromised if an
//   attacker were able to make a connection faster than the victim's other
//   device.
// - If ND started the protocol (requests to join the device group), comparing
//   RPH is not as critical yet still vital to mitigate a more sophisticated
//   attack where the attacker makes it look as if the victim is connected to
//   its device group. Until the victim finds out that it isn't its device group
//   (because the process is stuck on ED), the victim may potentially leak
//   sensitive information by adding a contact or sending a message, etc.
// - An attacker who also controls the relay server used for connection between
//   the victim's two devices could run a full MITM attack. Comparing RPH here
//   is critical to ensure that the victim's two devices have established an
//   end-to-end encrypted communication channel between each other.
//
// Letting ND start the protocol is considered more secure because of the above
// implications.
//
// ED is always required to let the user confirm the equality of RPH on both
// devices because it is ED who is to transmit the highly sensitive information.
//
// To prevent phishing attacks of a malicious web app claiming to be a Threema
// App (typo squatting), the CORS `Access-Control-Allow-Origin` of any WebSocket
// rendezvous relay server must be set to the bare minimum required by the use
// case, so that a connection cannot be established. However, phishing
// protection against a malicious non-web app claiming to be a Threema App is
// not possible.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Root message envelope for messages from the new device (ND) to the existing
/// device (ED).
public struct Join_NdToEd {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The enveloped message
  public var content: Join_NdToEd.OneOf_Content? = nil

  public var registered: Join_Registered {
    get {
      if case .registered(let v)? = content {return v}
      return Join_Registered()
    }
    set {content = .registered(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The enveloped message
  public enum OneOf_Content: Equatable {
    case registered(Join_Registered)

  #if !swift(>=4.1)
    public static func ==(lhs: Join_NdToEd.OneOf_Content, rhs: Join_NdToEd.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.registered, .registered): return {
        guard case .registered(let l) = lhs, case .registered(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Root message envelope for messages from the existing device (ED) to the new
/// device (ND).
public struct Join_EdToNd {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The enveloped message
  public var content: Join_EdToNd.OneOf_Content? = nil

  public var begin: Join_Begin {
    get {
      if case .begin(let v)? = content {return v}
      return Join_Begin()
    }
    set {content = .begin(newValue)}
  }

  /// A Blob that is referenced as part of `EssentialData`.
  ///
  /// When receiving this variant:
  ///
  /// 1. If `EssentialData` has been received before, close the connection and
  ///    abort these steps.
  /// 2. Store the Blob data temporarily or permanently and store its
  ///    associated Blob ID in the device's database.
  public var blobData: Common_BlobData {
    get {
      if case .blobData(let v)? = content {return v}
      return Common_BlobData()
    }
    set {content = .blobData(newValue)}
  }

  public var essentialData: Join_EssentialData {
    get {
      if case .essentialData(let v)? = content {return v}
      return Join_EssentialData()
    }
    set {content = .essentialData(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The enveloped message
  public enum OneOf_Content: Equatable {
    case begin(Join_Begin)
    /// A Blob that is referenced as part of `EssentialData`.
    ///
    /// When receiving this variant:
    ///
    /// 1. If `EssentialData` has been received before, close the connection and
    ///    abort these steps.
    /// 2. Store the Blob data temporarily or permanently and store its
    ///    associated Blob ID in the device's database.
    case blobData(Common_BlobData)
    case essentialData(Join_EssentialData)

  #if !swift(>=4.1)
    public static func ==(lhs: Join_EdToNd.OneOf_Content, rhs: Join_EdToNd.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.begin, .begin): return {
        guard case .begin(let l) = lhs, case .begin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.blobData, .blobData): return {
        guard case .blobData(let l) = lhs, case .blobData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.essentialData, .essentialData): return {
        guard case .essentialData(let l) = lhs, case .essentialData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Initial message sent by ED after nomination and user confirmation that RPH is
/// identical on both devices.
///
/// When creating this message, after confirmation by the user:
///
/// 1. Stop displaying RPH and notify the user that the device join process is in
///    progress.
/// 2. Begin a transaction (scope `NEW_DEVICE_SYNC`, precondition: none) on the
///    D2M connection. This transaction is to be held until the connection to ND
///    drops or until a `Registered` message was received. While the transaction
///    is being held, no `Reflected` and no end-to-end encrypted message coming
///    from the chat server is allowed to be processed! If the D2M connection is
///    lost, the established connection must also be closed, aborting any running
///    steps of this protocol.
/// 3. Send the `Begin` message and continue with the steps for creating
///    `EssentialData`.
///
/// When receiving this message:
///
/// 1. If `Begin` has been received before, close the connection and abort these
///    steps.
/// 2. Stop displaying RPH and notify the user that the device join process is in
///    progress.
public struct Join_Begin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Essential data ND needs to be able to participate in the device group.
///
/// Note: The transmitted used nonces are hashed with HMAC-SHA256 using the
/// identity as _key_.
///
/// When creating this message:
///
/// 1. Gather all blobs referenced for the user's profile picture, contact
///    profile pictures, etc. and send them as `common.BlobData` before this
///    message.
/// 2. Send the gathered `EssentialData`.
///
/// When receiving this message:
///
/// 1. If `EssentialData` has been received before, close the connection and
///    abort these steps.
/// 2. If any Blob ID is missing from the previously received set of
///    `common.BlobData`, close the connection and abort these steps.
/// 3. Store the data in the device's database.
/// 4. Generate a random D2M Device ID and a random CSP Device ID and store both
///    in the device's database.
/// 5. Establish a D2M connection by connecting to the provided mediator server.
/// 6. Wait until the `ServerInfo` has been received on the D2M connection.
///    Validate that the provided `DeviceSlotState` is `NEW`. Otherwise, close
///    both the D2M connection (normally) and the connection to ED and abort
///    these steps.
/// 7. Send a `Registered` message to ED.
/// 8. Ask the user whether conversation history data should be requested from
///    ND:
///    1. If the user does not want to request conversation history data, wait
///       until all buffered data on the connection has been written. Then, close
///       the connection and abort these steps.
///    2. If the user wants to request conversation history data from ED, leave
///       the connection running and start the History Exchange Protocol.
public struct Join_EssentialData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identityData: Join_EssentialData.IdentityData {
    get {return _storage._identityData ?? Join_EssentialData.IdentityData()}
    set {_uniqueStorage()._identityData = newValue}
  }
  /// Returns true if `identityData` has been explicitly set.
  public var hasIdentityData: Bool {return _storage._identityData != nil}
  /// Clears the value of `identityData`. Subsequent reads from it will return its default value.
  public mutating func clearIdentityData() {_uniqueStorage()._identityData = nil}

  /// Threema Work credentials
  ///
  /// Required for a Threema Work app. Must not be present in a Threema consumer app.
  public var workCredentials: Sync_ThreemaWorkCredentials {
    get {return _storage._workCredentials ?? Sync_ThreemaWorkCredentials()}
    set {_uniqueStorage()._workCredentials = newValue}
  }
  /// Returns true if `workCredentials` has been explicitly set.
  public var hasWorkCredentials: Bool {return _storage._workCredentials != nil}
  /// Clears the value of `workCredentials`. Subsequent reads from it will return its default value.
  public mutating func clearWorkCredentials() {_uniqueStorage()._workCredentials = nil}

  public var deviceGroupData: Join_EssentialData.DeviceGroupData {
    get {return _storage._deviceGroupData ?? Join_EssentialData.DeviceGroupData()}
    set {_uniqueStorage()._deviceGroupData = newValue}
  }
  /// Returns true if `deviceGroupData` has been explicitly set.
  public var hasDeviceGroupData: Bool {return _storage._deviceGroupData != nil}
  /// Clears the value of `deviceGroupData`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceGroupData() {_uniqueStorage()._deviceGroupData = nil}

  /// User's profile
  public var userProfile: Sync_UserProfile {
    get {return _storage._userProfile ?? Sync_UserProfile()}
    set {_uniqueStorage()._userProfile = newValue}
  }
  /// Returns true if `userProfile` has been explicitly set.
  public var hasUserProfile: Bool {return _storage._userProfile != nil}
  /// Clears the value of `userProfile`. Subsequent reads from it will return its default value.
  public mutating func clearUserProfile() {_uniqueStorage()._userProfile = nil}

  /// Shared settings
  public var settings: Sync_Settings {
    get {return _storage._settings ?? Sync_Settings()}
    set {_uniqueStorage()._settings = newValue}
  }
  /// Returns true if `settings` has been explicitly set.
  public var hasSettings: Bool {return _storage._settings != nil}
  /// Clears the value of `settings`. Subsequent reads from it will return its default value.
  public mutating func clearSettings() {_uniqueStorage()._settings = nil}

  /// MDM parameters
  public var mdmParameters: Sync_MdmParameters {
    get {return _storage._mdmParameters ?? Sync_MdmParameters()}
    set {_uniqueStorage()._mdmParameters = newValue}
  }
  /// Returns true if `mdmParameters` has been explicitly set.
  public var hasMdmParameters: Bool {return _storage._mdmParameters != nil}
  /// Clears the value of `mdmParameters`. Subsequent reads from it will return its default value.
  public mutating func clearMdmParameters() {_uniqueStorage()._mdmParameters = nil}

  public var contacts: [Join_EssentialData.AugmentedContact] {
    get {return _storage._contacts}
    set {_uniqueStorage()._contacts = newValue}
  }

  public var groups: [Join_EssentialData.AugmentedGroup] {
    get {return _storage._groups}
    set {_uniqueStorage()._groups = newValue}
  }

  public var distributionLists: [Join_EssentialData.AugmentedDistributionList] {
    get {return _storage._distributionLists}
    set {_uniqueStorage()._distributionLists = newValue}
  }

  /// Hashed nonces that were used for CSP messages.
  public var cspHashedNonces: [Data] {
    get {return _storage._cspHashedNonces}
    set {_uniqueStorage()._cspHashedNonces = newValue}
  }

  /// Hashed nonces thate were used for D2D messages.
  public var d2DHashedNonces: [Data] {
    get {return _storage._d2DHashedNonces}
    set {_uniqueStorage()._d2DHashedNonces = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// User's identity data
  public struct IdentityData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The user's Threema ID
    public var identity: String = String()

    /// The permanent client key associated to the Threema ID (32 bytes)
    public var ck: Data = Data()

    /// The device cookie used by the device group for the Threema ID (16 bytes)
    public var cspDeviceCookie: Data = Data()

    /// The CSP server group associated to the Threema ID (1 byte)
    public var cspServerGroup: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Device group data
  public struct DeviceGroupData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The device group key (32 bytes)
    public var dgk: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Contacts
  public struct AugmentedContact {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The contact's data.
    public var contact: Sync_Contact {
      get {return _contact ?? Sync_Contact()}
      set {_contact = newValue}
    }
    /// Returns true if `contact` has been explicitly set.
    public var hasContact: Bool {return self._contact != nil}
    /// Clears the value of `contact`. Subsequent reads from it will return its default value.
    public mutating func clearContact() {self._contact = nil}

    /// Unix-ish timestamp in milliseconds when the conversation with this
    /// contact was last updated.
    ///
    /// Optional if no conversation exists for this contact.
    public var lastUpdateAt: UInt64 {
      get {return _lastUpdateAt ?? 0}
      set {_lastUpdateAt = newValue}
    }
    /// Returns true if `lastUpdateAt` has been explicitly set.
    public var hasLastUpdateAt: Bool {return self._lastUpdateAt != nil}
    /// Clears the value of `lastUpdateAt`. Subsequent reads from it will return its default value.
    public mutating func clearLastUpdateAt() {self._lastUpdateAt = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _contact: Sync_Contact? = nil
    fileprivate var _lastUpdateAt: UInt64? = nil
  }

  /// Groups
  public struct AugmentedGroup {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The group's data.
    public var group: Sync_Group {
      get {return _storage._group ?? Sync_Group()}
      set {_uniqueStorage()._group = newValue}
    }
    /// Returns true if `group` has been explicitly set.
    public var hasGroup: Bool {return _storage._group != nil}
    /// Clears the value of `group`. Subsequent reads from it will return its default value.
    public mutating func clearGroup() {_uniqueStorage()._group = nil}

    /// Unix-ish timestamp in milliseconds when the conversation with this
    /// group was last updated.
    public var lastUpdateAt: UInt64 {
      get {return _storage._lastUpdateAt}
      set {_uniqueStorage()._lastUpdateAt = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Distribution lists
  public struct AugmentedDistributionList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The distribution list's data.
    public var distributionList: Sync_DistributionList {
      get {return _distributionList ?? Sync_DistributionList()}
      set {_distributionList = newValue}
    }
    /// Returns true if `distributionList` has been explicitly set.
    public var hasDistributionList: Bool {return self._distributionList != nil}
    /// Clears the value of `distributionList`. Subsequent reads from it will return its default value.
    public mutating func clearDistributionList() {self._distributionList = nil}

    /// Unix-ish timestamp in milliseconds when the conversation of this
    /// distribution list was last updated.
    public var lastUpdateAt: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _distributionList: Sync_DistributionList? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Lets ED know that ND has received all essential data and successfully
/// registered itself on the mediator server.
///
/// When receiving this message:
///
/// 1. Commit the transaction on the D2M connection. From this point on,
///    processing `Reflected` and end-to-end encrypted message coming from the
///    chat server is allowed again.
/// 2. Wait for ND to either close the connection or for ND to request
///    conversation history data. Any further messages from ND will move into
///    the History Exchange Protocol.
public struct Join_Registered {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Join_NdToEd: @unchecked Sendable {}
extension Join_NdToEd.OneOf_Content: @unchecked Sendable {}
extension Join_EdToNd: @unchecked Sendable {}
extension Join_EdToNd.OneOf_Content: @unchecked Sendable {}
extension Join_Begin: @unchecked Sendable {}
extension Join_EssentialData: @unchecked Sendable {}
extension Join_EssentialData.IdentityData: @unchecked Sendable {}
extension Join_EssentialData.DeviceGroupData: @unchecked Sendable {}
extension Join_EssentialData.AugmentedContact: @unchecked Sendable {}
extension Join_EssentialData.AugmentedGroup: @unchecked Sendable {}
extension Join_EssentialData.AugmentedDistributionList: @unchecked Sendable {}
extension Join_Registered: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "join"

extension Join_NdToEd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NdToEd"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "registered"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Join_Registered?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .registered(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .registered(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .registered(let v)? = self.content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Join_NdToEd, rhs: Join_NdToEd) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Join_EdToNd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EdToNd"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "begin"),
    2: .standard(proto: "blob_data"),
    3: .standard(proto: "essential_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Join_Begin?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .begin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .begin(v)
        }
      }()
      case 2: try {
        var v: Common_BlobData?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .blobData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .blobData(v)
        }
      }()
      case 3: try {
        var v: Join_EssentialData?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .essentialData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .essentialData(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .begin?: try {
      guard case .begin(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .blobData?: try {
      guard case .blobData(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .essentialData?: try {
      guard case .essentialData(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Join_EdToNd, rhs: Join_EdToNd) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Join_Begin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Begin"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Join_Begin, rhs: Join_Begin) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Join_EssentialData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EssentialData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "identity_data"),
    12: .standard(proto: "work_credentials"),
    3: .standard(proto: "device_group_data"),
    4: .standard(proto: "user_profile"),
    5: .same(proto: "settings"),
    6: .standard(proto: "mdm_parameters"),
    7: .same(proto: "contacts"),
    8: .same(proto: "groups"),
    9: .standard(proto: "distribution_lists"),
    10: .standard(proto: "csp_hashed_nonces"),
    11: .standard(proto: "d2d_hashed_nonces"),
  ]

  fileprivate class _StorageClass {
    var _identityData: Join_EssentialData.IdentityData? = nil
    var _workCredentials: Sync_ThreemaWorkCredentials? = nil
    var _deviceGroupData: Join_EssentialData.DeviceGroupData? = nil
    var _userProfile: Sync_UserProfile? = nil
    var _settings: Sync_Settings? = nil
    var _mdmParameters: Sync_MdmParameters? = nil
    var _contacts: [Join_EssentialData.AugmentedContact] = []
    var _groups: [Join_EssentialData.AugmentedGroup] = []
    var _distributionLists: [Join_EssentialData.AugmentedDistributionList] = []
    var _cspHashedNonces: [Data] = []
    var _d2DHashedNonces: [Data] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _identityData = source._identityData
      _workCredentials = source._workCredentials
      _deviceGroupData = source._deviceGroupData
      _userProfile = source._userProfile
      _settings = source._settings
      _mdmParameters = source._mdmParameters
      _contacts = source._contacts
      _groups = source._groups
      _distributionLists = source._distributionLists
      _cspHashedNonces = source._cspHashedNonces
      _d2DHashedNonces = source._d2DHashedNonces
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._identityData) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._deviceGroupData) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._userProfile) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._settings) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._mdmParameters) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._contacts) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._groups) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._distributionLists) }()
        case 10: try { try decoder.decodeRepeatedBytesField(value: &_storage._cspHashedNonces) }()
        case 11: try { try decoder.decodeRepeatedBytesField(value: &_storage._d2DHashedNonces) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._workCredentials) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._identityData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._deviceGroupData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._userProfile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._settings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._mdmParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._contacts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._contacts, fieldNumber: 7)
      }
      if !_storage._groups.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._groups, fieldNumber: 8)
      }
      if !_storage._distributionLists.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._distributionLists, fieldNumber: 9)
      }
      if !_storage._cspHashedNonces.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._cspHashedNonces, fieldNumber: 10)
      }
      if !_storage._d2DHashedNonces.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._d2DHashedNonces, fieldNumber: 11)
      }
      try { if let v = _storage._workCredentials {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Join_EssentialData, rhs: Join_EssentialData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._identityData != rhs_storage._identityData {return false}
        if _storage._workCredentials != rhs_storage._workCredentials {return false}
        if _storage._deviceGroupData != rhs_storage._deviceGroupData {return false}
        if _storage._userProfile != rhs_storage._userProfile {return false}
        if _storage._settings != rhs_storage._settings {return false}
        if _storage._mdmParameters != rhs_storage._mdmParameters {return false}
        if _storage._contacts != rhs_storage._contacts {return false}
        if _storage._groups != rhs_storage._groups {return false}
        if _storage._distributionLists != rhs_storage._distributionLists {return false}
        if _storage._cspHashedNonces != rhs_storage._cspHashedNonces {return false}
        if _storage._d2DHashedNonces != rhs_storage._d2DHashedNonces {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Join_EssentialData.IdentityData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Join_EssentialData.protoMessageName + ".IdentityData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identity"),
    2: .same(proto: "ck"),
    3: .standard(proto: "csp_device_cookie"),
    4: .standard(proto: "csp_server_group"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.ck) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.cspDeviceCookie) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.cspServerGroup) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    if !self.ck.isEmpty {
      try visitor.visitSingularBytesField(value: self.ck, fieldNumber: 2)
    }
    if !self.cspDeviceCookie.isEmpty {
      try visitor.visitSingularBytesField(value: self.cspDeviceCookie, fieldNumber: 3)
    }
    if !self.cspServerGroup.isEmpty {
      try visitor.visitSingularStringField(value: self.cspServerGroup, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Join_EssentialData.IdentityData, rhs: Join_EssentialData.IdentityData) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.ck != rhs.ck {return false}
    if lhs.cspDeviceCookie != rhs.cspDeviceCookie {return false}
    if lhs.cspServerGroup != rhs.cspServerGroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Join_EssentialData.DeviceGroupData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Join_EssentialData.protoMessageName + ".DeviceGroupData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dgk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.dgk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dgk.isEmpty {
      try visitor.visitSingularBytesField(value: self.dgk, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Join_EssentialData.DeviceGroupData, rhs: Join_EssentialData.DeviceGroupData) -> Bool {
    if lhs.dgk != rhs.dgk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Join_EssentialData.AugmentedContact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Join_EssentialData.protoMessageName + ".AugmentedContact"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contact"),
    2: .standard(proto: "last_update_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._contact) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._lastUpdateAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contact {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lastUpdateAt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Join_EssentialData.AugmentedContact, rhs: Join_EssentialData.AugmentedContact) -> Bool {
    if lhs._contact != rhs._contact {return false}
    if lhs._lastUpdateAt != rhs._lastUpdateAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Join_EssentialData.AugmentedGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Join_EssentialData.protoMessageName + ".AugmentedGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .standard(proto: "last_update_at"),
  ]

  fileprivate class _StorageClass {
    var _group: Sync_Group? = nil
    var _lastUpdateAt: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _group = source._group
      _lastUpdateAt = source._lastUpdateAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._group) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._lastUpdateAt) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._group {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._lastUpdateAt != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._lastUpdateAt, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Join_EssentialData.AugmentedGroup, rhs: Join_EssentialData.AugmentedGroup) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._group != rhs_storage._group {return false}
        if _storage._lastUpdateAt != rhs_storage._lastUpdateAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Join_EssentialData.AugmentedDistributionList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Join_EssentialData.protoMessageName + ".AugmentedDistributionList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "distribution_list"),
    2: .standard(proto: "last_update_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._distributionList) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.lastUpdateAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._distributionList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.lastUpdateAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastUpdateAt, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Join_EssentialData.AugmentedDistributionList, rhs: Join_EssentialData.AugmentedDistributionList) -> Bool {
    if lhs._distributionList != rhs._distributionList {return false}
    if lhs.lastUpdateAt != rhs.lastUpdateAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Join_Registered: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Registered"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Join_Registered, rhs: Join_Registered) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
