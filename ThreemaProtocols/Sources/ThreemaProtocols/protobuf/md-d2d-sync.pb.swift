// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: md-d2d-sync.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// ## Data Synchronisation Messages
//
// All strings are UTF-8 encoded.
//
// ### General Information
//
// When creating a sync message, only provide fields which are required and
// fields whose values have changed (i.e. delta updates). Fields that are
// required will be explicitly marked. For any other field within a sync
// message, assume that it is optional.
//
// When receiving a sync message, only handle fields whose values have been
// provided. As a rule of thumb, if a field is not present it means that the
// value has not changed.
//
// If more specific rules are needed in order to handle a field correctly,
// a description will be provided for the specific field.
//
// ### Validation
//
// A sync message should be validated by the following general rules:
//
// - Strictly validate enums, i.e. unknown values are not allowed and no
//   silent fallbacks are allowed.
// - Empty strings/lists have a different semantic than an omitted string/list.
//   The field should have a concise description on whether emptiness is
//   allowed, and, if so, the meaning of _empty_.
// - Follow the description of each field for more specific validation.
//
// If any of these rules is violated, the message should be discarded and logged
// as an error (but still acknowledged, if necessary).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// _Read_ receipt policy (when an unread message has been read)
public enum Sync_ReadReceiptPolicy: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Send _read_ receipt when an unread message has been read
  case sendReadReceipt // = 0

  /// Don't send _read_ receipts
  case dontSendReadReceipt // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .sendReadReceipt
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sendReadReceipt
    case 1: self = .dontSendReadReceipt
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .sendReadReceipt: return 0
    case .dontSendReadReceipt: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sync_ReadReceiptPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_ReadReceiptPolicy] = [
    .sendReadReceipt,
    .dontSendReadReceipt,
  ]
}

#endif  // swift(>=4.2)

/// Typing indicator policy (signal _currently typing_)
public enum Sync_TypingIndicatorPolicy: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Send _typing_ indicator when a message is being composed
  case sendTypingIndicator // = 0

  /// Don't send _typing_ indicators
  case dontSendTypingIndicator // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .sendTypingIndicator
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sendTypingIndicator
    case 1: self = .dontSendTypingIndicator
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .sendTypingIndicator: return 0
    case .dontSendTypingIndicator: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sync_TypingIndicatorPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_TypingIndicatorPolicy] = [
    .sendTypingIndicator,
    .dontSendTypingIndicator,
  ]
}

#endif  // swift(>=4.2)

/// Notification sound policy.
public enum Sync_NotificationSoundPolicy: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Do not emit a sound when notifying of a _conversation_ message.
  case muted // = 0
  case UNRECOGNIZED(Int)

  public init() {
    self = .muted
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .muted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .muted: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sync_NotificationSoundPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_NotificationSoundPolicy] = [
    .muted,
  ]
}

#endif  // swift(>=4.2)

/// Visibility of a conversation.
public enum Sync_ConversationVisibility: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Appears normally in the list of conversations
  case normal // = 0

  /// Appears pinned in the list of conversations
  case pinned // = 2

  /// Appears in the archived list of conversations
  case archived // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .normal
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .normal
    case 1: self = .archived
    case 2: self = .pinned
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .normal: return 0
    case .archived: return 1
    case .pinned: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sync_ConversationVisibility: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_ConversationVisibility] = [
    .normal,
    .pinned,
    .archived,
  ]
}

#endif  // swift(>=4.2)

/// Category of a conversation.
public enum Sync_ConversationCategory: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// No specific (default) category
  case `default` // = 0

  /// Protected conversation (_private chat_)
  case protected // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .default
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .default
    case 1: self = .protected
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .default: return 0
    case .protected: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sync_ConversationCategory: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_ConversationCategory] = [
    .default,
    .protected,
  ]
}

#endif  // swift(>=4.2)

/// Application configuration parameters shared across Threema Work devices.
///
/// See [mdm-parameters.md](./md-parameters.md) for documentation of possible
/// parameter values and associated steps to apply when a parameter has been set
/// for the first time, modified, or removed.
///
/// Note: MDM parameters are always transmitted fully, not as delta updates.
public struct Sync_MdmParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A map of MDM parameters, originating from an external MDM system. The map
  /// key is the identifier of the MDM parameter (e.g. `th_nickname`).
  public var externalParameters: Dictionary<String,Sync_MdmParameters.Parameter> = [:]

  /// A map of MDM parameters, originating from Threema App Configuration. The
  /// map key is the identifier of the MDM parameter (e.g. `th_nickname`).
  public var threemaParameters: Dictionary<String,Sync_MdmParameters.Parameter> = [:]

  /// The parameter precedence defines how to resolve conflicting parameters
  /// between an external MDM and the Threema App Configuration.
  public var parameterPrecedence: Sync_MdmParameters.ParameterPrecedence = .threema

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ParameterPrecedence: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// On conflict, parameters defined by Threema App Configuration take
    /// precedence
    case threema // = 0

    /// On conflict, parameters defined by an external MDM take precedence
    case external // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .threema
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .threema
      case 1: self = .external
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .threema: return 0
      case .external: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// A single MDM parameter.
  public struct Parameter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var value: Sync_MdmParameters.Parameter.OneOf_Value? = nil

    /// String parameter
    public var stringValue: String {
      get {
        if case .stringValue(let v)? = value {return v}
        return String()
      }
      set {value = .stringValue(newValue)}
    }

    /// Integer parameter
    public var integerValue: UInt64 {
      get {
        if case .integerValue(let v)? = value {return v}
        return 0
      }
      set {value = .integerValue(newValue)}
    }

    /// Boolean parameter
    public var booleanValue: Bool {
      get {
        if case .booleanValue(let v)? = value {return v}
        return false
      }
      set {value = .booleanValue(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Value: Equatable {
      /// String parameter
      case stringValue(String)
      /// Integer parameter
      case integerValue(UInt64)
      /// Boolean parameter
      case booleanValue(Bool)

    #if !swift(>=4.1)
      public static func ==(lhs: Sync_MdmParameters.Parameter.OneOf_Value, rhs: Sync_MdmParameters.Parameter.OneOf_Value) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.stringValue, .stringValue): return {
          guard case .stringValue(let l) = lhs, case .stringValue(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.integerValue, .integerValue): return {
          guard case .integerValue(let l) = lhs, case .integerValue(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.booleanValue, .booleanValue): return {
          guard case .booleanValue(let l) = lhs, case .booleanValue(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Sync_MdmParameters.ParameterPrecedence: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_MdmParameters.ParameterPrecedence] = [
    .threema,
    .external,
  ]
}

#endif  // swift(>=4.2)

/// Threema Work credentials for authentication towards Work APIs.
public struct Sync_ThreemaWorkCredentials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Work username.
  public var username: String = String()

  /// Work password.
  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The user's profile.
public struct Sync_UserProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Nickname
  ///
  /// Required towards a new device. Optional otherwise.
  ///
  /// When the user cleared its nickname, send an empty string. Do not send the
  /// user's Threema ID (i.e. process data).
  ///
  /// When an empty string was received, store the empty string as-is and fall
  /// back to the users Threema ID when sending an end-to-end encrypted message.
  public var nickname: String {
    get {return _nickname ?? String()}
    set {_nickname = newValue}
  }
  /// Returns true if `nickname` has been explicitly set.
  public var hasNickname: Bool {return self._nickname != nil}
  /// Clears the value of `nickname`. Subsequent reads from it will return its default value.
  public mutating func clearNickname() {self._nickname = nil}

  /// Profile picture
  ///
  /// Always optional.
  public var profilePicture: Common_DeltaImage {
    get {return _profilePicture ?? Common_DeltaImage()}
    set {_profilePicture = newValue}
  }
  /// Returns true if `profilePicture` has been explicitly set.
  public var hasProfilePicture: Bool {return self._profilePicture != nil}
  /// Clears the value of `profilePicture`. Subsequent reads from it will return its default value.
  public mutating func clearProfilePicture() {self._profilePicture = nil}

  public var profilePictureShareWith: Sync_UserProfile.ProfilePictureShareWith {
    get {return _profilePictureShareWith ?? Sync_UserProfile.ProfilePictureShareWith()}
    set {_profilePictureShareWith = newValue}
  }
  /// Returns true if `profilePictureShareWith` has been explicitly set.
  public var hasProfilePictureShareWith: Bool {return self._profilePictureShareWith != nil}
  /// Clears the value of `profilePictureShareWith`. Subsequent reads from it will return its default value.
  public mutating func clearProfilePictureShareWith() {self._profilePictureShareWith = nil}

  public var identityLinks: Sync_UserProfile.IdentityLinks {
    get {return _identityLinks ?? Sync_UserProfile.IdentityLinks()}
    set {_identityLinks = newValue}
  }
  /// Returns true if `identityLinks` has been explicitly set.
  public var hasIdentityLinks: Bool {return self._identityLinks != nil}
  /// Clears the value of `identityLinks`. Subsequent reads from it will return its default value.
  public mutating func clearIdentityLinks() {self._identityLinks = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Profile picture share policy
  ///
  /// Required towards a new device. Optional otherwise.
  public struct ProfilePictureShareWith {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var policy: Sync_UserProfile.ProfilePictureShareWith.OneOf_Policy? = nil

    /// Don't share
    public var nobody: Common_Unit {
      get {
        if case .nobody(let v)? = policy {return v}
        return Common_Unit()
      }
      set {policy = .nobody(newValue)}
    }

    /// Share with everyone
    public var everyone: Common_Unit {
      get {
        if case .everyone(let v)? = policy {return v}
        return Common_Unit()
      }
      set {policy = .everyone(newValue)}
    }

    /// Share only with explicitly listed contacts
    ///
    /// When the user selected _allow list_ but did not select any contacts,
    /// send an empty list. Do not fall back to `nobody`.
    public var allowList: Common_Identities {
      get {
        if case .allowList(let v)? = policy {return v}
        return Common_Identities()
      }
      set {policy = .allowList(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Policy: Equatable {
      /// Don't share
      case nobody(Common_Unit)
      /// Share with everyone
      case everyone(Common_Unit)
      /// Share only with explicitly listed contacts
      ///
      /// When the user selected _allow list_ but did not select any contacts,
      /// send an empty list. Do not fall back to `nobody`.
      case allowList(Common_Identities)

    #if !swift(>=4.1)
      public static func ==(lhs: Sync_UserProfile.ProfilePictureShareWith.OneOf_Policy, rhs: Sync_UserProfile.ProfilePictureShareWith.OneOf_Policy) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.nobody, .nobody): return {
          guard case .nobody(let l) = lhs, case .nobody(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.everyone, .everyone): return {
          guard case .everyone(let l) = lhs, case .everyone(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.allowList, .allowList): return {
          guard case .allowList(let l) = lhs, case .allowList(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// External entities linked with the identity
  ///
  /// Required towards a new device. Optional otherwise.
  ///
  /// When the user has cleared all of its identity links, this message is
  /// present but `links` contains zero items.
  public struct IdentityLinks {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// List of identity links
    public var links: [Sync_UserProfile.IdentityLinks.IdentityLink] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Threema ID link.
    public struct IdentityLink {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Identity link type
      public var type: Sync_UserProfile.IdentityLinks.IdentityLink.OneOf_Type? = nil

      /// Linked with a verified telephone number (E.164 format without leading
      /// `+`)
      public var phoneNumber: String {
        get {
          if case .phoneNumber(let v)? = type {return v}
          return String()
        }
        set {type = .phoneNumber(newValue)}
      }

      /// Linked with a verified email address
      public var email: String {
        get {
          if case .email(let v)? = type {return v}
          return String()
        }
        set {type = .email(newValue)}
      }

      /// Identity link description
      public var description_p: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Identity link type
      public enum OneOf_Type: Equatable {
        /// Linked with a verified telephone number (E.164 format without leading
        /// `+`)
        case phoneNumber(String)
        /// Linked with a verified email address
        case email(String)

      #if !swift(>=4.1)
        public static func ==(lhs: Sync_UserProfile.IdentityLinks.IdentityLink.OneOf_Type, rhs: Sync_UserProfile.IdentityLinks.IdentityLink.OneOf_Type) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.phoneNumber, .phoneNumber): return {
            guard case .phoneNumber(let l) = lhs, case .phoneNumber(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.email, .email): return {
            guard case .email(let l) = lhs, case .email(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _nickname: String? = nil
  fileprivate var _profilePicture: Common_DeltaImage? = nil
  fileprivate var _profilePictureShareWith: Sync_UserProfile.ProfilePictureShareWith? = nil
  fileprivate var _identityLinks: Sync_UserProfile.IdentityLinks? = nil
}

/// Threema contact.
public struct Sync_Contact {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Threema ID of the contact
  ///
  /// Always required.
  public var identity: String {
    get {return _storage._identity}
    set {_uniqueStorage()._identity = newValue}
  }

  /// Public key of the contact
  ///
  /// Required towards a new device and for a new contact. Should not be set
  /// for existing contacts and must be ignored (a public key for an identity
  /// cannot be changed).
  public var publicKey: Data {
    get {return _storage._publicKey ?? Data()}
    set {_uniqueStorage()._publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  public var hasPublicKey: Bool {return _storage._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPublicKey() {_uniqueStorage()._publicKey = nil}

  /// Unix-ish timestamp in milliseconds when the contact has been created
  /// (added) locally.
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  public var createdAt: UInt64 {
    get {return _storage._createdAt ?? 0}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// First name of the contact
  ///
  /// Always optional.
  ///
  /// An empty string is valid. When both `first_name` and `last_name` are
  /// empty string, the `nickname` should be used as display name.
  public var firstName: String {
    get {return _storage._firstName ?? String()}
    set {_uniqueStorage()._firstName = newValue}
  }
  /// Returns true if `firstName` has been explicitly set.
  public var hasFirstName: Bool {return _storage._firstName != nil}
  /// Clears the value of `firstName`. Subsequent reads from it will return its default value.
  public mutating func clearFirstName() {_uniqueStorage()._firstName = nil}

  /// Last name of the contact
  ///
  /// Always optional.
  ///
  /// An empty string is valid. When both `first_name` and `last_name` are
  /// empty string, the `nickname` should be used as display name.
  public var lastName: String {
    get {return _storage._lastName ?? String()}
    set {_uniqueStorage()._lastName = newValue}
  }
  /// Returns true if `lastName` has been explicitly set.
  public var hasLastName: Bool {return _storage._lastName != nil}
  /// Clears the value of `lastName`. Subsequent reads from it will return its default value.
  public mutating func clearLastName() {_uniqueStorage()._lastName = nil}

  /// Nickname of the contact (without `~` prefix)
  ///
  /// Always optional.
  ///
  /// An empty string is valid. If `first_name`, `last_name` and `nickname` are
  /// empty string, the Threema ID should be used as display name.
  public var nickname: String {
    get {return _storage._nickname ?? String()}
    set {_uniqueStorage()._nickname = newValue}
  }
  /// Returns true if `nickname` has been explicitly set.
  public var hasNickname: Bool {return _storage._nickname != nil}
  /// Clears the value of `nickname`. Subsequent reads from it will return its default value.
  public mutating func clearNickname() {_uniqueStorage()._nickname = nil}

  public var verificationLevel: Sync_Contact.VerificationLevel {
    get {return _storage._verificationLevel ?? .unverified}
    set {_uniqueStorage()._verificationLevel = newValue}
  }
  /// Returns true if `verificationLevel` has been explicitly set.
  public var hasVerificationLevel: Bool {return _storage._verificationLevel != nil}
  /// Clears the value of `verificationLevel`. Subsequent reads from it will return its default value.
  public mutating func clearVerificationLevel() {_uniqueStorage()._verificationLevel = nil}

  public var workVerificationLevel: Sync_Contact.WorkVerificationLevel {
    get {return _storage._workVerificationLevel ?? .none}
    set {_uniqueStorage()._workVerificationLevel = newValue}
  }
  /// Returns true if `workVerificationLevel` has been explicitly set.
  public var hasWorkVerificationLevel: Bool {return _storage._workVerificationLevel != nil}
  /// Clears the value of `workVerificationLevel`. Subsequent reads from it will return its default value.
  public mutating func clearWorkVerificationLevel() {_uniqueStorage()._workVerificationLevel = nil}

  public var identityType: Sync_Contact.IdentityType {
    get {return _storage._identityType ?? .regular}
    set {_uniqueStorage()._identityType = newValue}
  }
  /// Returns true if `identityType` has been explicitly set.
  public var hasIdentityType: Bool {return _storage._identityType != nil}
  /// Clears the value of `identityType`. Subsequent reads from it will return its default value.
  public mutating func clearIdentityType() {_uniqueStorage()._identityType = nil}

  public var acquaintanceLevel: Sync_Contact.AcquaintanceLevel {
    get {return _storage._acquaintanceLevel ?? .direct}
    set {_uniqueStorage()._acquaintanceLevel = newValue}
  }
  /// Returns true if `acquaintanceLevel` has been explicitly set.
  public var hasAcquaintanceLevel: Bool {return _storage._acquaintanceLevel != nil}
  /// Clears the value of `acquaintanceLevel`. Subsequent reads from it will return its default value.
  public mutating func clearAcquaintanceLevel() {_uniqueStorage()._acquaintanceLevel = nil}

  public var activityState: Sync_Contact.ActivityState {
    get {return _storage._activityState ?? .active}
    set {_uniqueStorage()._activityState = newValue}
  }
  /// Returns true if `activityState` has been explicitly set.
  public var hasActivityState: Bool {return _storage._activityState != nil}
  /// Clears the value of `activityState`. Subsequent reads from it will return its default value.
  public mutating func clearActivityState() {_uniqueStorage()._activityState = nil}

  /// Features available for the contact (64 bit mask,
  /// `common.CspFeatureMaskFlag` logically or-ed).
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  public var featureMask: UInt64 {
    get {return _storage._featureMask ?? 0}
    set {_uniqueStorage()._featureMask = newValue}
  }
  /// Returns true if `featureMask` has been explicitly set.
  public var hasFeatureMask: Bool {return _storage._featureMask != nil}
  /// Clears the value of `featureMask`. Subsequent reads from it will return its default value.
  public mutating func clearFeatureMask() {_uniqueStorage()._featureMask = nil}

  public var syncState: Sync_Contact.SyncState {
    get {return _storage._syncState ?? .initial}
    set {_uniqueStorage()._syncState = newValue}
  }
  /// Returns true if `syncState` has been explicitly set.
  public var hasSyncState: Bool {return _storage._syncState != nil}
  /// Clears the value of `syncState`. Subsequent reads from it will return its default value.
  public mutating func clearSyncState() {_uniqueStorage()._syncState = nil}

  public var readReceiptPolicyOverride: Sync_Contact.ReadReceiptPolicyOverride {
    get {return _storage._readReceiptPolicyOverride ?? Sync_Contact.ReadReceiptPolicyOverride()}
    set {_uniqueStorage()._readReceiptPolicyOverride = newValue}
  }
  /// Returns true if `readReceiptPolicyOverride` has been explicitly set.
  public var hasReadReceiptPolicyOverride: Bool {return _storage._readReceiptPolicyOverride != nil}
  /// Clears the value of `readReceiptPolicyOverride`. Subsequent reads from it will return its default value.
  public mutating func clearReadReceiptPolicyOverride() {_uniqueStorage()._readReceiptPolicyOverride = nil}

  public var typingIndicatorPolicyOverride: Sync_Contact.TypingIndicatorPolicyOverride {
    get {return _storage._typingIndicatorPolicyOverride ?? Sync_Contact.TypingIndicatorPolicyOverride()}
    set {_uniqueStorage()._typingIndicatorPolicyOverride = newValue}
  }
  /// Returns true if `typingIndicatorPolicyOverride` has been explicitly set.
  public var hasTypingIndicatorPolicyOverride: Bool {return _storage._typingIndicatorPolicyOverride != nil}
  /// Clears the value of `typingIndicatorPolicyOverride`. Subsequent reads from it will return its default value.
  public mutating func clearTypingIndicatorPolicyOverride() {_uniqueStorage()._typingIndicatorPolicyOverride = nil}

  public var notificationTriggerPolicyOverride: Sync_Contact.NotificationTriggerPolicyOverride {
    get {return _storage._notificationTriggerPolicyOverride ?? Sync_Contact.NotificationTriggerPolicyOverride()}
    set {_uniqueStorage()._notificationTriggerPolicyOverride = newValue}
  }
  /// Returns true if `notificationTriggerPolicyOverride` has been explicitly set.
  public var hasNotificationTriggerPolicyOverride: Bool {return _storage._notificationTriggerPolicyOverride != nil}
  /// Clears the value of `notificationTriggerPolicyOverride`. Subsequent reads from it will return its default value.
  public mutating func clearNotificationTriggerPolicyOverride() {_uniqueStorage()._notificationTriggerPolicyOverride = nil}

  public var notificationSoundPolicyOverride: Sync_Contact.NotificationSoundPolicyOverride {
    get {return _storage._notificationSoundPolicyOverride ?? Sync_Contact.NotificationSoundPolicyOverride()}
    set {_uniqueStorage()._notificationSoundPolicyOverride = newValue}
  }
  /// Returns true if `notificationSoundPolicyOverride` has been explicitly set.
  public var hasNotificationSoundPolicyOverride: Bool {return _storage._notificationSoundPolicyOverride != nil}
  /// Clears the value of `notificationSoundPolicyOverride`. Subsequent reads from it will return its default value.
  public mutating func clearNotificationSoundPolicyOverride() {_uniqueStorage()._notificationSoundPolicyOverride = nil}

  /// Contact-defined profile picture as received from the contact in a
  /// `set-profile-picture` message.
  ///
  /// Always optional.
  public var contactDefinedProfilePicture: Common_DeltaImage {
    get {return _storage._contactDefinedProfilePicture ?? Common_DeltaImage()}
    set {_uniqueStorage()._contactDefinedProfilePicture = newValue}
  }
  /// Returns true if `contactDefinedProfilePicture` has been explicitly set.
  public var hasContactDefinedProfilePicture: Bool {return _storage._contactDefinedProfilePicture != nil}
  /// Clears the value of `contactDefinedProfilePicture`. Subsequent reads from it will return its default value.
  public mutating func clearContactDefinedProfilePicture() {_uniqueStorage()._contactDefinedProfilePicture = nil}

  /// User-defined profile picture set by the user or imported from the address
  /// book.
  ///
  /// Always optional.
  public var userDefinedProfilePicture: Common_DeltaImage {
    get {return _storage._userDefinedProfilePicture ?? Common_DeltaImage()}
    set {_uniqueStorage()._userDefinedProfilePicture = newValue}
  }
  /// Returns true if `userDefinedProfilePicture` has been explicitly set.
  public var hasUserDefinedProfilePicture: Bool {return _storage._userDefinedProfilePicture != nil}
  /// Clears the value of `userDefinedProfilePicture`. Subsequent reads from it will return its default value.
  public mutating func clearUserDefinedProfilePicture() {_uniqueStorage()._userDefinedProfilePicture = nil}

  /// Conversation category of the contact
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  public var conversationCategory: Sync_ConversationCategory {
    get {return _storage._conversationCategory ?? .default}
    set {_uniqueStorage()._conversationCategory = newValue}
  }
  /// Returns true if `conversationCategory` has been explicitly set.
  public var hasConversationCategory: Bool {return _storage._conversationCategory != nil}
  /// Clears the value of `conversationCategory`. Subsequent reads from it will return its default value.
  public mutating func clearConversationCategory() {_uniqueStorage()._conversationCategory = nil}

  /// Conversation visibility of the contact
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  public var conversationVisibility: Sync_ConversationVisibility {
    get {return _storage._conversationVisibility ?? .normal}
    set {_uniqueStorage()._conversationVisibility = newValue}
  }
  /// Returns true if `conversationVisibility` has been explicitly set.
  public var hasConversationVisibility: Bool {return _storage._conversationVisibility != nil}
  /// Clears the value of `conversationVisibility`. Subsequent reads from it will return its default value.
  public mutating func clearConversationVisibility() {_uniqueStorage()._conversationVisibility = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Verification level of the contact
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  ///
  /// Note: When applying logic depending on the verification level, a
  /// `WorkVerificationLevel` of `WORK_SUBSCRIPTION_VERIFIED` virtually raises
  /// the verification level to `SERVER_VERIFIED`. However, the contact
  /// verification level takes precedence if it is `FULLY_VERIFIED`.
  public enum VerificationLevel: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unverified, public key has been obtained from the server
    case unverified // = 0

    /// Verified with one of the account links via the server, or the contact
    /// has been obtained via the Work API.
    case serverVerified // = 1

    /// Verified, public key has been obtained via a secure channel
    case fullyVerified // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unverified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unverified
      case 1: self = .serverVerified
      case 2: self = .fullyVerified
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unverified: return 0
      case .serverVerified: return 1
      case .fullyVerified: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Threema Work verification level of the contact.
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  ///
  /// Note: When not using a Threema Work client, the Threema Work verification
  /// level must always be `NONE`.
  public enum WorkVerificationLevel: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The user does not use Threema Work or the contact is not in the same
    /// Threema Work subscription.
    case none // = 0

    /// The contact is in the same Threema Work subscription.
    case workSubscriptionVerified // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .workSubscriptionVerified
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .workSubscriptionVerified: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Identity type of the contact
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  public enum IdentityType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Regular contact (uses the regular Threema app)
    case regular // = 0

    /// Work contact (uses the Threema work app)
    case work // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .regular
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .regular
      case 1: self = .work
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .regular: return 0
      case .work: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Acquaintance level of the contact
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  public enum AcquaintanceLevel: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The contact was explicitly added by the user or a 1:1 conversation with
    /// the contact has been initiated.
    case direct // = 0

    /// The contact is part of a group the user is also part of. The contact was
    /// not explicitly added and no 1:1 conversation has been initiated.
    case group // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .direct
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .direct
      case 1: self = .group
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .direct: return 0
      case .group: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Activity state of the contact
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  public enum ActivityState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The ID is active (used recently and not deleted).
    case active // = 0

    /// The ID has not been used for a prolonged time (typically 3 months) and
    /// may have been abandoned. Such IDs can be marked as "inactive" in the
    /// client's contact database, and the user may be alerted to the fact that
    /// messages to this ID may not arrive (e.g. alert box, gray color in
    /// contact list etc.). An inactive ID can become active again at any time,
    /// so the client should keep checking it.
    case inactive // = 1

    /// ID has never been assigned, or it has been permanently deleted. Such IDs
    /// should be marked as "deleted" in the client's contact database, and no
    /// further messages should be sent or received from them. Since deletion is
    /// permanent, once an ID has been reported as invalid by the server, it
    /// should not be checked again in the future.
    case invalid // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .active
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .active
      case 1: self = .inactive
      case 2: self = .invalid
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .active: return 0
      case .inactive: return 1
      case .invalid: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Contact synchronisation state
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  ///
  /// These states are strict monotonic. When a downgrade is being detected,
  /// log the incident and ignore the update.
  public enum SyncState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The contact data has not been imported and has not been edited by the
    /// user either.
    case initial // = 0

    /// The contact data has been imported (e.g. via a local address book and an
    /// identity link). In this state, subsequent contact synchronisations must
    /// not alter the contact's data.
    case imported // = 1

    /// The contact data has been edited by the user. In this state, subsequent
    /// contact synchronisations must not alter the contact's data.
    case custom // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .initial
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .initial
      case 1: self = .imported
      case 2: self = .custom
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .initial: return 0
      case .imported: return 1
      case .custom: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// _Read_ receipt policy override for this contact
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  public struct ReadReceiptPolicyOverride {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var override: Sync_Contact.ReadReceiptPolicyOverride.OneOf_Override? = nil

    /// Apply the _read_ receipt policy specified in the settings
    public var `default`: Common_Unit {
      get {
        if case .default(let v)? = override {return v}
        return Common_Unit()
      }
      set {override = .default(newValue)}
    }

    /// Apply the following _read_ receipt policy
    public var policy: Sync_ReadReceiptPolicy {
      get {
        if case .policy(let v)? = override {return v}
        return .sendReadReceipt
      }
      set {override = .policy(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Override: Equatable {
      /// Apply the _read_ receipt policy specified in the settings
      case `default`(Common_Unit)
      /// Apply the following _read_ receipt policy
      case policy(Sync_ReadReceiptPolicy)

    #if !swift(>=4.1)
      public static func ==(lhs: Sync_Contact.ReadReceiptPolicyOverride.OneOf_Override, rhs: Sync_Contact.ReadReceiptPolicyOverride.OneOf_Override) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.default, .default): return {
          guard case .default(let l) = lhs, case .default(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.policy, .policy): return {
          guard case .policy(let l) = lhs, case .policy(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// Typing indicator policy override for this contact
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  public struct TypingIndicatorPolicyOverride {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var override: Sync_Contact.TypingIndicatorPolicyOverride.OneOf_Override? = nil

    /// Apply the typing indicator policy specified in the settings
    public var `default`: Common_Unit {
      get {
        if case .default(let v)? = override {return v}
        return Common_Unit()
      }
      set {override = .default(newValue)}
    }

    /// Apply the following typing indicator policy
    public var policy: Sync_TypingIndicatorPolicy {
      get {
        if case .policy(let v)? = override {return v}
        return .sendTypingIndicator
      }
      set {override = .policy(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Override: Equatable {
      /// Apply the typing indicator policy specified in the settings
      case `default`(Common_Unit)
      /// Apply the following typing indicator policy
      case policy(Sync_TypingIndicatorPolicy)

    #if !swift(>=4.1)
      public static func ==(lhs: Sync_Contact.TypingIndicatorPolicyOverride.OneOf_Override, rhs: Sync_Contact.TypingIndicatorPolicyOverride.OneOf_Override) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.default, .default): return {
          guard case .default(let l) = lhs, case .default(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.policy, .policy): return {
          guard case .policy(let l) = lhs, case .policy(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// Notification trigger policy for the contact
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  public struct NotificationTriggerPolicyOverride {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var override: Sync_Contact.NotificationTriggerPolicyOverride.OneOf_Override? = nil

    /// Apply the trigger policy specified in the settings (i.e. trigger on
    /// every _conversation_ message).
    public var `default`: Common_Unit {
      get {
        if case .default(let v)? = override {return v}
        return Common_Unit()
      }
      set {override = .default(newValue)}
    }

    /// Apply the following notification trigger policy
    public var policy: Sync_Contact.NotificationTriggerPolicyOverride.Policy {
      get {
        if case .policy(let v)? = override {return v}
        return Sync_Contact.NotificationTriggerPolicyOverride.Policy()
      }
      set {override = .policy(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Override: Equatable {
      /// Apply the trigger policy specified in the settings (i.e. trigger on
      /// every _conversation_ message).
      case `default`(Common_Unit)
      /// Apply the following notification trigger policy
      case policy(Sync_Contact.NotificationTriggerPolicyOverride.Policy)

    #if !swift(>=4.1)
      public static func ==(lhs: Sync_Contact.NotificationTriggerPolicyOverride.OneOf_Override, rhs: Sync_Contact.NotificationTriggerPolicyOverride.OneOf_Override) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.default, .default): return {
          guard case .default(let l) = lhs, case .default(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.policy, .policy): return {
          guard case .policy(let l) = lhs, case .policy(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public struct Policy {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var policy: Sync_Contact.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy = .never

      /// Unix-ish timestamp in milliseconds when the provided policy should
      /// expire and fall back to the default. If not provided, the policy does
      /// not expire.
      public var expiresAt: UInt64 {
        get {return _expiresAt ?? 0}
        set {_expiresAt = newValue}
      }
      /// Returns true if `expiresAt` has been explicitly set.
      public var hasExpiresAt: Bool {return self._expiresAt != nil}
      /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
      public mutating func clearExpiresAt() {self._expiresAt = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Apply the following notification trigger policy
      public enum NotificationTriggerPolicy: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// Never trigger a notification message.
        case never // = 0
        case UNRECOGNIZED(Int)

        public init() {
          self = .never
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .never
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .never: return 0
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}

      fileprivate var _expiresAt: UInt64? = nil
    }

    public init() {}
  }

  /// Notification sound policy for the contact
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  ///
  /// Custom sounds are not reflected but are to be (re-)applied in case the
  /// policy is _default_.
  public struct NotificationSoundPolicyOverride {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var override: Sync_Contact.NotificationSoundPolicyOverride.OneOf_Override? = nil

    /// Apply the notification sound policy specified in the settings (i.e.
    /// always emit a sound when notifying of a _conversation_ message).
    public var `default`: Common_Unit {
      get {
        if case .default(let v)? = override {return v}
        return Common_Unit()
      }
      set {override = .default(newValue)}
    }

    /// Apply the following notification sound policy
    public var policy: Sync_NotificationSoundPolicy {
      get {
        if case .policy(let v)? = override {return v}
        return .muted
      }
      set {override = .policy(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Override: Equatable {
      /// Apply the notification sound policy specified in the settings (i.e.
      /// always emit a sound when notifying of a _conversation_ message).
      case `default`(Common_Unit)
      /// Apply the following notification sound policy
      case policy(Sync_NotificationSoundPolicy)

    #if !swift(>=4.1)
      public static func ==(lhs: Sync_Contact.NotificationSoundPolicyOverride.OneOf_Override, rhs: Sync_Contact.NotificationSoundPolicyOverride.OneOf_Override) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.default, .default): return {
          guard case .default(let l) = lhs, case .default(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.policy, .policy): return {
          guard case .policy(let l) = lhs, case .policy(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Sync_Contact.VerificationLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_Contact.VerificationLevel] = [
    .unverified,
    .serverVerified,
    .fullyVerified,
  ]
}

extension Sync_Contact.WorkVerificationLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_Contact.WorkVerificationLevel] = [
    .none,
    .workSubscriptionVerified,
  ]
}

extension Sync_Contact.IdentityType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_Contact.IdentityType] = [
    .regular,
    .work,
  ]
}

extension Sync_Contact.AcquaintanceLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_Contact.AcquaintanceLevel] = [
    .direct,
    .group,
  ]
}

extension Sync_Contact.ActivityState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_Contact.ActivityState] = [
    .active,
    .inactive,
    .invalid,
  ]
}

extension Sync_Contact.SyncState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_Contact.SyncState] = [
    .initial,
    .imported,
    .custom,
  ]
}

extension Sync_Contact.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_Contact.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy] = [
    .never,
  ]
}

#endif  // swift(>=4.2)

/// Threema contacts associated to a group.
public struct Sync_Group {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique group identity
  ///
  /// Always required.
  public var groupIdentity: Common_GroupIdentity {
    get {return _groupIdentity ?? Common_GroupIdentity()}
    set {_groupIdentity = newValue}
  }
  /// Returns true if `groupIdentity` has been explicitly set.
  public var hasGroupIdentity: Bool {return self._groupIdentity != nil}
  /// Clears the value of `groupIdentity`. Subsequent reads from it will return its default value.
  public mutating func clearGroupIdentity() {self._groupIdentity = nil}

  /// Name of the group
  ///
  /// Required towards a new device and for a new group. Optional for an
  /// existing group.
  ///
  /// An empty string is valid. In such a case, the display name of the
  /// group is the list of its members.
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  /// Unix-ish timestamp in milliseconds when the group has been created locally
  ///
  /// Required towards a new device and for a new group. Optional for an
  /// existing group.
  public var createdAt: UInt64 {
    get {return _createdAt ?? 0}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var userState: Sync_Group.UserState {
    get {return _userState ?? .member}
    set {_userState = newValue}
  }
  /// Returns true if `userState` has been explicitly set.
  public var hasUserState: Bool {return self._userState != nil}
  /// Clears the value of `userState`. Subsequent reads from it will return its default value.
  public mutating func clearUserState() {self._userState = nil}

  public var notificationTriggerPolicyOverride: Sync_Group.NotificationTriggerPolicyOverride {
    get {return _notificationTriggerPolicyOverride ?? Sync_Group.NotificationTriggerPolicyOverride()}
    set {_notificationTriggerPolicyOverride = newValue}
  }
  /// Returns true if `notificationTriggerPolicyOverride` has been explicitly set.
  public var hasNotificationTriggerPolicyOverride: Bool {return self._notificationTriggerPolicyOverride != nil}
  /// Clears the value of `notificationTriggerPolicyOverride`. Subsequent reads from it will return its default value.
  public mutating func clearNotificationTriggerPolicyOverride() {self._notificationTriggerPolicyOverride = nil}

  public var notificationSoundPolicyOverride: Sync_Group.NotificationSoundPolicyOverride {
    get {return _notificationSoundPolicyOverride ?? Sync_Group.NotificationSoundPolicyOverride()}
    set {_notificationSoundPolicyOverride = newValue}
  }
  /// Returns true if `notificationSoundPolicyOverride` has been explicitly set.
  public var hasNotificationSoundPolicyOverride: Bool {return self._notificationSoundPolicyOverride != nil}
  /// Clears the value of `notificationSoundPolicyOverride`. Subsequent reads from it will return its default value.
  public mutating func clearNotificationSoundPolicyOverride() {self._notificationSoundPolicyOverride = nil}

  /// Group's profile picture as received from the group's creator
  ///
  /// Always optional.
  public var profilePicture: Common_DeltaImage {
    get {return _profilePicture ?? Common_DeltaImage()}
    set {_profilePicture = newValue}
  }
  /// Returns true if `profilePicture` has been explicitly set.
  public var hasProfilePicture: Bool {return self._profilePicture != nil}
  /// Clears the value of `profilePicture`. Subsequent reads from it will return its default value.
  public mutating func clearProfilePicture() {self._profilePicture = nil}

  /// Group members (**NOT** including the user itself)
  ///
  /// Required towards a new device and for a new group. Optional for an existing
  /// group.
  ///
  /// The concrete semantic of this list depends on the current `user_state`:
  ///
  /// - `MEMBER`: It contains a list of all **current** group members (with the
  ///   user itself implicitly added).
  /// - `KICKED`/`LEFT`: It contains a list of all **previous** group members up
  ///   to that event. If the list is empty, the group must not be visible in the
  ///   UI.
  ///
  /// An empty list is valid.
  public var memberIdentities: Common_Identities {
    get {return _memberIdentities ?? Common_Identities()}
    set {_memberIdentities = newValue}
  }
  /// Returns true if `memberIdentities` has been explicitly set.
  public var hasMemberIdentities: Bool {return self._memberIdentities != nil}
  /// Clears the value of `memberIdentities`. Subsequent reads from it will return its default value.
  public mutating func clearMemberIdentities() {self._memberIdentities = nil}

  /// Conversation category of the group
  ///
  /// Required towards a new device and for a new group. Optional for an
  /// existing group.
  public var conversationCategory: Sync_ConversationCategory {
    get {return _conversationCategory ?? .default}
    set {_conversationCategory = newValue}
  }
  /// Returns true if `conversationCategory` has been explicitly set.
  public var hasConversationCategory: Bool {return self._conversationCategory != nil}
  /// Clears the value of `conversationCategory`. Subsequent reads from it will return its default value.
  public mutating func clearConversationCategory() {self._conversationCategory = nil}

  /// Conversation visibility of the group
  ///
  /// Required towards a new device and for a new group. Optional for an
  /// existing group.
  public var conversationVisibility: Sync_ConversationVisibility {
    get {return _conversationVisibility ?? .normal}
    set {_conversationVisibility = newValue}
  }
  /// Returns true if `conversationVisibility` has been explicitly set.
  public var hasConversationVisibility: Bool {return self._conversationVisibility != nil}
  /// Clears the value of `conversationVisibility`. Subsequent reads from it will return its default value.
  public mutating func clearConversationVisibility() {self._conversationVisibility = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The user's state within the group
  ///
  /// Required towards a new device and for a new group. Optional for an
  /// existing group.
  public enum UserState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The user is a member (or creator) of the group.
    case member // = 0

    /// The user has been kicked from the group. Implies that the group has been
    /// marked as _left_.
    case kicked // = 1

    /// The user left the group. Implies that the group has been marked as
    /// _left_.
    case left // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .member
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .member
      case 1: self = .kicked
      case 2: self = .left
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .member: return 0
      case .kicked: return 1
      case .left: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Notification trigger policy for the group
  ///
  /// Required towards a new device and for a new group. Optional for an
  /// existing group.
  public struct NotificationTriggerPolicyOverride {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var override: Sync_Group.NotificationTriggerPolicyOverride.OneOf_Override? = nil

    /// Apply the trigger policy specified in the settings (i.e. trigger on
    /// every _conversation_ message).
    public var `default`: Common_Unit {
      get {
        if case .default(let v)? = override {return v}
        return Common_Unit()
      }
      set {override = .default(newValue)}
    }

    /// Apply the following notification trigger policy
    public var policy: Sync_Group.NotificationTriggerPolicyOverride.Policy {
      get {
        if case .policy(let v)? = override {return v}
        return Sync_Group.NotificationTriggerPolicyOverride.Policy()
      }
      set {override = .policy(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Override: Equatable {
      /// Apply the trigger policy specified in the settings (i.e. trigger on
      /// every _conversation_ message).
      case `default`(Common_Unit)
      /// Apply the following notification trigger policy
      case policy(Sync_Group.NotificationTriggerPolicyOverride.Policy)

    #if !swift(>=4.1)
      public static func ==(lhs: Sync_Group.NotificationTriggerPolicyOverride.OneOf_Override, rhs: Sync_Group.NotificationTriggerPolicyOverride.OneOf_Override) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.default, .default): return {
          guard case .default(let l) = lhs, case .default(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.policy, .policy): return {
          guard case .policy(let l) = lhs, case .policy(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public struct Policy {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var policy: Sync_Group.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy = .mentioned

      /// Unix-ish timestamp in milliseconds when the provided policy should
      /// expire and fall back to the default. If not provided, the policy does
      /// not expire.
      public var expiresAt: UInt64 {
        get {return _expiresAt ?? 0}
        set {_expiresAt = newValue}
      }
      /// Returns true if `expiresAt` has been explicitly set.
      public var hasExpiresAt: Bool {return self._expiresAt != nil}
      /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
      public mutating func clearExpiresAt() {self._expiresAt = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Apply the following notification trigger policy
      public enum NotificationTriggerPolicy: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// Only trigger a notification if mentioned in a _conversation_ message.
        case mentioned // = 0

        /// Never trigger a notification message.
        case never // = 1
        case UNRECOGNIZED(Int)

        public init() {
          self = .mentioned
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .mentioned
          case 1: self = .never
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .mentioned: return 0
          case .never: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}

      fileprivate var _expiresAt: UInt64? = nil
    }

    public init() {}
  }

  /// Notification sound policy for the group
  ///
  /// Required towards a new device and for a new group. Optional for an existing
  /// group.
  ///
  /// Custom sounds are not reflected but are to be (re-)applied in case the
  /// policy is _default_.
  public struct NotificationSoundPolicyOverride {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var override: Sync_Group.NotificationSoundPolicyOverride.OneOf_Override? = nil

    /// Apply the notification sound policy specified in the settings (i.e.
    /// always emit a sound when notifying of a _conversation_ message).
    public var `default`: Common_Unit {
      get {
        if case .default(let v)? = override {return v}
        return Common_Unit()
      }
      set {override = .default(newValue)}
    }

    /// Apply the following notification sound policy
    public var policy: Sync_NotificationSoundPolicy {
      get {
        if case .policy(let v)? = override {return v}
        return .muted
      }
      set {override = .policy(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Override: Equatable {
      /// Apply the notification sound policy specified in the settings (i.e.
      /// always emit a sound when notifying of a _conversation_ message).
      case `default`(Common_Unit)
      /// Apply the following notification sound policy
      case policy(Sync_NotificationSoundPolicy)

    #if !swift(>=4.1)
      public static func ==(lhs: Sync_Group.NotificationSoundPolicyOverride.OneOf_Override, rhs: Sync_Group.NotificationSoundPolicyOverride.OneOf_Override) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.default, .default): return {
          guard case .default(let l) = lhs, case .default(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.policy, .policy): return {
          guard case .policy(let l) = lhs, case .policy(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}

  fileprivate var _groupIdentity: Common_GroupIdentity? = nil
  fileprivate var _name: String? = nil
  fileprivate var _createdAt: UInt64? = nil
  fileprivate var _userState: Sync_Group.UserState? = nil
  fileprivate var _notificationTriggerPolicyOverride: Sync_Group.NotificationTriggerPolicyOverride? = nil
  fileprivate var _notificationSoundPolicyOverride: Sync_Group.NotificationSoundPolicyOverride? = nil
  fileprivate var _profilePicture: Common_DeltaImage? = nil
  fileprivate var _memberIdentities: Common_Identities? = nil
  fileprivate var _conversationCategory: Sync_ConversationCategory? = nil
  fileprivate var _conversationVisibility: Sync_ConversationVisibility? = nil
}

#if swift(>=4.2)

extension Sync_Group.UserState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_Group.UserState] = [
    .member,
    .kicked,
    .left,
  ]
}

extension Sync_Group.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_Group.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy] = [
    .mentioned,
    .never,
  ]
}

#endif  // swift(>=4.2)

/// Threema contacts associated to a distribution list.
public struct Sync_DistributionList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID of the distribution list
  ///
  /// Always required.
  public var distributionListID: UInt64 = 0

  /// Name of the distribution list
  ///
  /// Required towards a new device and for a new distribution list. Optional
  /// for an existing distribution list.
  ///
  /// An empty string is valid. In such a case, the display name of the
  /// distribution list is the list of its members.
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  /// Unix-ish timestamp in milliseconds when the group has been created
  ///
  /// Required towards a new device and for a new distribution list. Optional
  /// for an existing distribution list.
  public var createdAt: UInt64 {
    get {return _createdAt ?? 0}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// Distribution list members
  ///
  /// Required towards a new device and for a new distribution list. Optional
  /// for an existing distribution list.
  ///
  /// An empty list is **not** valid. Clearing all members should be prevented
  /// by the UI.
  public var memberIdentities: Common_Identities {
    get {return _memberIdentities ?? Common_Identities()}
    set {_memberIdentities = newValue}
  }
  /// Returns true if `memberIdentities` has been explicitly set.
  public var hasMemberIdentities: Bool {return self._memberIdentities != nil}
  /// Clears the value of `memberIdentities`. Subsequent reads from it will return its default value.
  public mutating func clearMemberIdentities() {self._memberIdentities = nil}

  /// Conversation category of the distribution list
  ///
  /// Required towards a new device and for a new distribution list. Optional
  /// for an existing distribution list.
  public var conversationCategory: Sync_ConversationCategory {
    get {return _conversationCategory ?? .default}
    set {_conversationCategory = newValue}
  }
  /// Returns true if `conversationCategory` has been explicitly set.
  public var hasConversationCategory: Bool {return self._conversationCategory != nil}
  /// Clears the value of `conversationCategory`. Subsequent reads from it will return its default value.
  public mutating func clearConversationCategory() {self._conversationCategory = nil}

  /// Conversation visibility of the distribution list
  ///
  /// Required towards a new device and for a new distribution list. Optional
  /// for an existing distribution list.
  public var conversationVisibility: Sync_ConversationVisibility {
    get {return _conversationVisibility ?? .normal}
    set {_conversationVisibility = newValue}
  }
  /// Returns true if `conversationVisibility` has been explicitly set.
  public var hasConversationVisibility: Bool {return self._conversationVisibility != nil}
  /// Clears the value of `conversationVisibility`. Subsequent reads from it will return its default value.
  public mutating func clearConversationVisibility() {self._conversationVisibility = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _createdAt: UInt64? = nil
  fileprivate var _memberIdentities: Common_Identities? = nil
  fileprivate var _conversationCategory: Sync_ConversationCategory? = nil
  fileprivate var _conversationVisibility: Sync_ConversationVisibility? = nil
}

/// App settings
///
/// When the user changes one or more settings:
///
/// 1. Begin a transaction (scope: `SETTINGS_SYNC`, precondition: none).
/// 2. For each setting that has been modified, run the associated steps of the
///    setting and include the modified settings.
/// 3. Reflect this message and commit the transaction.
/// 4. Apply the modified settings locally.
///
/// When reflected from another device:
///
/// 1. For each setting that is being included by this message, run the
///    associated steps of the setting and apply the modified setting.
public struct Sync_Settings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var contactSyncPolicy: Sync_Settings.ContactSyncPolicy {
    get {return _contactSyncPolicy ?? .notSynced}
    set {_contactSyncPolicy = newValue}
  }
  /// Returns true if `contactSyncPolicy` has been explicitly set.
  public var hasContactSyncPolicy: Bool {return self._contactSyncPolicy != nil}
  /// Clears the value of `contactSyncPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearContactSyncPolicy() {self._contactSyncPolicy = nil}

  public var unknownContactPolicy: Sync_Settings.UnknownContactPolicy {
    get {return _unknownContactPolicy ?? .allowUnknown}
    set {_unknownContactPolicy = newValue}
  }
  /// Returns true if `unknownContactPolicy` has been explicitly set.
  public var hasUnknownContactPolicy: Bool {return self._unknownContactPolicy != nil}
  /// Clears the value of `unknownContactPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearUnknownContactPolicy() {self._unknownContactPolicy = nil}

  /// _Read_ receipt policy (when an unread message has been read)
  ///
  /// Required towards a new device. Optional otherwise.
  public var readReceiptPolicy: Sync_ReadReceiptPolicy {
    get {return _readReceiptPolicy ?? .sendReadReceipt}
    set {_readReceiptPolicy = newValue}
  }
  /// Returns true if `readReceiptPolicy` has been explicitly set.
  public var hasReadReceiptPolicy: Bool {return self._readReceiptPolicy != nil}
  /// Clears the value of `readReceiptPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearReadReceiptPolicy() {self._readReceiptPolicy = nil}

  /// Typing indicator policy (signal _currently typing_)
  ///
  /// Required towards a new device. Optional otherwise.
  public var typingIndicatorPolicy: Sync_TypingIndicatorPolicy {
    get {return _typingIndicatorPolicy ?? .sendTypingIndicator}
    set {_typingIndicatorPolicy = newValue}
  }
  /// Returns true if `typingIndicatorPolicy` has been explicitly set.
  public var hasTypingIndicatorPolicy: Bool {return self._typingIndicatorPolicy != nil}
  /// Clears the value of `typingIndicatorPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearTypingIndicatorPolicy() {self._typingIndicatorPolicy = nil}

  public var o2OCallPolicy: Sync_Settings.O2oCallPolicy {
    get {return _o2OCallPolicy ?? .allowO2OCall}
    set {_o2OCallPolicy = newValue}
  }
  /// Returns true if `o2OCallPolicy` has been explicitly set.
  public var hasO2OCallPolicy: Bool {return self._o2OCallPolicy != nil}
  /// Clears the value of `o2OCallPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearO2OCallPolicy() {self._o2OCallPolicy = nil}

  public var o2OCallConnectionPolicy: Sync_Settings.O2oCallConnectionPolicy {
    get {return _o2OCallConnectionPolicy ?? .allowDirectConnection}
    set {_o2OCallConnectionPolicy = newValue}
  }
  /// Returns true if `o2OCallConnectionPolicy` has been explicitly set.
  public var hasO2OCallConnectionPolicy: Bool {return self._o2OCallConnectionPolicy != nil}
  /// Clears the value of `o2OCallConnectionPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearO2OCallConnectionPolicy() {self._o2OCallConnectionPolicy = nil}

  public var o2OCallVideoPolicy: Sync_Settings.O2oCallVideoPolicy {
    get {return _o2OCallVideoPolicy ?? .allowVideo}
    set {_o2OCallVideoPolicy = newValue}
  }
  /// Returns true if `o2OCallVideoPolicy` has been explicitly set.
  public var hasO2OCallVideoPolicy: Bool {return self._o2OCallVideoPolicy != nil}
  /// Clears the value of `o2OCallVideoPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearO2OCallVideoPolicy() {self._o2OCallVideoPolicy = nil}

  public var groupCallPolicy: Sync_Settings.GroupCallPolicy {
    get {return _groupCallPolicy ?? .allowGroupCall}
    set {_groupCallPolicy = newValue}
  }
  /// Returns true if `groupCallPolicy` has been explicitly set.
  public var hasGroupCallPolicy: Bool {return self._groupCallPolicy != nil}
  /// Clears the value of `groupCallPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearGroupCallPolicy() {self._groupCallPolicy = nil}

  public var screenshotPolicy: Sync_Settings.ScreenshotPolicy {
    get {return _screenshotPolicy ?? .allowScreenshot}
    set {_screenshotPolicy = newValue}
  }
  /// Returns true if `screenshotPolicy` has been explicitly set.
  public var hasScreenshotPolicy: Bool {return self._screenshotPolicy != nil}
  /// Clears the value of `screenshotPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearScreenshotPolicy() {self._screenshotPolicy = nil}

  public var keyboardDataCollectionPolicy: Sync_Settings.KeyboardDataCollectionPolicy {
    get {return _keyboardDataCollectionPolicy ?? .allowDataCollection}
    set {_keyboardDataCollectionPolicy = newValue}
  }
  /// Returns true if `keyboardDataCollectionPolicy` has been explicitly set.
  public var hasKeyboardDataCollectionPolicy: Bool {return self._keyboardDataCollectionPolicy != nil}
  /// Clears the value of `keyboardDataCollectionPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearKeyboardDataCollectionPolicy() {self._keyboardDataCollectionPolicy = nil}

  /// List of Threema IDs whose messages are blocked
  ///
  /// Required towards a new device. Optional otherwise.
  ///
  /// An empty list is valid.
  public var blockedIdentities: Common_Identities {
    get {return _blockedIdentities ?? Common_Identities()}
    set {_blockedIdentities = newValue}
  }
  /// Returns true if `blockedIdentities` has been explicitly set.
  public var hasBlockedIdentities: Bool {return self._blockedIdentities != nil}
  /// Clears the value of `blockedIdentities`. Subsequent reads from it will return its default value.
  public mutating func clearBlockedIdentities() {self._blockedIdentities = nil}

  /// Threema IDs to be excluded when syncing the contact list
  ///
  /// Required towards a new device. Optional otherwise.
  ///
  /// An empty list is valid.
  public var excludeFromSyncIdentities: Common_Identities {
    get {return _excludeFromSyncIdentities ?? Common_Identities()}
    set {_excludeFromSyncIdentities = newValue}
  }
  /// Returns true if `excludeFromSyncIdentities` has been explicitly set.
  public var hasExcludeFromSyncIdentities: Bool {return self._excludeFromSyncIdentities != nil}
  /// Clears the value of `excludeFromSyncIdentities`. Subsequent reads from it will return its default value.
  public mutating func clearExcludeFromSyncIdentities() {self._excludeFromSyncIdentities = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Contact synchronisation policy
  ///
  /// Required towards a new device. Optional otherwise.
  public enum ContactSyncPolicy: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not synced
    case notSynced // = 0

    /// Synced
    case sync // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .notSynced
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notSynced
      case 1: self = .sync
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .notSynced: return 0
      case .sync: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Unknown contacts policy
  ///
  /// Required towards a new device. Optional otherwise.
  public enum UnknownContactPolicy: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Allowed to contact the user
    case allowUnknown // = 0

    /// Will be blocked by the user
    case blockUnknown // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .allowUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowUnknown
      case 1: self = .blockUnknown
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .allowUnknown: return 0
      case .blockUnknown: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Threema 1:1 Call policy
  ///
  /// Required towards a new device. Optional otherwise.
  public enum O2oCallPolicy: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Allow creating/receiving Threema 1:1 Calls
    case allowO2OCall // = 0

    /// Denied from creating/receiving any Threema 1:1 Calls
    case denyO2OCall // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .allowO2OCall
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowO2OCall
      case 1: self = .denyO2OCall
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .allowO2OCall: return 0
      case .denyO2OCall: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Threema 1:1 Call connection policy.
  ///
  /// Required towards a new device. Optional otherwise.
  ///
  /// Note: This is only relevant for 1:1 calls.
  public enum O2oCallConnectionPolicy: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Allow direct (peer-to-peer) connections for Threema 1:1 Calls
    case allowDirectConnection // = 0

    /// Require relayed connections for Threema 1:1 Calls
    case requireRelayedConnection // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .allowDirectConnection
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowDirectConnection
      case 1: self = .requireRelayedConnection
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .allowDirectConnection: return 0
      case .requireRelayedConnection: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Threema 1:1 Call video (stream) policy.
  ///
  /// Required towards a new device. Optional otherwise.
  public enum O2oCallVideoPolicy: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Allow sending and receiving video streams in Threema 1:1 Calls.
    case allowVideo // = 0

    /// Reject and don't send video streams in Threema 1:1 Calls.
    case denyVideo // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .allowVideo
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowVideo
      case 1: self = .denyVideo
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .allowVideo: return 0
      case .denyVideo: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Threema Group Call policy
  ///
  /// Required towards a new device. Optional otherwise.
  public enum GroupCallPolicy: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Allow creating/receiving Threema Group Calls
    case allowGroupCall // = 0

    /// Denied from creating/receiving any Threema Group Calls
    case denyGroupCall // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .allowGroupCall
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowGroupCall
      case 1: self = .denyGroupCall
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .allowGroupCall: return 0
      case .denyGroupCall: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Screenshot policy
  ///
  /// Required towards a new device. Optional otherwise.
  public enum ScreenshotPolicy: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Allow taking screenshots
    case allowScreenshot // = 0

    /// Deny taking screenshots, if possible
    case denyScreenshot // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .allowScreenshot
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowScreenshot
      case 1: self = .denyScreenshot
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .allowScreenshot: return 0
      case .denyScreenshot: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Keyboard data collection policy (e.g. for personalised suggestions)
  ///
  /// Required towards a new device. Optional otherwise.
  public enum KeyboardDataCollectionPolicy: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Allow keyboard input data to be collected
    case allowDataCollection // = 0

    /// Deny collecting of keyboard input data
    case denyDataCollection // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .allowDataCollection
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowDataCollection
      case 1: self = .denyDataCollection
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .allowDataCollection: return 0
      case .denyDataCollection: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _contactSyncPolicy: Sync_Settings.ContactSyncPolicy? = nil
  fileprivate var _unknownContactPolicy: Sync_Settings.UnknownContactPolicy? = nil
  fileprivate var _readReceiptPolicy: Sync_ReadReceiptPolicy? = nil
  fileprivate var _typingIndicatorPolicy: Sync_TypingIndicatorPolicy? = nil
  fileprivate var _o2OCallPolicy: Sync_Settings.O2oCallPolicy? = nil
  fileprivate var _o2OCallConnectionPolicy: Sync_Settings.O2oCallConnectionPolicy? = nil
  fileprivate var _o2OCallVideoPolicy: Sync_Settings.O2oCallVideoPolicy? = nil
  fileprivate var _groupCallPolicy: Sync_Settings.GroupCallPolicy? = nil
  fileprivate var _screenshotPolicy: Sync_Settings.ScreenshotPolicy? = nil
  fileprivate var _keyboardDataCollectionPolicy: Sync_Settings.KeyboardDataCollectionPolicy? = nil
  fileprivate var _blockedIdentities: Common_Identities? = nil
  fileprivate var _excludeFromSyncIdentities: Common_Identities? = nil
}

#if swift(>=4.2)

extension Sync_Settings.ContactSyncPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_Settings.ContactSyncPolicy] = [
    .notSynced,
    .sync,
  ]
}

extension Sync_Settings.UnknownContactPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_Settings.UnknownContactPolicy] = [
    .allowUnknown,
    .blockUnknown,
  ]
}

extension Sync_Settings.O2oCallPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_Settings.O2oCallPolicy] = [
    .allowO2OCall,
    .denyO2OCall,
  ]
}

extension Sync_Settings.O2oCallConnectionPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_Settings.O2oCallConnectionPolicy] = [
    .allowDirectConnection,
    .requireRelayedConnection,
  ]
}

extension Sync_Settings.O2oCallVideoPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_Settings.O2oCallVideoPolicy] = [
    .allowVideo,
    .denyVideo,
  ]
}

extension Sync_Settings.GroupCallPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_Settings.GroupCallPolicy] = [
    .allowGroupCall,
    .denyGroupCall,
  ]
}

extension Sync_Settings.ScreenshotPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_Settings.ScreenshotPolicy] = [
    .allowScreenshot,
    .denyScreenshot,
  ]
}

extension Sync_Settings.KeyboardDataCollectionPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sync_Settings.KeyboardDataCollectionPolicy] = [
    .allowDataCollection,
    .denyDataCollection,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Sync_ReadReceiptPolicy: @unchecked Sendable {}
extension Sync_TypingIndicatorPolicy: @unchecked Sendable {}
extension Sync_NotificationSoundPolicy: @unchecked Sendable {}
extension Sync_ConversationVisibility: @unchecked Sendable {}
extension Sync_ConversationCategory: @unchecked Sendable {}
extension Sync_MdmParameters: @unchecked Sendable {}
extension Sync_MdmParameters.ParameterPrecedence: @unchecked Sendable {}
extension Sync_MdmParameters.Parameter: @unchecked Sendable {}
extension Sync_MdmParameters.Parameter.OneOf_Value: @unchecked Sendable {}
extension Sync_ThreemaWorkCredentials: @unchecked Sendable {}
extension Sync_UserProfile: @unchecked Sendable {}
extension Sync_UserProfile.ProfilePictureShareWith: @unchecked Sendable {}
extension Sync_UserProfile.ProfilePictureShareWith.OneOf_Policy: @unchecked Sendable {}
extension Sync_UserProfile.IdentityLinks: @unchecked Sendable {}
extension Sync_UserProfile.IdentityLinks.IdentityLink: @unchecked Sendable {}
extension Sync_UserProfile.IdentityLinks.IdentityLink.OneOf_Type: @unchecked Sendable {}
extension Sync_Contact: @unchecked Sendable {}
extension Sync_Contact.VerificationLevel: @unchecked Sendable {}
extension Sync_Contact.WorkVerificationLevel: @unchecked Sendable {}
extension Sync_Contact.IdentityType: @unchecked Sendable {}
extension Sync_Contact.AcquaintanceLevel: @unchecked Sendable {}
extension Sync_Contact.ActivityState: @unchecked Sendable {}
extension Sync_Contact.SyncState: @unchecked Sendable {}
extension Sync_Contact.ReadReceiptPolicyOverride: @unchecked Sendable {}
extension Sync_Contact.ReadReceiptPolicyOverride.OneOf_Override: @unchecked Sendable {}
extension Sync_Contact.TypingIndicatorPolicyOverride: @unchecked Sendable {}
extension Sync_Contact.TypingIndicatorPolicyOverride.OneOf_Override: @unchecked Sendable {}
extension Sync_Contact.NotificationTriggerPolicyOverride: @unchecked Sendable {}
extension Sync_Contact.NotificationTriggerPolicyOverride.OneOf_Override: @unchecked Sendable {}
extension Sync_Contact.NotificationTriggerPolicyOverride.Policy: @unchecked Sendable {}
extension Sync_Contact.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy: @unchecked Sendable {}
extension Sync_Contact.NotificationSoundPolicyOverride: @unchecked Sendable {}
extension Sync_Contact.NotificationSoundPolicyOverride.OneOf_Override: @unchecked Sendable {}
extension Sync_Group: @unchecked Sendable {}
extension Sync_Group.UserState: @unchecked Sendable {}
extension Sync_Group.NotificationTriggerPolicyOverride: @unchecked Sendable {}
extension Sync_Group.NotificationTriggerPolicyOverride.OneOf_Override: @unchecked Sendable {}
extension Sync_Group.NotificationTriggerPolicyOverride.Policy: @unchecked Sendable {}
extension Sync_Group.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy: @unchecked Sendable {}
extension Sync_Group.NotificationSoundPolicyOverride: @unchecked Sendable {}
extension Sync_Group.NotificationSoundPolicyOverride.OneOf_Override: @unchecked Sendable {}
extension Sync_DistributionList: @unchecked Sendable {}
extension Sync_Settings: @unchecked Sendable {}
extension Sync_Settings.ContactSyncPolicy: @unchecked Sendable {}
extension Sync_Settings.UnknownContactPolicy: @unchecked Sendable {}
extension Sync_Settings.O2oCallPolicy: @unchecked Sendable {}
extension Sync_Settings.O2oCallConnectionPolicy: @unchecked Sendable {}
extension Sync_Settings.O2oCallVideoPolicy: @unchecked Sendable {}
extension Sync_Settings.GroupCallPolicy: @unchecked Sendable {}
extension Sync_Settings.ScreenshotPolicy: @unchecked Sendable {}
extension Sync_Settings.KeyboardDataCollectionPolicy: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "sync"

extension Sync_ReadReceiptPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SEND_READ_RECEIPT"),
    1: .same(proto: "DONT_SEND_READ_RECEIPT"),
  ]
}

extension Sync_TypingIndicatorPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SEND_TYPING_INDICATOR"),
    1: .same(proto: "DONT_SEND_TYPING_INDICATOR"),
  ]
}

extension Sync_NotificationSoundPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MUTED"),
  ]
}

extension Sync_ConversationVisibility: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "ARCHIVED"),
    2: .same(proto: "PINNED"),
  ]
}

extension Sync_ConversationCategory: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "PROTECTED"),
  ]
}

extension Sync_MdmParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MdmParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "external_parameters"),
    2: .standard(proto: "threema_parameters"),
    3: .standard(proto: "parameter_precedence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Sync_MdmParameters.Parameter>.self, value: &self.externalParameters) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Sync_MdmParameters.Parameter>.self, value: &self.threemaParameters) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.parameterPrecedence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.externalParameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Sync_MdmParameters.Parameter>.self, value: self.externalParameters, fieldNumber: 1)
    }
    if !self.threemaParameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Sync_MdmParameters.Parameter>.self, value: self.threemaParameters, fieldNumber: 2)
    }
    if self.parameterPrecedence != .threema {
      try visitor.visitSingularEnumField(value: self.parameterPrecedence, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_MdmParameters, rhs: Sync_MdmParameters) -> Bool {
    if lhs.externalParameters != rhs.externalParameters {return false}
    if lhs.threemaParameters != rhs.threemaParameters {return false}
    if lhs.parameterPrecedence != rhs.parameterPrecedence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_MdmParameters.ParameterPrecedence: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "THREEMA"),
    1: .same(proto: "EXTERNAL"),
  ]
}

extension Sync_MdmParameters.Parameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_MdmParameters.protoMessageName + ".Parameter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "string_value"),
    3: .standard(proto: "integer_value"),
    2: .standard(proto: "boolean_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .stringValue(v)
        }
      }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .booleanValue(v)
        }
      }()
      case 3: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .integerValue(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .booleanValue?: try {
      guard case .booleanValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .integerValue?: try {
      guard case .integerValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_MdmParameters.Parameter, rhs: Sync_MdmParameters.Parameter) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ThreemaWorkCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThreemaWorkCredentials"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ThreemaWorkCredentials, rhs: Sync_ThreemaWorkCredentials) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_UserProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nickname"),
    2: .standard(proto: "profile_picture"),
    3: .standard(proto: "profile_picture_share_with"),
    4: .standard(proto: "identity_links"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._nickname) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._profilePicture) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._profilePictureShareWith) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._identityLinks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nickname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._profilePicture {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._profilePictureShareWith {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._identityLinks {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_UserProfile, rhs: Sync_UserProfile) -> Bool {
    if lhs._nickname != rhs._nickname {return false}
    if lhs._profilePicture != rhs._profilePicture {return false}
    if lhs._profilePictureShareWith != rhs._profilePictureShareWith {return false}
    if lhs._identityLinks != rhs._identityLinks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_UserProfile.ProfilePictureShareWith: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_UserProfile.protoMessageName + ".ProfilePictureShareWith"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nobody"),
    2: .same(proto: "everyone"),
    3: .standard(proto: "allow_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .nobody(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .nobody(v)
        }
      }()
      case 2: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .everyone(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .everyone(v)
        }
      }()
      case 3: try {
        var v: Common_Identities?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .allowList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .allowList(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.policy {
    case .nobody?: try {
      guard case .nobody(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .everyone?: try {
      guard case .everyone(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .allowList?: try {
      guard case .allowList(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_UserProfile.ProfilePictureShareWith, rhs: Sync_UserProfile.ProfilePictureShareWith) -> Bool {
    if lhs.policy != rhs.policy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_UserProfile.IdentityLinks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_UserProfile.protoMessageName + ".IdentityLinks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "links"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.links) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_UserProfile.IdentityLinks, rhs: Sync_UserProfile.IdentityLinks) -> Bool {
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_UserProfile.IdentityLinks.IdentityLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_UserProfile.IdentityLinks.protoMessageName + ".IdentityLink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "phone_number"),
    2: .same(proto: "email"),
    3: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .phoneNumber(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .email(v)
        }
      }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .phoneNumber?: try {
      guard case .phoneNumber(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .email?: try {
      guard case .email(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_UserProfile.IdentityLinks.IdentityLink, rhs: Sync_UserProfile.IdentityLinks.IdentityLink) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Contact"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identity"),
    2: .standard(proto: "public_key"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "first_name"),
    5: .standard(proto: "last_name"),
    6: .same(proto: "nickname"),
    7: .standard(proto: "verification_level"),
    21: .standard(proto: "work_verification_level"),
    8: .standard(proto: "identity_type"),
    9: .standard(proto: "acquaintance_level"),
    10: .standard(proto: "activity_state"),
    18: .standard(proto: "feature_mask"),
    13: .standard(proto: "sync_state"),
    16: .standard(proto: "read_receipt_policy_override"),
    17: .standard(proto: "typing_indicator_policy_override"),
    19: .standard(proto: "notification_trigger_policy_override"),
    20: .standard(proto: "notification_sound_policy_override"),
    14: .standard(proto: "contact_defined_profile_picture"),
    15: .standard(proto: "user_defined_profile_picture"),
    11: .standard(proto: "conversation_category"),
    12: .standard(proto: "conversation_visibility"),
  ]

  fileprivate class _StorageClass {
    var _identity: String = String()
    var _publicKey: Data? = nil
    var _createdAt: UInt64? = nil
    var _firstName: String? = nil
    var _lastName: String? = nil
    var _nickname: String? = nil
    var _verificationLevel: Sync_Contact.VerificationLevel? = nil
    var _workVerificationLevel: Sync_Contact.WorkVerificationLevel? = nil
    var _identityType: Sync_Contact.IdentityType? = nil
    var _acquaintanceLevel: Sync_Contact.AcquaintanceLevel? = nil
    var _activityState: Sync_Contact.ActivityState? = nil
    var _featureMask: UInt64? = nil
    var _syncState: Sync_Contact.SyncState? = nil
    var _readReceiptPolicyOverride: Sync_Contact.ReadReceiptPolicyOverride? = nil
    var _typingIndicatorPolicyOverride: Sync_Contact.TypingIndicatorPolicyOverride? = nil
    var _notificationTriggerPolicyOverride: Sync_Contact.NotificationTriggerPolicyOverride? = nil
    var _notificationSoundPolicyOverride: Sync_Contact.NotificationSoundPolicyOverride? = nil
    var _contactDefinedProfilePicture: Common_DeltaImage? = nil
    var _userDefinedProfilePicture: Common_DeltaImage? = nil
    var _conversationCategory: Sync_ConversationCategory? = nil
    var _conversationVisibility: Sync_ConversationVisibility? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _identity = source._identity
      _publicKey = source._publicKey
      _createdAt = source._createdAt
      _firstName = source._firstName
      _lastName = source._lastName
      _nickname = source._nickname
      _verificationLevel = source._verificationLevel
      _workVerificationLevel = source._workVerificationLevel
      _identityType = source._identityType
      _acquaintanceLevel = source._acquaintanceLevel
      _activityState = source._activityState
      _featureMask = source._featureMask
      _syncState = source._syncState
      _readReceiptPolicyOverride = source._readReceiptPolicyOverride
      _typingIndicatorPolicyOverride = source._typingIndicatorPolicyOverride
      _notificationTriggerPolicyOverride = source._notificationTriggerPolicyOverride
      _notificationSoundPolicyOverride = source._notificationSoundPolicyOverride
      _contactDefinedProfilePicture = source._contactDefinedProfilePicture
      _userDefinedProfilePicture = source._userDefinedProfilePicture
      _conversationCategory = source._conversationCategory
      _conversationVisibility = source._conversationVisibility
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._identity) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._publicKey) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._createdAt) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._firstName) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._lastName) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._nickname) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._verificationLevel) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._identityType) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._acquaintanceLevel) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._activityState) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._conversationCategory) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._conversationVisibility) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._syncState) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._contactDefinedProfilePicture) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._userDefinedProfilePicture) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._readReceiptPolicyOverride) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._typingIndicatorPolicyOverride) }()
        case 18: try { try decoder.decodeSingularUInt64Field(value: &_storage._featureMask) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._notificationTriggerPolicyOverride) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._notificationSoundPolicyOverride) }()
        case 21: try { try decoder.decodeSingularEnumField(value: &_storage._workVerificationLevel) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._identity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identity, fieldNumber: 1)
      }
      try { if let v = _storage._publicKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._firstName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._lastName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._nickname {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._verificationLevel {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._identityType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._acquaintanceLevel {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._activityState {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._conversationCategory {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._conversationVisibility {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._syncState {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._contactDefinedProfilePicture {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._userDefinedProfilePicture {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._readReceiptPolicyOverride {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._typingIndicatorPolicyOverride {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._featureMask {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._notificationTriggerPolicyOverride {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._notificationSoundPolicyOverride {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._workVerificationLevel {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 21)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Contact, rhs: Sync_Contact) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._publicKey != rhs_storage._publicKey {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._firstName != rhs_storage._firstName {return false}
        if _storage._lastName != rhs_storage._lastName {return false}
        if _storage._nickname != rhs_storage._nickname {return false}
        if _storage._verificationLevel != rhs_storage._verificationLevel {return false}
        if _storage._workVerificationLevel != rhs_storage._workVerificationLevel {return false}
        if _storage._identityType != rhs_storage._identityType {return false}
        if _storage._acquaintanceLevel != rhs_storage._acquaintanceLevel {return false}
        if _storage._activityState != rhs_storage._activityState {return false}
        if _storage._featureMask != rhs_storage._featureMask {return false}
        if _storage._syncState != rhs_storage._syncState {return false}
        if _storage._readReceiptPolicyOverride != rhs_storage._readReceiptPolicyOverride {return false}
        if _storage._typingIndicatorPolicyOverride != rhs_storage._typingIndicatorPolicyOverride {return false}
        if _storage._notificationTriggerPolicyOverride != rhs_storage._notificationTriggerPolicyOverride {return false}
        if _storage._notificationSoundPolicyOverride != rhs_storage._notificationSoundPolicyOverride {return false}
        if _storage._contactDefinedProfilePicture != rhs_storage._contactDefinedProfilePicture {return false}
        if _storage._userDefinedProfilePicture != rhs_storage._userDefinedProfilePicture {return false}
        if _storage._conversationCategory != rhs_storage._conversationCategory {return false}
        if _storage._conversationVisibility != rhs_storage._conversationVisibility {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Contact.VerificationLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNVERIFIED"),
    1: .same(proto: "SERVER_VERIFIED"),
    2: .same(proto: "FULLY_VERIFIED"),
  ]
}

extension Sync_Contact.WorkVerificationLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "WORK_SUBSCRIPTION_VERIFIED"),
  ]
}

extension Sync_Contact.IdentityType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REGULAR"),
    1: .same(proto: "WORK"),
  ]
}

extension Sync_Contact.AcquaintanceLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DIRECT"),
    1: .same(proto: "GROUP"),
  ]
}

extension Sync_Contact.ActivityState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACTIVE"),
    1: .same(proto: "INACTIVE"),
    2: .same(proto: "INVALID"),
  ]
}

extension Sync_Contact.SyncState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INITIAL"),
    1: .same(proto: "IMPORTED"),
    2: .same(proto: "CUSTOM"),
  ]
}

extension Sync_Contact.ReadReceiptPolicyOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_Contact.protoMessageName + ".ReadReceiptPolicyOverride"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "default"),
    2: .same(proto: "policy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.override {
          hadOneofValue = true
          if case .default(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.override = .default(v)
        }
      }()
      case 2: try {
        var v: Sync_ReadReceiptPolicy?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.override != nil {try decoder.handleConflictingOneOf()}
          self.override = .policy(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.override {
    case .default?: try {
      guard case .default(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .policy?: try {
      guard case .policy(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Contact.ReadReceiptPolicyOverride, rhs: Sync_Contact.ReadReceiptPolicyOverride) -> Bool {
    if lhs.override != rhs.override {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Contact.TypingIndicatorPolicyOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_Contact.protoMessageName + ".TypingIndicatorPolicyOverride"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "default"),
    2: .same(proto: "policy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.override {
          hadOneofValue = true
          if case .default(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.override = .default(v)
        }
      }()
      case 2: try {
        var v: Sync_TypingIndicatorPolicy?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.override != nil {try decoder.handleConflictingOneOf()}
          self.override = .policy(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.override {
    case .default?: try {
      guard case .default(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .policy?: try {
      guard case .policy(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Contact.TypingIndicatorPolicyOverride, rhs: Sync_Contact.TypingIndicatorPolicyOverride) -> Bool {
    if lhs.override != rhs.override {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Contact.NotificationTriggerPolicyOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_Contact.protoMessageName + ".NotificationTriggerPolicyOverride"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "default"),
    2: .same(proto: "policy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.override {
          hadOneofValue = true
          if case .default(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.override = .default(v)
        }
      }()
      case 2: try {
        var v: Sync_Contact.NotificationTriggerPolicyOverride.Policy?
        var hadOneofValue = false
        if let current = self.override {
          hadOneofValue = true
          if case .policy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.override = .policy(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.override {
    case .default?: try {
      guard case .default(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .policy?: try {
      guard case .policy(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Contact.NotificationTriggerPolicyOverride, rhs: Sync_Contact.NotificationTriggerPolicyOverride) -> Bool {
    if lhs.override != rhs.override {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Contact.NotificationTriggerPolicyOverride.Policy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_Contact.NotificationTriggerPolicyOverride.protoMessageName + ".Policy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "policy"),
    2: .standard(proto: "expires_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.policy) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._expiresAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.policy != .never {
      try visitor.visitSingularEnumField(value: self.policy, fieldNumber: 1)
    }
    try { if let v = self._expiresAt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Contact.NotificationTriggerPolicyOverride.Policy, rhs: Sync_Contact.NotificationTriggerPolicyOverride.Policy) -> Bool {
    if lhs.policy != rhs.policy {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Contact.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NEVER"),
  ]
}

extension Sync_Contact.NotificationSoundPolicyOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_Contact.protoMessageName + ".NotificationSoundPolicyOverride"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "default"),
    2: .same(proto: "policy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.override {
          hadOneofValue = true
          if case .default(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.override = .default(v)
        }
      }()
      case 2: try {
        var v: Sync_NotificationSoundPolicy?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.override != nil {try decoder.handleConflictingOneOf()}
          self.override = .policy(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.override {
    case .default?: try {
      guard case .default(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .policy?: try {
      guard case .policy(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Contact.NotificationSoundPolicyOverride, rhs: Sync_Contact.NotificationSoundPolicyOverride) -> Bool {
    if lhs.override != rhs.override {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Group"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_identity"),
    2: .same(proto: "name"),
    3: .standard(proto: "created_at"),
    6: .standard(proto: "user_state"),
    9: .standard(proto: "notification_trigger_policy_override"),
    10: .standard(proto: "notification_sound_policy_override"),
    7: .standard(proto: "profile_picture"),
    8: .standard(proto: "member_identities"),
    4: .standard(proto: "conversation_category"),
    5: .standard(proto: "conversation_visibility"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groupIdentity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._conversationCategory) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._conversationVisibility) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._userState) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._profilePicture) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._memberIdentities) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._notificationTriggerPolicyOverride) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._notificationSoundPolicyOverride) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groupIdentity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._conversationCategory {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._conversationVisibility {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._userState {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._profilePicture {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._memberIdentities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._notificationTriggerPolicyOverride {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._notificationSoundPolicyOverride {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Group, rhs: Sync_Group) -> Bool {
    if lhs._groupIdentity != rhs._groupIdentity {return false}
    if lhs._name != rhs._name {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._userState != rhs._userState {return false}
    if lhs._notificationTriggerPolicyOverride != rhs._notificationTriggerPolicyOverride {return false}
    if lhs._notificationSoundPolicyOverride != rhs._notificationSoundPolicyOverride {return false}
    if lhs._profilePicture != rhs._profilePicture {return false}
    if lhs._memberIdentities != rhs._memberIdentities {return false}
    if lhs._conversationCategory != rhs._conversationCategory {return false}
    if lhs._conversationVisibility != rhs._conversationVisibility {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Group.UserState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEMBER"),
    1: .same(proto: "KICKED"),
    2: .same(proto: "LEFT"),
  ]
}

extension Sync_Group.NotificationTriggerPolicyOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_Group.protoMessageName + ".NotificationTriggerPolicyOverride"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "default"),
    2: .same(proto: "policy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.override {
          hadOneofValue = true
          if case .default(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.override = .default(v)
        }
      }()
      case 2: try {
        var v: Sync_Group.NotificationTriggerPolicyOverride.Policy?
        var hadOneofValue = false
        if let current = self.override {
          hadOneofValue = true
          if case .policy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.override = .policy(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.override {
    case .default?: try {
      guard case .default(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .policy?: try {
      guard case .policy(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Group.NotificationTriggerPolicyOverride, rhs: Sync_Group.NotificationTriggerPolicyOverride) -> Bool {
    if lhs.override != rhs.override {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Group.NotificationTriggerPolicyOverride.Policy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_Group.NotificationTriggerPolicyOverride.protoMessageName + ".Policy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "policy"),
    2: .standard(proto: "expires_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.policy) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._expiresAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.policy != .mentioned {
      try visitor.visitSingularEnumField(value: self.policy, fieldNumber: 1)
    }
    try { if let v = self._expiresAt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Group.NotificationTriggerPolicyOverride.Policy, rhs: Sync_Group.NotificationTriggerPolicyOverride.Policy) -> Bool {
    if lhs.policy != rhs.policy {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Group.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MENTIONED"),
    1: .same(proto: "NEVER"),
  ]
}

extension Sync_Group.NotificationSoundPolicyOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_Group.protoMessageName + ".NotificationSoundPolicyOverride"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "default"),
    2: .same(proto: "policy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.override {
          hadOneofValue = true
          if case .default(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.override = .default(v)
        }
      }()
      case 2: try {
        var v: Sync_NotificationSoundPolicy?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.override != nil {try decoder.handleConflictingOneOf()}
          self.override = .policy(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.override {
    case .default?: try {
      guard case .default(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .policy?: try {
      guard case .policy(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Group.NotificationSoundPolicyOverride, rhs: Sync_Group.NotificationSoundPolicyOverride) -> Bool {
    if lhs.override != rhs.override {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_DistributionList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DistributionList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "distribution_list_id"),
    2: .same(proto: "name"),
    3: .standard(proto: "created_at"),
    6: .standard(proto: "member_identities"),
    4: .standard(proto: "conversation_category"),
    5: .standard(proto: "conversation_visibility"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.distributionListID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._conversationCategory) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._conversationVisibility) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._memberIdentities) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.distributionListID != 0 {
      try visitor.visitSingularFixed64Field(value: self.distributionListID, fieldNumber: 1)
    }
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._conversationCategory {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._conversationVisibility {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._memberIdentities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_DistributionList, rhs: Sync_DistributionList) -> Bool {
    if lhs.distributionListID != rhs.distributionListID {return false}
    if lhs._name != rhs._name {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._memberIdentities != rhs._memberIdentities {return false}
    if lhs._conversationCategory != rhs._conversationCategory {return false}
    if lhs._conversationVisibility != rhs._conversationVisibility {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Settings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Settings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contact_sync_policy"),
    2: .standard(proto: "unknown_contact_policy"),
    3: .standard(proto: "read_receipt_policy"),
    4: .standard(proto: "typing_indicator_policy"),
    5: .standard(proto: "o2o_call_policy"),
    6: .standard(proto: "o2o_call_connection_policy"),
    12: .standard(proto: "o2o_call_video_policy"),
    11: .standard(proto: "group_call_policy"),
    7: .standard(proto: "screenshot_policy"),
    8: .standard(proto: "keyboard_data_collection_policy"),
    9: .standard(proto: "blocked_identities"),
    10: .standard(proto: "exclude_from_sync_identities"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._contactSyncPolicy) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._unknownContactPolicy) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._readReceiptPolicy) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._typingIndicatorPolicy) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._o2OCallPolicy) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._o2OCallConnectionPolicy) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._screenshotPolicy) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self._keyboardDataCollectionPolicy) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._blockedIdentities) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._excludeFromSyncIdentities) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self._groupCallPolicy) }()
      case 12: try { try decoder.decodeSingularEnumField(value: &self._o2OCallVideoPolicy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contactSyncPolicy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._unknownContactPolicy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._readReceiptPolicy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._typingIndicatorPolicy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._o2OCallPolicy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._o2OCallConnectionPolicy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._screenshotPolicy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._keyboardDataCollectionPolicy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._blockedIdentities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._excludeFromSyncIdentities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._groupCallPolicy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._o2OCallVideoPolicy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Settings, rhs: Sync_Settings) -> Bool {
    if lhs._contactSyncPolicy != rhs._contactSyncPolicy {return false}
    if lhs._unknownContactPolicy != rhs._unknownContactPolicy {return false}
    if lhs._readReceiptPolicy != rhs._readReceiptPolicy {return false}
    if lhs._typingIndicatorPolicy != rhs._typingIndicatorPolicy {return false}
    if lhs._o2OCallPolicy != rhs._o2OCallPolicy {return false}
    if lhs._o2OCallConnectionPolicy != rhs._o2OCallConnectionPolicy {return false}
    if lhs._o2OCallVideoPolicy != rhs._o2OCallVideoPolicy {return false}
    if lhs._groupCallPolicy != rhs._groupCallPolicy {return false}
    if lhs._screenshotPolicy != rhs._screenshotPolicy {return false}
    if lhs._keyboardDataCollectionPolicy != rhs._keyboardDataCollectionPolicy {return false}
    if lhs._blockedIdentities != rhs._blockedIdentities {return false}
    if lhs._excludeFromSyncIdentities != rhs._excludeFromSyncIdentities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Settings.ContactSyncPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_SYNCED"),
    1: .same(proto: "SYNC"),
  ]
}

extension Sync_Settings.UnknownContactPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_UNKNOWN"),
    1: .same(proto: "BLOCK_UNKNOWN"),
  ]
}

extension Sync_Settings.O2oCallPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_O2O_CALL"),
    1: .same(proto: "DENY_O2O_CALL"),
  ]
}

extension Sync_Settings.O2oCallConnectionPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_DIRECT_CONNECTION"),
    1: .same(proto: "REQUIRE_RELAYED_CONNECTION"),
  ]
}

extension Sync_Settings.O2oCallVideoPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_VIDEO"),
    1: .same(proto: "DENY_VIDEO"),
  ]
}

extension Sync_Settings.GroupCallPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_GROUP_CALL"),
    1: .same(proto: "DENY_GROUP_CALL"),
  ]
}

extension Sync_Settings.ScreenshotPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_SCREENSHOT"),
    1: .same(proto: "DENY_SCREENSHOT"),
  ]
}

extension Sync_Settings.KeyboardDataCollectionPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_DATA_COLLECTION"),
    1: .same(proto: "DENY_DATA_COLLECTION"),
  ]
}
