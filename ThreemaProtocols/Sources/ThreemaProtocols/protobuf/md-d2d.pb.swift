// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: md-d2d.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// ## Device to Device Protocol
//
// ### General Information
//
// **Encryption cipher:** XSalsa20-Poly1305, unless otherwise specified.
//
// All strings are UTF-8 encoded.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// D2D protocol versions.
///
/// Note 1: The most significant byte is the major version and the least
/// significant byte is the minor version.
///
/// Note 2: Once the D2D protocol is more stable, an unknown major version can be
/// interpreted as incompatible. For now, we only have 0.X versions that define
/// in which way they break compatibility.
public enum D2d_ProtocolVersion: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// The version is unspecified.
  case unspecified // = 0

  /// V0.1
  ///
  /// Devices using this version use the opportunistic (but problematic) group
  /// sync mechanism via pure CSP reflection. D2D group sync reflection was
  /// totally underspecified but is partially supported on the receiving side.
  case v01 // = 1

  /// V0.2
  ///
  /// Builds on V0.1 with backwards compatibility to V0.1. Devices using this
  /// version use the explicit group sync mechanism via D2D sync reflection.
  ///
  /// Upon reception, V0.2 devices detecting a reflected message will switch over
  /// the version, and:
  ///
  /// - for V0.1 in combination with a CSP group message, fall back to the
  ///   backwards compatibility mode and update the group according to the
  ///   message.
  /// - for V0.2+ in combination with a CSP group message, ignore it.
  case v02 // = 2

  /// V0.3
  ///
  /// Builds on V0.2 but removes the backwards compatibility to V0.1.
  ///
  /// Upon reception, V0.2 devices detecting a reflected message will switch over
  /// the version, and:
  ///
  /// - for V0.1 in combination with a CSP group message, spit out a warning that
  ///   the group is going to desync.
  /// - for V0.2+ in combination with a CSP group message, ignore it.
  case v03 // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .v01
    case 2: self = .v02
    case 3: self = .v03
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .v01: return 1
    case .v02: return 2
    case .v03: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [D2d_ProtocolVersion] = [
    .unspecified,
    .v01,
    .v02,
    .v03,
  ]

}

/// Data shared across all devices and transmitted during the handshake.
public struct D2d_SharedDeviceData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Random amount of padding, ignored by the receiver
  public var padding: Data = Data()

  /// Current lowest protocol version that must be supported by all devices
  public var version: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Metadata about a device, determined by the device itself.
public struct D2d_DeviceInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Random amount of padding, ignored by the receiver
  public var padding: Data = Data()

  public var platform: D2d_DeviceInfo.Platform = .unspecified

  /// Platform details (smartphone model / browser), e.g. "Firefox 91.0.2" or
  /// "iPhone 11 Pro"
  public var platformDetails: String = String()

  /// App version, e.g. "4.52" (Android) or "4.6.12b2653" (iOS)
  public var appVersion: String = String()

  /// User defined device label (e.g. "PC at Work"), may be empty if not set.
  /// Recommended to not not exceed 64 grapheme clusters.
  public var label: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Platform
  public enum Platform: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Unknown platform
    case unspecified // = 0

    /// Android
    case android // = 1

    /// Apple iOS
    case ios // = 2

    /// Desktop application
    case desktop // = 3

    /// Web application
    case web // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .android
      case 2: self = .ios
      case 3: self = .desktop
      case 4: self = .web
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .android: return 1
      case .ios: return 2
      case .desktop: return 3
      case .web: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [D2d_DeviceInfo.Platform] = [
      .unspecified,
      .android,
      .ios,
      .desktop,
      .web,
    ]

  }

  public init() {}
}

/// A transaction scope. Used in the d2m transaction messages.
public struct D2d_TransactionScope: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var scope: D2d_TransactionScope.Scope = .userProfileSync

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Scope: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case userProfileSync // = 0
    case contactSync // = 1
    case groupSync // = 2
    case distributionListSync // = 3
    case settingsSync // = 4
    case mdmParameterSync // = 5
    case newDeviceSync // = 6
    case dropDevice // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .userProfileSync
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .userProfileSync
      case 1: self = .contactSync
      case 2: self = .groupSync
      case 3: self = .distributionListSync
      case 4: self = .settingsSync
      case 5: self = .mdmParameterSync
      case 6: self = .newDeviceSync
      case 7: self = .dropDevice
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .userProfileSync: return 0
      case .contactSync: return 1
      case .groupSync: return 2
      case .distributionListSync: return 3
      case .settingsSync: return 4
      case .mdmParameterSync: return 5
      case .newDeviceSync: return 6
      case .dropDevice: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [D2d_TransactionScope.Scope] = [
      .userProfileSync,
      .contactSync,
      .groupSync,
      .distributionListSync,
      .settingsSync,
      .mdmParameterSync,
      .newDeviceSync,
      .dropDevice,
    ]

  }

  public init() {}
}

/// Root message
public struct D2d_Envelope: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Random amount of padding, ignored by the receiver
  public var padding: Data {
    get {return _storage._padding}
    set {_uniqueStorage()._padding = newValue}
  }

  /// Sender device id
  public var deviceID: UInt64 {
    get {return _storage._deviceID}
    set {_uniqueStorage()._deviceID = newValue}
  }

  /// D2D (`ProtocolVersion`) the device used when it sent this message.
  ///
  /// If `0`, assume V0.1 (`0x0001`).
  public var protocolVersion: UInt32 {
    get {return _storage._protocolVersion}
    set {_uniqueStorage()._protocolVersion = newValue}
  }

  /// The enveloped reflected message
  public var content: OneOf_Content? {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  public var outgoingMessage: D2d_OutgoingMessage {
    get {
      if case .outgoingMessage(let v)? = _storage._content {return v}
      return D2d_OutgoingMessage()
    }
    set {_uniqueStorage()._content = .outgoingMessage(newValue)}
  }

  public var outgoingMessageUpdate: D2d_OutgoingMessageUpdate {
    get {
      if case .outgoingMessageUpdate(let v)? = _storage._content {return v}
      return D2d_OutgoingMessageUpdate()
    }
    set {_uniqueStorage()._content = .outgoingMessageUpdate(newValue)}
  }

  public var incomingMessage: D2d_IncomingMessage {
    get {
      if case .incomingMessage(let v)? = _storage._content {return v}
      return D2d_IncomingMessage()
    }
    set {_uniqueStorage()._content = .incomingMessage(newValue)}
  }

  public var incomingMessageUpdate: D2d_IncomingMessageUpdate {
    get {
      if case .incomingMessageUpdate(let v)? = _storage._content {return v}
      return D2d_IncomingMessageUpdate()
    }
    set {_uniqueStorage()._content = .incomingMessageUpdate(newValue)}
  }

  public var userProfileSync: D2d_UserProfileSync {
    get {
      if case .userProfileSync(let v)? = _storage._content {return v}
      return D2d_UserProfileSync()
    }
    set {_uniqueStorage()._content = .userProfileSync(newValue)}
  }

  public var contactSync: D2d_ContactSync {
    get {
      if case .contactSync(let v)? = _storage._content {return v}
      return D2d_ContactSync()
    }
    set {_uniqueStorage()._content = .contactSync(newValue)}
  }

  public var groupSync: D2d_GroupSync {
    get {
      if case .groupSync(let v)? = _storage._content {return v}
      return D2d_GroupSync()
    }
    set {_uniqueStorage()._content = .groupSync(newValue)}
  }

  public var distributionListSync: D2d_DistributionListSync {
    get {
      if case .distributionListSync(let v)? = _storage._content {return v}
      return D2d_DistributionListSync()
    }
    set {_uniqueStorage()._content = .distributionListSync(newValue)}
  }

  public var settingsSync: D2d_SettingsSync {
    get {
      if case .settingsSync(let v)? = _storage._content {return v}
      return D2d_SettingsSync()
    }
    set {_uniqueStorage()._content = .settingsSync(newValue)}
  }

  public var mdmParameterSync: D2d_MdmParameterSync {
    get {
      if case .mdmParameterSync(let v)? = _storage._content {return v}
      return D2d_MdmParameterSync()
    }
    set {_uniqueStorage()._content = .mdmParameterSync(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The enveloped reflected message
  public enum OneOf_Content: Equatable, Sendable {
    case outgoingMessage(D2d_OutgoingMessage)
    case outgoingMessageUpdate(D2d_OutgoingMessageUpdate)
    case incomingMessage(D2d_IncomingMessage)
    case incomingMessageUpdate(D2d_IncomingMessageUpdate)
    case userProfileSync(D2d_UserProfileSync)
    case contactSync(D2d_ContactSync)
    case groupSync(D2d_GroupSync)
    case distributionListSync(D2d_DistributionListSync)
    case settingsSync(D2d_SettingsSync)
    case mdmParameterSync(D2d_MdmParameterSync)

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Unique conversation identifier.
public struct D2d_ConversationId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A contact's Threema ID, distribution list ID or group identity to identify
  /// the conversation.
  public var id: D2d_ConversationId.OneOf_ID? = nil

  public var contact: String {
    get {
      if case .contact(let v)? = id {return v}
      return String()
    }
    set {id = .contact(newValue)}
  }

  public var distributionList: UInt64 {
    get {
      if case .distributionList(let v)? = id {return v}
      return 0
    }
    set {id = .distributionList(newValue)}
  }

  public var group: Common_GroupIdentity {
    get {
      if case .group(let v)? = id {return v}
      return Common_GroupIdentity()
    }
    set {id = .group(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A contact's Threema ID, distribution list ID or group identity to identify
  /// the conversation.
  public enum OneOf_ID: Equatable, Sendable {
    case contact(String)
    case distributionList(UInt64)
    case group(Common_GroupIdentity)

  }

  public init() {}
}

/// An outgoing message, reflected to other devices.
///
/// When sending this message:
///
/// 1. [...]
/// 2. Set `nonces` to the nonces of the associated CSP
///    `e2e.message-with-metadata` (or `e2e.legacy-message`) messages that
///    contained the `body` in encrypted form.¹
///
/// When receiving this message:
///
/// 1. Add all `nonces` to the CSP nonce storage (discarding any nonces that
///    already exist in the nonce storage).
/// 2. If a message with the same `message_id` exists within the associated
///    `conversation`, discard the message and abort these steps.
/// 3. [...]
///
/// ¹: For contacts and distribution lists, there will be exactly one nonce. For
/// groups, there will be as many nonces as there are group members minus one.
public struct D2d_OutgoingMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Conversation ID of the enclosed message.
  ///
  /// Note: If the conversation is of type group, group and group creator id of
  /// the enclosed CSP E2E message must match the values of the supplied group
  /// identity. Otherwise, the message must be considered invalid.
  public var conversation: D2d_ConversationId {
    get {return _conversation ?? D2d_ConversationId()}
    set {_conversation = newValue}
  }
  /// Returns true if `conversation` has been explicitly set.
  public var hasConversation: Bool {return self._conversation != nil}
  /// Clears the value of `conversation`. Subsequent reads from it will return its default value.
  public mutating func clearConversation() {self._conversation = nil}

  /// Unique ID of the enclosed message
  public var messageID: UInt64 = 0

  /// Optional thread message ID (the message ID of the last incoming message in
  /// the current conversation)
  public var threadMessageID: UInt64 {
    get {return _threadMessageID ?? 0}
    set {_threadMessageID = newValue}
  }
  /// Returns true if `threadMessageID` has been explicitly set.
  public var hasThreadMessageID: Bool {return self._threadMessageID != nil}
  /// Clears the value of `threadMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearThreadMessageID() {self._threadMessageID = nil}

  /// Unix-ish timestamp in milliseconds for when the enclosed message has been
  /// created
  ///
  /// Note: Take this value from the
  /// `csp.payload.legacy-message`/`csp.payload.message-with-metadata-box` that
  /// enclosed the message.
  public var createdAt: UInt64 = 0

  /// Enclosed message's type
  public var type: Common_CspE2eMessageType = .invalidType

  /// The message's body, i.e. the unpadded `csp.e2e.container.padded-data`
  public var body: Data = Data()

  /// Nonces the message was encrypted with towards each receiver (the shared
  /// secret derived from the long-term keys).
  ///
  /// Optional for now, always required in a future version.
  public var nonces: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _conversation: D2d_ConversationId? = nil
  fileprivate var _threadMessageID: UInt64? = nil
}

/// Update one or more existing outgoing messages.
public struct D2d_OutgoingMessageUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Updates
  public var updates: [D2d_OutgoingMessageUpdate.Update] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Mark the referred message as sent (acknowledged by the chat server).
  ///
  /// Note 1: The timestamp of the `reflect-ack`/`reflected` message determines
  /// the timestamp for when the referred message has been sent.
  ///
  /// Note 2: This indicates that the referred message has been successfully
  /// stored in the message queue of the server. It does NOT indicate that the
  /// referred message has been delivered to the intended receiver.
  public struct Sent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Update: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Conversation ID of the referred message.
    public var conversation: D2d_ConversationId {
      get {return _conversation ?? D2d_ConversationId()}
      set {_conversation = newValue}
    }
    /// Returns true if `conversation` has been explicitly set.
    public var hasConversation: Bool {return self._conversation != nil}
    /// Clears the value of `conversation`. Subsequent reads from it will return its default value.
    public mutating func clearConversation() {self._conversation = nil}

    /// Unique ID of the referred message
    public var messageID: UInt64 = 0

    /// Update type
    public var update: D2d_OutgoingMessageUpdate.Update.OneOf_Update? = nil

    /// Mark the referred message as sent
    public var sent: D2d_OutgoingMessageUpdate.Sent {
      get {
        if case .sent(let v)? = update {return v}
        return D2d_OutgoingMessageUpdate.Sent()
      }
      set {update = .sent(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Update type
    public enum OneOf_Update: Equatable, Sendable {
      /// Mark the referred message as sent
      case sent(D2d_OutgoingMessageUpdate.Sent)

    }

    public init() {}

    fileprivate var _conversation: D2d_ConversationId? = nil
  }

  public init() {}
}

/// An incoming message, reflected to other devices.
///
///
/// When sending this message:
///
/// 1. [...]
/// 2. Set `nonce` to the nonce of `e2e.message-with-metadata` (or
///    `e2e.legacy-message`) that contained the `body` in encrypted form.
///
/// When receiving this message:
///
/// 1. Add `nonce` to the CSP nonce storage (discard a nonces that already exist
///    in the nonce storage).
/// 2. If a message with the same `message_id` exists within the associated
///    `conversation`, discard the message and abort these steps.
/// 3. [...]
public struct D2d_IncomingMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sender's Threema ID
  public var senderIdentity: String = String()

  /// Unique ID of the enclosed message
  public var messageID: UInt64 = 0

  /// Unix-ish timestamp in milliseconds for when the enclosed message has been
  /// created.
  ///
  /// Note: Take this value from the
  /// `csp.payload.legacy-message`/`csp.payload.message-with-metadata-box` that
  /// enclosed the message.
  public var createdAt: UInt64 = 0

  /// Enclosed message's type.
  public var type: Common_CspE2eMessageType = .invalidType

  /// The message's body, i.e. the unpadded `csp.e2e.container.padded-data`
  public var body: Data = Data()

  /// Nonce the message was encrypted with by the sender (the shared secret
  /// derived from the long-term keys).
  ///
  /// Optional for now, always required in a future version.
  public var nonce: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Update one or more existing incoming messages.
public struct D2d_IncomingMessageUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Updates
  public var updates: [D2d_IncomingMessageUpdate.Update] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Mark the referred message as read.
  ///
  /// Note: This may only be used when _read receipts_ have been turned off, i.e.
  /// as a replacement for reflecting `delivery-receipt` type _read_ (`0x02`).
  public struct Read: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Unix-ish timestamp in milliseconds for when the referred message has been
    /// read.
    public var at: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Update: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Conversation ID of the referred message.
    public var conversation: D2d_ConversationId {
      get {return _conversation ?? D2d_ConversationId()}
      set {_conversation = newValue}
    }
    /// Returns true if `conversation` has been explicitly set.
    public var hasConversation: Bool {return self._conversation != nil}
    /// Clears the value of `conversation`. Subsequent reads from it will return its default value.
    public mutating func clearConversation() {self._conversation = nil}

    /// Unique ID of the referred message
    public var messageID: UInt64 = 0

    /// Update type
    public var update: D2d_IncomingMessageUpdate.Update.OneOf_Update? = nil

    /// Mark the referred message as read
    public var read: D2d_IncomingMessageUpdate.Read {
      get {
        if case .read(let v)? = update {return v}
        return D2d_IncomingMessageUpdate.Read()
      }
      set {update = .read(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Update type
    public enum OneOf_Update: Equatable, Sendable {
      /// Mark the referred message as read
      case read(D2d_IncomingMessageUpdate.Read)

    }

    public init() {}

    fileprivate var _conversation: D2d_ConversationId? = nil
  }

  public init() {}
}

/// User profile synchronisation message.
public struct D2d_UserProfileSync: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Synchronisation type
  public var action: D2d_UserProfileSync.OneOf_Action? = nil

  public var update: D2d_UserProfileSync.Update {
    get {
      if case .update(let v)? = action {return v}
      return D2d_UserProfileSync.Update()
    }
    set {action = .update(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Synchronisation type
  public enum OneOf_Action: Equatable, Sendable {
    case update(D2d_UserProfileSync.Update)

  }

  /// Update the user's profile
  public struct Update: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var userProfile: Sync_UserProfile {
      get {return _userProfile ?? Sync_UserProfile()}
      set {_userProfile = newValue}
    }
    /// Returns true if `userProfile` has been explicitly set.
    public var hasUserProfile: Bool {return self._userProfile != nil}
    /// Clears the value of `userProfile`. Subsequent reads from it will return its default value.
    public mutating func clearUserProfile() {self._userProfile = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _userProfile: Sync_UserProfile? = nil
  }

  public init() {}
}

/// Contact synchronisation message.
public struct D2d_ContactSync: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Synchronisation type
  public var action: D2d_ContactSync.OneOf_Action? = nil

  /// Create a Threema contact
  public var create: D2d_ContactSync.Create {
    get {
      if case .create(let v)? = action {return v}
      return D2d_ContactSync.Create()
    }
    set {action = .create(newValue)}
  }

  /// Update a Threema contact
  public var update: D2d_ContactSync.Update {
    get {
      if case .update(let v)? = action {return v}
      return D2d_ContactSync.Update()
    }
    set {action = .update(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Synchronisation type
  public enum OneOf_Action: Equatable, Sendable {
    /// Create a Threema contact
    case create(D2d_ContactSync.Create)
    /// Update a Threema contact
    case update(D2d_ContactSync.Update)

  }

  /// Create a Threema contact.
  public struct Create: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var contact: Sync_Contact {
      get {return _contact ?? Sync_Contact()}
      set {_contact = newValue}
    }
    /// Returns true if `contact` has been explicitly set.
    public var hasContact: Bool {return self._contact != nil}
    /// Clears the value of `contact`. Subsequent reads from it will return its default value.
    public mutating func clearContact() {self._contact = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _contact: Sync_Contact? = nil
  }

  /// Update a Threema contact.
  public struct Update: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var contact: Sync_Contact {
      get {return _contact ?? Sync_Contact()}
      set {_contact = newValue}
    }
    /// Returns true if `contact` has been explicitly set.
    public var hasContact: Bool {return self._contact != nil}
    /// Clears the value of `contact`. Subsequent reads from it will return its default value.
    public mutating func clearContact() {self._contact = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _contact: Sync_Contact? = nil
  }

  public init() {}
}

/// Group synchronisation message.
public struct D2d_GroupSync: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Synchronisation type
  public var action: D2d_GroupSync.OneOf_Action? = nil

  /// Create a group
  public var create: D2d_GroupSync.Create {
    get {
      if case .create(let v)? = action {return v}
      return D2d_GroupSync.Create()
    }
    set {action = .create(newValue)}
  }

  /// Update a group
  public var update: D2d_GroupSync.Update {
    get {
      if case .update(let v)? = action {return v}
      return D2d_GroupSync.Update()
    }
    set {action = .update(newValue)}
  }

  /// Delete a group
  public var delete: D2d_GroupSync.Delete {
    get {
      if case .delete(let v)? = action {return v}
      return D2d_GroupSync.Delete()
    }
    set {action = .delete(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Synchronisation type
  public enum OneOf_Action: Equatable, Sendable {
    /// Create a group
    case create(D2d_GroupSync.Create)
    /// Update a group
    case update(D2d_GroupSync.Update)
    /// Delete a group
    case delete(D2d_GroupSync.Delete)

  }

  /// Create a group.
  public struct Create: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var group: Sync_Group {
      get {return _group ?? Sync_Group()}
      set {_group = newValue}
    }
    /// Returns true if `group` has been explicitly set.
    public var hasGroup: Bool {return self._group != nil}
    /// Clears the value of `group`. Subsequent reads from it will return its default value.
    public mutating func clearGroup() {self._group = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _group: Sync_Group? = nil
  }

  /// Update a group.
  ///
  /// When receiving this variant:
  ///
  /// 1. Let `current` be a snapshot of the current group state.
  /// 2. Persist the update to the group.
  /// 3. Let `member-changes` be an empty list.
  /// 4. For each `identity`, `state-change` pair of `member_state_changes`:
  ///    1. If `state-change` is `ADDED` and `identity` does not exist in
  ///       `current.members`, add the tuple `identity`, `state-change` to
  ///       `member-changes`.
  ///    2. If `state-change` is `KICKED` or `LEFT` and `identity` does exist in
  ///       `current.members`, add the tuple `identity`, `state-change` to
  ///       `member-changes`.
  /// 5. Group `member-changes` by their associated `state-change` and add
  ///    appropriate status messages to the associated conversation.
  public struct Update: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var group: Sync_Group {
      get {return _storage._group ?? Sync_Group()}
      set {_uniqueStorage()._group = newValue}
    }
    /// Returns true if `group` has been explicitly set.
    public var hasGroup: Bool {return _storage._group != nil}
    /// Clears the value of `group`. Subsequent reads from it will return its default value.
    public mutating func clearGroup() {_uniqueStorage()._group = nil}

    /// A map of the member identity string to the member state change.
    public var memberStateChanges: Dictionary<String,D2d_GroupSync.Update.MemberStateChange> {
      get {return _storage._memberStateChanges}
      set {_uniqueStorage()._memberStateChanges = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum MemberStateChange: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// The member has been added
      case added // = 0

      /// The member has been kicked from the group.
      case kicked // = 1

      /// The member left the group.
      case left // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .added
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .added
        case 1: self = .kicked
        case 2: self = .left
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .added: return 0
        case .kicked: return 1
        case .left: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [D2d_GroupSync.Update.MemberStateChange] = [
        .added,
        .kicked,
        .left,
      ]

    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Delete a group.
  public struct Delete: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Unique group identity
    public var groupIdentity: Common_GroupIdentity {
      get {return _groupIdentity ?? Common_GroupIdentity()}
      set {_groupIdentity = newValue}
    }
    /// Returns true if `groupIdentity` has been explicitly set.
    public var hasGroupIdentity: Bool {return self._groupIdentity != nil}
    /// Clears the value of `groupIdentity`. Subsequent reads from it will return its default value.
    public mutating func clearGroupIdentity() {self._groupIdentity = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _groupIdentity: Common_GroupIdentity? = nil
  }

  public init() {}
}

/// Distribution list synchronisation message.
public struct D2d_DistributionListSync: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Synchronisation type
  public var action: D2d_DistributionListSync.OneOf_Action? = nil

  /// Create a distribution list
  public var create: D2d_DistributionListSync.Create {
    get {
      if case .create(let v)? = action {return v}
      return D2d_DistributionListSync.Create()
    }
    set {action = .create(newValue)}
  }

  /// Update a distribution list
  public var update: D2d_DistributionListSync.Update {
    get {
      if case .update(let v)? = action {return v}
      return D2d_DistributionListSync.Update()
    }
    set {action = .update(newValue)}
  }

  /// Delete a distribution list
  public var delete: D2d_DistributionListSync.Delete {
    get {
      if case .delete(let v)? = action {return v}
      return D2d_DistributionListSync.Delete()
    }
    set {action = .delete(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Synchronisation type
  public enum OneOf_Action: Equatable, Sendable {
    /// Create a distribution list
    case create(D2d_DistributionListSync.Create)
    /// Update a distribution list
    case update(D2d_DistributionListSync.Update)
    /// Delete a distribution list
    case delete(D2d_DistributionListSync.Delete)

  }

  /// Create a distribution list.
  public struct Create: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var distributionList: Sync_DistributionList {
      get {return _distributionList ?? Sync_DistributionList()}
      set {_distributionList = newValue}
    }
    /// Returns true if `distributionList` has been explicitly set.
    public var hasDistributionList: Bool {return self._distributionList != nil}
    /// Clears the value of `distributionList`. Subsequent reads from it will return its default value.
    public mutating func clearDistributionList() {self._distributionList = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _distributionList: Sync_DistributionList? = nil
  }

  /// Update a distribution list.
  public struct Update: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var distributionList: Sync_DistributionList {
      get {return _distributionList ?? Sync_DistributionList()}
      set {_distributionList = newValue}
    }
    /// Returns true if `distributionList` has been explicitly set.
    public var hasDistributionList: Bool {return self._distributionList != nil}
    /// Clears the value of `distributionList`. Subsequent reads from it will return its default value.
    public mutating func clearDistributionList() {self._distributionList = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _distributionList: Sync_DistributionList? = nil
  }

  /// Delete a distribution list.
  public struct Delete: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Unique ID of the distribution list
    public var distributionListID: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Settings synchronisation message.
public struct D2d_SettingsSync: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Synchronisation type
  public var action: D2d_SettingsSync.OneOf_Action? = nil

  public var update: D2d_SettingsSync.Update {
    get {
      if case .update(let v)? = action {return v}
      return D2d_SettingsSync.Update()
    }
    set {action = .update(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Synchronisation type
  public enum OneOf_Action: Equatable, Sendable {
    case update(D2d_SettingsSync.Update)

  }

  /// Update settings.
  public struct Update: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var settings: Sync_Settings {
      get {return _settings ?? Sync_Settings()}
      set {_settings = newValue}
    }
    /// Returns true if `settings` has been explicitly set.
    public var hasSettings: Bool {return self._settings != nil}
    /// Clears the value of `settings`. Subsequent reads from it will return its default value.
    public mutating func clearSettings() {self._settings = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _settings: Sync_Settings? = nil
  }

  public init() {}
}

/// MDM parameter synchronisation message.
public struct D2d_MdmParameterSync: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Synchronisation type
  public var action: D2d_MdmParameterSync.OneOf_Action? = nil

  public var update: D2d_MdmParameterSync.Update {
    get {
      if case .update(let v)? = action {return v}
      return D2d_MdmParameterSync.Update()
    }
    set {action = .update(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Synchronisation type
  public enum OneOf_Action: Equatable, Sendable {
    case update(D2d_MdmParameterSync.Update)

  }

  /// Update MDM parameters.
  ///
  /// When receiving this variant, run the _MDM Merge And Apply Steps_.
  public struct Update: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var parameters: Sync_MdmParameters {
      get {return _parameters ?? Sync_MdmParameters()}
      set {_parameters = newValue}
    }
    /// Returns true if `parameters` has been explicitly set.
    public var hasParameters: Bool {return self._parameters != nil}
    /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
    public mutating func clearParameters() {self._parameters = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _parameters: Sync_MdmParameters? = nil
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "d2d"

extension D2d_ProtocolVersion: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "V0_1"),
    2: .same(proto: "V0_2"),
    3: .same(proto: "V0_3"),
  ]
}

extension D2d_SharedDeviceData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SharedDeviceData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "padding"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.padding) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.padding.isEmpty {
      try visitor.visitSingularBytesField(value: self.padding, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_SharedDeviceData, rhs: D2d_SharedDeviceData) -> Bool {
    if lhs.padding != rhs.padding {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_DeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeviceInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "padding"),
    2: .same(proto: "platform"),
    3: .standard(proto: "platform_details"),
    4: .standard(proto: "app_version"),
    5: .same(proto: "label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.padding) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.platform) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.platformDetails) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.appVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.padding.isEmpty {
      try visitor.visitSingularBytesField(value: self.padding, fieldNumber: 1)
    }
    if self.platform != .unspecified {
      try visitor.visitSingularEnumField(value: self.platform, fieldNumber: 2)
    }
    if !self.platformDetails.isEmpty {
      try visitor.visitSingularStringField(value: self.platformDetails, fieldNumber: 3)
    }
    if !self.appVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.appVersion, fieldNumber: 4)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_DeviceInfo, rhs: D2d_DeviceInfo) -> Bool {
    if lhs.padding != rhs.padding {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.platformDetails != rhs.platformDetails {return false}
    if lhs.appVersion != rhs.appVersion {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_DeviceInfo.Platform: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "ANDROID"),
    2: .same(proto: "IOS"),
    3: .same(proto: "DESKTOP"),
    4: .same(proto: "WEB"),
  ]
}

extension D2d_TransactionScope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionScope"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.scope) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.scope != .userProfileSync {
      try visitor.visitSingularEnumField(value: self.scope, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_TransactionScope, rhs: D2d_TransactionScope) -> Bool {
    if lhs.scope != rhs.scope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_TransactionScope.Scope: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "USER_PROFILE_SYNC"),
    1: .same(proto: "CONTACT_SYNC"),
    2: .same(proto: "GROUP_SYNC"),
    3: .same(proto: "DISTRIBUTION_LIST_SYNC"),
    4: .same(proto: "SETTINGS_SYNC"),
    5: .same(proto: "MDM_PARAMETER_SYNC"),
    6: .same(proto: "NEW_DEVICE_SYNC"),
    7: .same(proto: "DROP_DEVICE"),
  ]
}

extension D2d_Envelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Envelope"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "padding"),
    13: .standard(proto: "device_id"),
    3: .standard(proto: "protocol_version"),
    2: .standard(proto: "outgoing_message"),
    10: .standard(proto: "outgoing_message_update"),
    4: .standard(proto: "incoming_message"),
    11: .standard(proto: "incoming_message_update"),
    5: .standard(proto: "user_profile_sync"),
    6: .standard(proto: "contact_sync"),
    7: .standard(proto: "group_sync"),
    8: .standard(proto: "distribution_list_sync"),
    9: .standard(proto: "settings_sync"),
    12: .standard(proto: "mdm_parameter_sync"),
  ]

  fileprivate class _StorageClass {
    var _padding: Data = Data()
    var _deviceID: UInt64 = 0
    var _protocolVersion: UInt32 = 0
    var _content: D2d_Envelope.OneOf_Content?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _padding = source._padding
      _deviceID = source._deviceID
      _protocolVersion = source._protocolVersion
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._padding) }()
        case 2: try {
          var v: D2d_OutgoingMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .outgoingMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .outgoingMessage(v)
          }
        }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._protocolVersion) }()
        case 4: try {
          var v: D2d_IncomingMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .incomingMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .incomingMessage(v)
          }
        }()
        case 5: try {
          var v: D2d_UserProfileSync?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .userProfileSync(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .userProfileSync(v)
          }
        }()
        case 6: try {
          var v: D2d_ContactSync?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .contactSync(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .contactSync(v)
          }
        }()
        case 7: try {
          var v: D2d_GroupSync?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .groupSync(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .groupSync(v)
          }
        }()
        case 8: try {
          var v: D2d_DistributionListSync?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .distributionListSync(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .distributionListSync(v)
          }
        }()
        case 9: try {
          var v: D2d_SettingsSync?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .settingsSync(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .settingsSync(v)
          }
        }()
        case 10: try {
          var v: D2d_OutgoingMessageUpdate?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .outgoingMessageUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .outgoingMessageUpdate(v)
          }
        }()
        case 11: try {
          var v: D2d_IncomingMessageUpdate?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .incomingMessageUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .incomingMessageUpdate(v)
          }
        }()
        case 12: try {
          var v: D2d_MdmParameterSync?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .mdmParameterSync(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .mdmParameterSync(v)
          }
        }()
        case 13: try { try decoder.decodeSingularFixed64Field(value: &_storage._deviceID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._padding.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._padding, fieldNumber: 1)
      }
      try { if case .outgoingMessage(let v)? = _storage._content {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._protocolVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._protocolVersion, fieldNumber: 3)
      }
      switch _storage._content {
      case .incomingMessage?: try {
        guard case .incomingMessage(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .userProfileSync?: try {
        guard case .userProfileSync(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .contactSync?: try {
        guard case .contactSync(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .groupSync?: try {
        guard case .groupSync(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .distributionListSync?: try {
        guard case .distributionListSync(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .settingsSync?: try {
        guard case .settingsSync(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .outgoingMessageUpdate?: try {
        guard case .outgoingMessageUpdate(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .incomingMessageUpdate?: try {
        guard case .incomingMessageUpdate(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .mdmParameterSync?: try {
        guard case .mdmParameterSync(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      default: break
      }
      if _storage._deviceID != 0 {
        try visitor.visitSingularFixed64Field(value: _storage._deviceID, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_Envelope, rhs: D2d_Envelope) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._padding != rhs_storage._padding {return false}
        if _storage._deviceID != rhs_storage._deviceID {return false}
        if _storage._protocolVersion != rhs_storage._protocolVersion {return false}
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_ConversationId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConversationId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contact"),
    2: .standard(proto: "distribution_list"),
    3: .same(proto: "group"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.id != nil {try decoder.handleConflictingOneOf()}
          self.id = .contact(v)
        }
      }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularFixed64Field(value: &v)
        if let v = v {
          if self.id != nil {try decoder.handleConflictingOneOf()}
          self.id = .distributionList(v)
        }
      }()
      case 3: try {
        var v: Common_GroupIdentity?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .group(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .group(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.id {
    case .contact?: try {
      guard case .contact(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .distributionList?: try {
      guard case .distributionList(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 2)
    }()
    case .group?: try {
      guard case .group(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_ConversationId, rhs: D2d_ConversationId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_OutgoingMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutgoingMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conversation"),
    2: .standard(proto: "message_id"),
    6: .standard(proto: "thread_message_id"),
    3: .standard(proto: "created_at"),
    4: .same(proto: "type"),
    5: .same(proto: "body"),
    7: .same(proto: "nonces"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._conversation) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.messageID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.createdAt) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      case 6: try { try decoder.decodeSingularFixed64Field(value: &self._threadMessageID) }()
      case 7: try { try decoder.decodeRepeatedBytesField(value: &self.nonces) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.messageID != 0 {
      try visitor.visitSingularFixed64Field(value: self.messageID, fieldNumber: 2)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 3)
    }
    if self.type != .invalidType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 5)
    }
    try { if let v = self._threadMessageID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 6)
    } }()
    if !self.nonces.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.nonces, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_OutgoingMessage, rhs: D2d_OutgoingMessage) -> Bool {
    if lhs._conversation != rhs._conversation {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs._threadMessageID != rhs._threadMessageID {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.type != rhs.type {return false}
    if lhs.body != rhs.body {return false}
    if lhs.nonces != rhs.nonces {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_OutgoingMessageUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutgoingMessageUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_OutgoingMessageUpdate, rhs: D2d_OutgoingMessageUpdate) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_OutgoingMessageUpdate.Sent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D2d_OutgoingMessageUpdate.protoMessageName + ".Sent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_OutgoingMessageUpdate.Sent, rhs: D2d_OutgoingMessageUpdate.Sent) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_OutgoingMessageUpdate.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D2d_OutgoingMessageUpdate.protoMessageName + ".Update"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conversation"),
    2: .standard(proto: "message_id"),
    3: .same(proto: "sent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._conversation) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.messageID) }()
      case 3: try {
        var v: D2d_OutgoingMessageUpdate.Sent?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .sent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .sent(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.messageID != 0 {
      try visitor.visitSingularFixed64Field(value: self.messageID, fieldNumber: 2)
    }
    try { if case .sent(let v)? = self.update {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_OutgoingMessageUpdate.Update, rhs: D2d_OutgoingMessageUpdate.Update) -> Bool {
    if lhs._conversation != rhs._conversation {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.update != rhs.update {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_IncomingMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IncomingMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [4..<5],
      numberNameMappings: [
        1: .standard(proto: "sender_identity"),
        2: .standard(proto: "message_id"),
        3: .standard(proto: "created_at"),
        5: .same(proto: "type"),
        6: .same(proto: "body"),
        7: .same(proto: "nonce"),
  ])

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.senderIdentity) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.messageID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.createdAt) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.nonce) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.senderIdentity.isEmpty {
      try visitor.visitSingularStringField(value: self.senderIdentity, fieldNumber: 1)
    }
    if self.messageID != 0 {
      try visitor.visitSingularFixed64Field(value: self.messageID, fieldNumber: 2)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 3)
    }
    if self.type != .invalidType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 5)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 6)
    }
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_IncomingMessage, rhs: D2d_IncomingMessage) -> Bool {
    if lhs.senderIdentity != rhs.senderIdentity {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.type != rhs.type {return false}
    if lhs.body != rhs.body {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_IncomingMessageUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IncomingMessageUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_IncomingMessageUpdate, rhs: D2d_IncomingMessageUpdate) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_IncomingMessageUpdate.Read: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D2d_IncomingMessageUpdate.protoMessageName + ".Read"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.at) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.at != 0 {
      try visitor.visitSingularUInt64Field(value: self.at, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_IncomingMessageUpdate.Read, rhs: D2d_IncomingMessageUpdate.Read) -> Bool {
    if lhs.at != rhs.at {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_IncomingMessageUpdate.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D2d_IncomingMessageUpdate.protoMessageName + ".Update"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conversation"),
    2: .standard(proto: "message_id"),
    3: .same(proto: "read"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._conversation) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.messageID) }()
      case 3: try {
        var v: D2d_IncomingMessageUpdate.Read?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .read(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .read(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.messageID != 0 {
      try visitor.visitSingularFixed64Field(value: self.messageID, fieldNumber: 2)
    }
    try { if case .read(let v)? = self.update {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_IncomingMessageUpdate.Update, rhs: D2d_IncomingMessageUpdate.Update) -> Bool {
    if lhs._conversation != rhs._conversation {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.update != rhs.update {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_UserProfileSync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserProfileSync"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "update"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: D2d_UserProfileSync.Update?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .update(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .update(let v)? = self.action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_UserProfileSync, rhs: D2d_UserProfileSync) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_UserProfileSync.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D2d_UserProfileSync.protoMessageName + ".Update"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_profile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userProfile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userProfile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_UserProfileSync.Update, rhs: D2d_UserProfileSync.Update) -> Bool {
    if lhs._userProfile != rhs._userProfile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_ContactSync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContactSync"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "create"),
    2: .same(proto: "update"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: D2d_ContactSync.Create?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .create(v)
        }
      }()
      case 2: try {
        var v: D2d_ContactSync.Update?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .update(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.action {
    case .create?: try {
      guard case .create(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .update?: try {
      guard case .update(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_ContactSync, rhs: D2d_ContactSync) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_ContactSync.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D2d_ContactSync.protoMessageName + ".Create"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contact"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._contact) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contact {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_ContactSync.Create, rhs: D2d_ContactSync.Create) -> Bool {
    if lhs._contact != rhs._contact {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_ContactSync.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D2d_ContactSync.protoMessageName + ".Update"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contact"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._contact) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contact {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_ContactSync.Update, rhs: D2d_ContactSync.Update) -> Bool {
    if lhs._contact != rhs._contact {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_GroupSync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupSync"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "create"),
    2: .same(proto: "update"),
    3: .same(proto: "delete"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: D2d_GroupSync.Create?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .create(v)
        }
      }()
      case 2: try {
        var v: D2d_GroupSync.Update?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .update(v)
        }
      }()
      case 3: try {
        var v: D2d_GroupSync.Delete?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .delete(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.action {
    case .create?: try {
      guard case .create(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .update?: try {
      guard case .update(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_GroupSync, rhs: D2d_GroupSync) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_GroupSync.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D2d_GroupSync.protoMessageName + ".Create"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_GroupSync.Create, rhs: D2d_GroupSync.Create) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_GroupSync.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D2d_GroupSync.protoMessageName + ".Update"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .standard(proto: "member_state_changes"),
  ]

  fileprivate class _StorageClass {
    var _group: Sync_Group? = nil
    var _memberStateChanges: Dictionary<String,D2d_GroupSync.Update.MemberStateChange> = [:]

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _group = source._group
      _memberStateChanges = source._memberStateChanges
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._group) }()
        case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,D2d_GroupSync.Update.MemberStateChange>.self, value: &_storage._memberStateChanges) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._group {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._memberStateChanges.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,D2d_GroupSync.Update.MemberStateChange>.self, value: _storage._memberStateChanges, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_GroupSync.Update, rhs: D2d_GroupSync.Update) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._group != rhs_storage._group {return false}
        if _storage._memberStateChanges != rhs_storage._memberStateChanges {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_GroupSync.Update.MemberStateChange: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADDED"),
    1: .same(proto: "KICKED"),
    2: .same(proto: "LEFT"),
  ]
}

extension D2d_GroupSync.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D2d_GroupSync.protoMessageName + ".Delete"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_identity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groupIdentity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groupIdentity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_GroupSync.Delete, rhs: D2d_GroupSync.Delete) -> Bool {
    if lhs._groupIdentity != rhs._groupIdentity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_DistributionListSync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DistributionListSync"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "create"),
    2: .same(proto: "update"),
    3: .same(proto: "delete"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: D2d_DistributionListSync.Create?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .create(v)
        }
      }()
      case 2: try {
        var v: D2d_DistributionListSync.Update?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .update(v)
        }
      }()
      case 3: try {
        var v: D2d_DistributionListSync.Delete?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .delete(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.action {
    case .create?: try {
      guard case .create(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .update?: try {
      guard case .update(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_DistributionListSync, rhs: D2d_DistributionListSync) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_DistributionListSync.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D2d_DistributionListSync.protoMessageName + ".Create"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "distribution_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._distributionList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._distributionList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_DistributionListSync.Create, rhs: D2d_DistributionListSync.Create) -> Bool {
    if lhs._distributionList != rhs._distributionList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_DistributionListSync.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D2d_DistributionListSync.protoMessageName + ".Update"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "distribution_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._distributionList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._distributionList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_DistributionListSync.Update, rhs: D2d_DistributionListSync.Update) -> Bool {
    if lhs._distributionList != rhs._distributionList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_DistributionListSync.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D2d_DistributionListSync.protoMessageName + ".Delete"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "distribution_list_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.distributionListID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.distributionListID != 0 {
      try visitor.visitSingularFixed64Field(value: self.distributionListID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_DistributionListSync.Delete, rhs: D2d_DistributionListSync.Delete) -> Bool {
    if lhs.distributionListID != rhs.distributionListID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_SettingsSync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SettingsSync"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "update"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: D2d_SettingsSync.Update?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .update(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .update(let v)? = self.action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_SettingsSync, rhs: D2d_SettingsSync) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_SettingsSync.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D2d_SettingsSync.protoMessageName + ".Update"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._settings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._settings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_SettingsSync.Update, rhs: D2d_SettingsSync.Update) -> Bool {
    if lhs._settings != rhs._settings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_MdmParameterSync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MdmParameterSync"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "update"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: D2d_MdmParameterSync.Update?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .update(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .update(let v)? = self.action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_MdmParameterSync, rhs: D2d_MdmParameterSync) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_MdmParameterSync.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D2d_MdmParameterSync.protoMessageName + ".Update"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2d_MdmParameterSync.Update, rhs: D2d_MdmParameterSync.Update) -> Bool {
    if lhs._parameters != rhs._parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
