// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: md-d2m.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// ## Device to Mediator Protocol (Supplementary)
//
// This is a supplementary section to the corresponding structbuf section
// with complementary messages that use protobuf instead of structbuf. All
// defined messages here follow the same logic.
//
// Note that all messages defined here, with the exception of `ClientUrlInfo`,
// are wrapped by `payload.container`.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// D2M protocol versions.
public enum D2m_ProtocolVersion: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Initial D2M protocol version (alpha, may break).
  case v0 // = 0
  case UNRECOGNIZED(Int)

  public init() {
    self = .v0
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .v0
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .v0: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [D2m_ProtocolVersion] = [
    .v0,
  ]

}

/// Policy determining the device slot's lifetime.
public enum D2m_DeviceSlotExpirationPolicy: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// The device slot should be removed shortly after the device
  /// disconnected. However, there should be a delay of several minutes to
  /// ensure that the device can reconnect if it disconnected unintentionally.
  case volatile // = 0

  /// The device slot should be kept as long as possible
  case persistent // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .volatile
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .volatile
    case 1: self = .persistent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .volatile: return 0
    case .persistent: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [D2m_DeviceSlotExpirationPolicy] = [
    .volatile,
    .persistent,
  ]

}

/// Device registration state on the mediator server.
public enum D2m_DeviceSlotState: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// A new device slot has been allocated for the device (i.e. the device's
  /// id was not registered on the server).
  case new // = 0

  /// An existing device slot has been reused for the device (i.e. the
  /// device's id is already registered on the server).
  case existing // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .new
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .new
    case 1: self = .existing
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .new: return 0
    case .existing: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [D2m_DeviceSlotState] = [
    .new,
    .existing,
  ]

}

/// Send along client information when connecting to the mediator server.
///
/// This message is serialized, hex-encoded (lowercase) and then used as the
/// WebSocket path.
///
/// Type: n/a
/// Direction: Client -> Server
public struct D2m_ClientUrlInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 32 byte device group id (`DGPK.public`)
  public var deviceGroupID: Data = Data()

  /// Server group, as assigned by the server when the Threema identity has been
  /// created. Must consist of only digits or ASCII letters (`^[0-9a-zA-Z]+$`).
  public var serverGroup: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Initial message from the server, containing an authentication challenge.
///
/// Type: 0x10
/// Direction: Client <-- Server
public struct D2m_ServerHello: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Highest protocol version (`ProtocolVersion`) the server supports.
  public var version: UInt32 = 0

  /// 32 byte ephemeral server key (`ESK.public`)
  public var esk: Data = Data()

  /// 32 byte random challenge
  public var challenge: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Initial message from the client, containing the authentication challenge
/// response and additional login information.
///
/// Type: 0x11
/// Direction: Client --> Server
public struct D2m_ClientHello: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Protocol version (`ProtocolVersion`) which the client has selected.
  public var version: UInt32 = 0

  /// Challenge response (72 bytes) for authentication.
  ///
  /// The response is created by encrypting the server's challenge in the
  /// following way:
  ///
  /// ```text
  /// XSalsa20-Poly1305(
  ///   key=X25519HSalsa20(DGPK.secret, ESK.public),
  ///   nonce=<random>,
  /// )
  /// ```
  ///
  /// The nonce is then prefixed to the encrypted challenge.
  public var response: Data = Data()

  /// Unique device id
  public var deviceID: UInt64 = 0

  public var deviceSlotsExhaustedPolicy: D2m_ClientHello.DeviceSlotsExhaustedPolicy = .reject

  /// Policy determining the device slot's lifetime
  public var deviceSlotExpirationPolicy: D2m_DeviceSlotExpirationPolicy = .volatile

  /// The expected device slot state on the server.
  ///
  /// If the expected device slot state does not match the actual device slot
  /// state, the device will be dropped by the mediator server with the close
  /// code `4115` before being registered.
  public var expectedDeviceSlotState: D2m_DeviceSlotState = .new

  /// Device info (`d2d.DeviceInfo`), encrypted by `DGDIK.secret` and prefixed
  /// with a random nonce.
  public var encryptedDeviceInfo: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Policy to be applied in case the device id is not registered on the server
  /// and all device slots have been exhausted.
  public enum DeviceSlotsExhaustedPolicy: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Terminate the connection
    case reject // = 0

    /// Drop the least recently used device
    case dropLeastRecent // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .reject
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .reject
      case 1: self = .dropLeastRecent
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .reject: return 0
      case .dropLeastRecent: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [D2m_ClientHello.DeviceSlotsExhaustedPolicy] = [
      .reject,
      .dropLeastRecent,
    ]

  }

  public init() {}
}

/// Parts of the server's configuration and the device slot state.
///
/// Type: 0x12
/// Direction: Client <-- Server
public struct D2m_ServerInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Current Unix-ish timestamp in milliseconds of the server.
  ///
  /// If the client's current timestamp deviates by more than 20 minutes, the
  /// client should disconnect and prompt the user to synchronise its clock.
  /// The user should also have an option to _connect anyway_ which should be
  /// cached for a reasonable amount of time.
  public var currentTime: UInt64 = 0

  /// Maximum number of device slots
  public var maxDeviceSlots: UInt32 = 0

  /// Informs the device about its device slot state on the server
  public var deviceSlotState: D2m_DeviceSlotState = .new

  /// Device data shared among devices (`SharedDeviceData`), encrypted by
  /// `DGSDDK.secret` and prefixed with a random nonce.
  public var encryptedSharedDeviceData: Data = Data()

  /// Amount of messages in the reflection queue that will now be sent to the
  /// device. If the client is up-to-date, the value will be 0.
  ///
  /// Note: The amount of messages in the reflection queue may increase at any
  /// time, so there is no guarantee that `ReflectionQueueDry` will be received
  /// after having received `reflection_queue_length` reflected messages.
  public var reflectionQueueLength: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The device's reflection queue on the server has been fully transmitted to
/// the device.
///
/// Note: This does not mean that reflected messages have already been
///       acknowledged by the device!
///
/// Type: 0x20
/// Direction: Client <-- Server
public struct D2m_ReflectionQueueDry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The device's role has been promoted to leader, indicating that the device
/// should now request to receive and reflect messages from the chat server.
///
/// Type: 0x21
/// Direction: Client <-- Server
public struct D2m_RolePromotedToLeader: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request device information of all devices.
///
/// Type: 0x30
/// Direction: Client --> Server
public struct D2m_GetDevicesInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Device information of all devices.
///
/// Type: 0x31
/// Direction: Client <-- Server
public struct D2m_DevicesInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var augmentedDeviceInfo: Dictionary<UInt64,D2m_DevicesInfo.AugmentedDeviceInfo> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Device id to (augmented) device info map of all devices.
  public struct AugmentedDeviceInfo: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Device info (`d2d.DeviceInfo`), encrypted by `DGDIK.secret` and prefixed
    /// with a random nonce.
    public var encryptedDeviceInfo: Data = Data()

    /// Connection state
    public var connectionState: D2m_DevicesInfo.AugmentedDeviceInfo.OneOf_ConnectionState? = nil

    /// Unix-ish timestamp in milliseconds containing the most recent login
    /// time of the device. Only set if device is currently connected.
    public var connectedSince: UInt64 {
      get {
        if case .connectedSince(let v)? = connectionState {return v}
        return 0
      }
      set {connectionState = .connectedSince(newValue)}
    }

    /// Unix-ish timestamp in milliseconds containing the most recent
    /// disconnect time of the device. Only set if device is not connected.
    public var lastDisconnectAt: UInt64 {
      get {
        if case .lastDisconnectAt(let v)? = connectionState {return v}
        return 0
      }
      set {connectionState = .lastDisconnectAt(newValue)}
    }

    /// Expiration policy of the device.
    public var deviceSlotExpirationPolicy: D2m_DeviceSlotExpirationPolicy = .volatile

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Connection state
    public enum OneOf_ConnectionState: Equatable, Sendable {
      /// Unix-ish timestamp in milliseconds containing the most recent login
      /// time of the device. Only set if device is currently connected.
      case connectedSince(UInt64)
      /// Unix-ish timestamp in milliseconds containing the most recent
      /// disconnect time of the device. Only set if device is not connected.
      case lastDisconnectAt(UInt64)

    }

    public init() {}
  }

  public init() {}
}

/// Request to drop a device and free its device slot.
///
/// Type: 0x32
/// Direction: Client --> Server
public struct D2m_DropDevice: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique device id
  public var deviceID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Acknowledges that a device has been dropped and the device slot has been
/// free'd.
///
/// Type: 0x33
/// Direction: Client <-- Server
public struct D2m_DropDeviceAck: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique device id
  public var deviceID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Set the shared device data which is being sent to each device during login.
///
/// Type: 0x34
/// Direction: Client --> Server
public struct D2m_SetSharedDeviceData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device data shared among devices (`d2d.SharedDeviceData`), encrypted by
  /// `DGSDDK.secret` and prefixed with a random nonce.
  public var encryptedSharedDeviceData: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Acquires a device group lock for an atomic operation shared across the
/// device group.
///
/// Reflection messages from the device to the mediator server will only be
/// reflected once the transaction is committed.
///
/// Type: 0x40
/// Direction: Client --> Server
public struct D2m_BeginTransaction: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transaction scope (`d2d.TransactionScope`), encrypted by
  /// `DGTSK.secret` and prefixed with a random nonce.
  public var encryptedScope: Data = Data()

  /// Time-to-live in seconds for this transaction. Once the TTL is reached, the
  /// mediator server will abort the transaction and disconnect the client. When
  /// set to `0`, the server's maximum transaction TTL will be used.
  public var ttl: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Acknowledges that the device group lock has been acquired and that the
/// transaction has been started.
///
/// Type: 0x41
/// Direction: Client <-- Server
public struct D2m_BeginTransactionAck: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Commits a transaction, releases a device group lock.
///
/// Type: 0x42
/// Direction: Client --> Server
public struct D2m_CommitTransaction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Acknowledges that the transaction has been committed and that the device
/// group lock has been released.
///
/// Type: 0x43
/// Direction: Client <-- Server
public struct D2m_CommitTransactionAck: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A `BeginTransaction` request is rejected because another transaction is
/// already in process.
///
/// Type: 0x44
/// Direction: Client <-- Server
public struct D2m_TransactionRejected: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The device that currently holds the lock
  public var deviceID: UInt64 = 0

  /// The encrypted transaction scope (`d2d.TransactionScope`) associated with
  /// the currently locked transaction, encrypted by `DGTSK.secret` and prefixed
  /// with a random nonce.
  public var encryptedScope: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// When a transaction ends (either because it was committed or because the
/// device disconnected), this message is sent to all connected devices except
/// for the device that committed the transaction.
///
/// This can be used by the other devices as a "retry signal" if a previous
/// "BeginTransaction" attempt was unsuccessful.
///
/// Type: 0x45
/// Direction: Client <-- Server
public struct D2m_TransactionEnded: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The device that held the lock up until now
  public var deviceID: UInt64 = 0

  /// The encrypted transaction scope (`d2d.TransactionScope`) associated with
  /// the transaction that just ended, encrypted by `DGTSK.secret` and prefixed
  /// with a random nonce.
  public var encryptedScope: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "d2m"

extension D2m_ProtocolVersion: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "V0"),
  ]
}

extension D2m_DeviceSlotExpirationPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VOLATILE"),
    1: .same(proto: "PERSISTENT"),
  ]
}

extension D2m_DeviceSlotState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NEW"),
    1: .same(proto: "EXISTING"),
  ]
}

extension D2m_ClientUrlInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientUrlInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [2..<3],
      numberNameMappings: [
        1: .standard(proto: "device_group_id"),
        3: .standard(proto: "server_group"),
  ])

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.deviceGroupID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.serverGroup) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceGroupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceGroupID, fieldNumber: 1)
    }
    if !self.serverGroup.isEmpty {
      try visitor.visitSingularStringField(value: self.serverGroup, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2m_ClientUrlInfo, rhs: D2m_ClientUrlInfo) -> Bool {
    if lhs.deviceGroupID != rhs.deviceGroupID {return false}
    if lhs.serverGroup != rhs.serverGroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_ServerHello: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerHello"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "esk"),
    3: .same(proto: "challenge"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.esk) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.challenge) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.esk.isEmpty {
      try visitor.visitSingularBytesField(value: self.esk, fieldNumber: 2)
    }
    if !self.challenge.isEmpty {
      try visitor.visitSingularBytesField(value: self.challenge, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2m_ServerHello, rhs: D2m_ServerHello) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.esk != rhs.esk {return false}
    if lhs.challenge != rhs.challenge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_ClientHello: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientHello"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "response"),
    3: .standard(proto: "device_id"),
    4: .standard(proto: "device_slots_exhausted_policy"),
    5: .standard(proto: "device_slot_expiration_policy"),
    7: .standard(proto: "expected_device_slot_state"),
    6: .standard(proto: "encrypted_device_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.response) }()
      case 3: try { try decoder.decodeSingularFixed64Field(value: &self.deviceID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.deviceSlotsExhaustedPolicy) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.deviceSlotExpirationPolicy) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.encryptedDeviceInfo) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.expectedDeviceSlotState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.response.isEmpty {
      try visitor.visitSingularBytesField(value: self.response, fieldNumber: 2)
    }
    if self.deviceID != 0 {
      try visitor.visitSingularFixed64Field(value: self.deviceID, fieldNumber: 3)
    }
    if self.deviceSlotsExhaustedPolicy != .reject {
      try visitor.visitSingularEnumField(value: self.deviceSlotsExhaustedPolicy, fieldNumber: 4)
    }
    if self.deviceSlotExpirationPolicy != .volatile {
      try visitor.visitSingularEnumField(value: self.deviceSlotExpirationPolicy, fieldNumber: 5)
    }
    if !self.encryptedDeviceInfo.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedDeviceInfo, fieldNumber: 6)
    }
    if self.expectedDeviceSlotState != .new {
      try visitor.visitSingularEnumField(value: self.expectedDeviceSlotState, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2m_ClientHello, rhs: D2m_ClientHello) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.response != rhs.response {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.deviceSlotsExhaustedPolicy != rhs.deviceSlotsExhaustedPolicy {return false}
    if lhs.deviceSlotExpirationPolicy != rhs.deviceSlotExpirationPolicy {return false}
    if lhs.expectedDeviceSlotState != rhs.expectedDeviceSlotState {return false}
    if lhs.encryptedDeviceInfo != rhs.encryptedDeviceInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_ClientHello.DeviceSlotsExhaustedPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REJECT"),
    1: .same(proto: "DROP_LEAST_RECENT"),
  ]
}

extension D2m_ServerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "current_time"),
    1: .standard(proto: "max_device_slots"),
    2: .standard(proto: "device_slot_state"),
    3: .standard(proto: "encrypted_shared_device_data"),
    5: .standard(proto: "reflection_queue_length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.maxDeviceSlots) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.deviceSlotState) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.encryptedSharedDeviceData) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.currentTime) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.reflectionQueueLength) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxDeviceSlots != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxDeviceSlots, fieldNumber: 1)
    }
    if self.deviceSlotState != .new {
      try visitor.visitSingularEnumField(value: self.deviceSlotState, fieldNumber: 2)
    }
    if !self.encryptedSharedDeviceData.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedSharedDeviceData, fieldNumber: 3)
    }
    if self.currentTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.currentTime, fieldNumber: 4)
    }
    if self.reflectionQueueLength != 0 {
      try visitor.visitSingularUInt32Field(value: self.reflectionQueueLength, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2m_ServerInfo, rhs: D2m_ServerInfo) -> Bool {
    if lhs.currentTime != rhs.currentTime {return false}
    if lhs.maxDeviceSlots != rhs.maxDeviceSlots {return false}
    if lhs.deviceSlotState != rhs.deviceSlotState {return false}
    if lhs.encryptedSharedDeviceData != rhs.encryptedSharedDeviceData {return false}
    if lhs.reflectionQueueLength != rhs.reflectionQueueLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_ReflectionQueueDry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReflectionQueueDry"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2m_ReflectionQueueDry, rhs: D2m_ReflectionQueueDry) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_RolePromotedToLeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RolePromotedToLeader"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2m_RolePromotedToLeader, rhs: D2m_RolePromotedToLeader) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_GetDevicesInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDevicesInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2m_GetDevicesInfo, rhs: D2m_GetDevicesInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_DevicesInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DevicesInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "augmented_device_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufFixed64,D2m_DevicesInfo.AugmentedDeviceInfo>.self, value: &self.augmentedDeviceInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.augmentedDeviceInfo.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufFixed64,D2m_DevicesInfo.AugmentedDeviceInfo>.self, value: self.augmentedDeviceInfo, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2m_DevicesInfo, rhs: D2m_DevicesInfo) -> Bool {
    if lhs.augmentedDeviceInfo != rhs.augmentedDeviceInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_DevicesInfo.AugmentedDeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = D2m_DevicesInfo.protoMessageName + ".AugmentedDeviceInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "encrypted_device_info"),
    2: .standard(proto: "connected_since"),
    4: .standard(proto: "last_disconnect_at"),
    3: .standard(proto: "device_slot_expiration_policy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.encryptedDeviceInfo) }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.connectionState != nil {try decoder.handleConflictingOneOf()}
          self.connectionState = .connectedSince(v)
        }
      }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.deviceSlotExpirationPolicy) }()
      case 4: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.connectionState != nil {try decoder.handleConflictingOneOf()}
          self.connectionState = .lastDisconnectAt(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.encryptedDeviceInfo.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedDeviceInfo, fieldNumber: 1)
    }
    try { if case .connectedSince(let v)? = self.connectionState {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    if self.deviceSlotExpirationPolicy != .volatile {
      try visitor.visitSingularEnumField(value: self.deviceSlotExpirationPolicy, fieldNumber: 3)
    }
    try { if case .lastDisconnectAt(let v)? = self.connectionState {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2m_DevicesInfo.AugmentedDeviceInfo, rhs: D2m_DevicesInfo.AugmentedDeviceInfo) -> Bool {
    if lhs.encryptedDeviceInfo != rhs.encryptedDeviceInfo {return false}
    if lhs.connectionState != rhs.connectionState {return false}
    if lhs.deviceSlotExpirationPolicy != rhs.deviceSlotExpirationPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_DropDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DropDevice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.deviceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceID != 0 {
      try visitor.visitSingularFixed64Field(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2m_DropDevice, rhs: D2m_DropDevice) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_DropDeviceAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DropDeviceAck"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.deviceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceID != 0 {
      try visitor.visitSingularFixed64Field(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2m_DropDeviceAck, rhs: D2m_DropDeviceAck) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_SetSharedDeviceData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetSharedDeviceData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "encrypted_shared_device_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.encryptedSharedDeviceData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.encryptedSharedDeviceData.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedSharedDeviceData, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2m_SetSharedDeviceData, rhs: D2m_SetSharedDeviceData) -> Bool {
    if lhs.encryptedSharedDeviceData != rhs.encryptedSharedDeviceData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_BeginTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BeginTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "encrypted_scope"),
    2: .same(proto: "ttl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.encryptedScope) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.ttl) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.encryptedScope.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedScope, fieldNumber: 1)
    }
    if self.ttl != 0 {
      try visitor.visitSingularUInt32Field(value: self.ttl, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2m_BeginTransaction, rhs: D2m_BeginTransaction) -> Bool {
    if lhs.encryptedScope != rhs.encryptedScope {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_BeginTransactionAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BeginTransactionAck"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2m_BeginTransactionAck, rhs: D2m_BeginTransactionAck) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_CommitTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommitTransaction"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2m_CommitTransaction, rhs: D2m_CommitTransaction) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_CommitTransactionAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommitTransactionAck"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2m_CommitTransactionAck, rhs: D2m_CommitTransactionAck) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_TransactionRejected: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionRejected"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
    2: .standard(proto: "encrypted_scope"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.encryptedScope) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceID != 0 {
      try visitor.visitSingularFixed64Field(value: self.deviceID, fieldNumber: 1)
    }
    if !self.encryptedScope.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedScope, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2m_TransactionRejected, rhs: D2m_TransactionRejected) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.encryptedScope != rhs.encryptedScope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_TransactionEnded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionEnded"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
    2: .standard(proto: "encrypted_scope"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.encryptedScope) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceID != 0 {
      try visitor.visitSingularFixed64Field(value: self.deviceID, fieldNumber: 1)
    }
    if !self.encryptedScope.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedScope, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: D2m_TransactionEnded, rhs: D2m_TransactionEnded) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.encryptedScope != rhs.encryptedScope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
