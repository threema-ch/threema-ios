// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: o2o-call.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// # 1:1 Calls

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Root signaling message
public struct Callsignaling_Envelope {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Random amount of padding (0-255 bytes), ignored by the receiver
  public var padding: Data = Data()

  public var content: Callsignaling_Envelope.OneOf_Content? = nil

  public var videoQualityProfile: Callsignaling_VideoQualityProfile {
    get {
      if case .videoQualityProfile(let v)? = content {return v}
      return Callsignaling_VideoQualityProfile()
    }
    set {content = .videoQualityProfile(newValue)}
  }

  public var captureStateChange: Callsignaling_CaptureState {
    get {
      if case .captureStateChange(let v)? = content {return v}
      return Callsignaling_CaptureState()
    }
    set {content = .captureStateChange(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case videoQualityProfile(Callsignaling_VideoQualityProfile)
    case captureStateChange(Callsignaling_CaptureState)

  #if !swift(>=4.1)
    public static func ==(lhs: Callsignaling_Envelope.OneOf_Content, rhs: Callsignaling_Envelope.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.videoQualityProfile, .videoQualityProfile): return {
        guard case .videoQualityProfile(let l) = lhs, case .videoQualityProfile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.captureStateChange, .captureStateChange): return {
        guard case .captureStateChange(let l) = lhs, case .captureStateChange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// The app switched to a new video quality profile
///
/// In order to be forwards-compatible, the raw configuration of the profile
/// (bitrate, resolution, etc) should also be included in this message. This
/// way, if an unknown enum value is received, the receiver can simply use the
/// raw values instead.
public struct Callsignaling_VideoQualityProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var profile: Callsignaling_VideoQualityProfile.QualityProfile = .max

  /// The max bitrate in kbps
  public var maxBitrateKbps: UInt32 = 0

  /// The max resolution (in landscape orientation)
  public var maxResolution: Common_Resolution {
    get {return _maxResolution ?? Common_Resolution()}
    set {_maxResolution = newValue}
  }
  /// Returns true if `maxResolution` has been explicitly set.
  public var hasMaxResolution: Bool {return self._maxResolution != nil}
  /// Clears the value of `maxResolution`. Subsequent reads from it will return its default value.
  public mutating func clearMaxResolution() {self._maxResolution = nil}

  /// The max framerate
  public var maxFps: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The quality profile
  public enum QualityProfile: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Very high quality, used only when explicitly selected by the user
    case max // = 0

    /// High quality, used by default in non-metered networks
    case high // = 1

    /// Low quality, optimize for bandwidth, used by default in metered networks
    case low // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .max
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .max
      case 1: self = .high
      case 2: self = .low
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .max: return 0
      case .high: return 1
      case .low: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _maxResolution: Common_Resolution? = nil
}

#if swift(>=4.2)

extension Callsignaling_VideoQualityProfile.QualityProfile: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Callsignaling_VideoQualityProfile.QualityProfile] = [
    .max,
    .high,
    .low,
  ]
}

#endif  // swift(>=4.2)

/// Signal changes in the capturing state (e.g. video camera enabled or disabled)
public struct Callsignaling_CaptureState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var state: Callsignaling_CaptureState.Mode = .off

  public var device: Callsignaling_CaptureState.CaptureDevice = .camera

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The capture state of a capturing device
  public enum Mode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Off, not sending any data
    case off // = 0

    /// On, sending data
    case on // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .off
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .off
      case 1: self = .on
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .off: return 0
      case .on: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The capture device type
  public enum CaptureDevice: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Capturing from a camera
    case camera // = 0

    /// Capturing from screen sharing (do not use atm)
    case reservedForScreenShare // = 1

    /// Capturing from a microphone
    case microphone // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .camera
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .camera
      case 1: self = .reservedForScreenShare
      case 2: self = .microphone
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .camera: return 0
      case .reservedForScreenShare: return 1
      case .microphone: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Callsignaling_CaptureState.Mode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Callsignaling_CaptureState.Mode] = [
    .off,
    .on,
  ]
}

extension Callsignaling_CaptureState.CaptureDevice: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Callsignaling_CaptureState.CaptureDevice] = [
    .camera,
    .reservedForScreenShare,
    .microphone,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Callsignaling_Envelope: @unchecked Sendable {}
extension Callsignaling_Envelope.OneOf_Content: @unchecked Sendable {}
extension Callsignaling_VideoQualityProfile: @unchecked Sendable {}
extension Callsignaling_VideoQualityProfile.QualityProfile: @unchecked Sendable {}
extension Callsignaling_CaptureState: @unchecked Sendable {}
extension Callsignaling_CaptureState.Mode: @unchecked Sendable {}
extension Callsignaling_CaptureState.CaptureDevice: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "callsignaling"

extension Callsignaling_Envelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Envelope"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "padding"),
    2: .standard(proto: "video_quality_profile"),
    3: .standard(proto: "capture_state_change"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.padding) }()
      case 2: try {
        var v: Callsignaling_VideoQualityProfile?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .videoQualityProfile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .videoQualityProfile(v)
        }
      }()
      case 3: try {
        var v: Callsignaling_CaptureState?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .captureStateChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .captureStateChange(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.padding.isEmpty {
      try visitor.visitSingularBytesField(value: self.padding, fieldNumber: 1)
    }
    switch self.content {
    case .videoQualityProfile?: try {
      guard case .videoQualityProfile(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .captureStateChange?: try {
      guard case .captureStateChange(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Callsignaling_Envelope, rhs: Callsignaling_Envelope) -> Bool {
    if lhs.padding != rhs.padding {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Callsignaling_VideoQualityProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VideoQualityProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profile"),
    2: .standard(proto: "max_bitrate_kbps"),
    3: .standard(proto: "max_resolution"),
    4: .standard(proto: "max_fps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.profile) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.maxBitrateKbps) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._maxResolution) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.maxFps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.profile != .max {
      try visitor.visitSingularEnumField(value: self.profile, fieldNumber: 1)
    }
    if self.maxBitrateKbps != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxBitrateKbps, fieldNumber: 2)
    }
    try { if let v = self._maxResolution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.maxFps != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxFps, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Callsignaling_VideoQualityProfile, rhs: Callsignaling_VideoQualityProfile) -> Bool {
    if lhs.profile != rhs.profile {return false}
    if lhs.maxBitrateKbps != rhs.maxBitrateKbps {return false}
    if lhs._maxResolution != rhs._maxResolution {return false}
    if lhs.maxFps != rhs.maxFps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Callsignaling_VideoQualityProfile.QualityProfile: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MAX"),
    1: .same(proto: "HIGH"),
    2: .same(proto: "LOW"),
  ]
}

extension Callsignaling_CaptureState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CaptureState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .same(proto: "device"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.device) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .off {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    if self.device != .camera {
      try visitor.visitSingularEnumField(value: self.device, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Callsignaling_CaptureState, rhs: Callsignaling_CaptureState) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.device != rhs.device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Callsignaling_CaptureState.Mode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OFF"),
    1: .same(proto: "ON"),
  ]
}

extension Callsignaling_CaptureState.CaptureDevice: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CAMERA"),
    1: .same(proto: "RESERVED_FOR_SCREEN_SHARE"),
    2: .same(proto: "MICROPHONE"),
  ]
}
